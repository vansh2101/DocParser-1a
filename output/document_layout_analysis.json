{
  "metadata": {
    "totalPages": 34,
    "totalDetections": 164,
    "processingTime": 55.77,
    "averageTimePerPage": "1.64",
    "confidence_threshold": 0.5,
    "processedAt": "2025-07-28T10:01:31.169Z",
    "pdfPath": "./OS-LabFile-HemangJAin_23CS174.pdf",
    "elementTypeCounts": {
      "Text": 97,
      "Picture": 1,
      "Title": 1,
      "Section-header": 46,
      "List-item": 18,
      "Table": 1
    }
  },
  "documentStructure": [
    {
      "id": "default_section_page_1",
      "title": "Content (Page 1)",
      "level": "H1",
      "page": 1,
      "children": [
        {
          "id": "page1_detection5",
          "type": "text",
          "content": "(Formerly Delhi College of Engineering)",
          "bbox": [
            186,
            139,
            564,
            168
          ],
          "bbox_normalized": [
            0.2569,
            0.1357,
            0.779,
            0.1641
          ],
          "page": 1,
          "confidence": 0.568,
          "width": 378,
          "height": 29,
          "area": 10962,
          "reading_order": 1
        },
        {
          "id": "page1_detection1",
          "type": "picture",
          "content": "[Picture - image content]",
          "bbox": [
            255,
            187,
            469,
            402
          ],
          "bbox_normalized": [
            0.3522,
            0.1826,
            0.6478,
            0.3926
          ],
          "page": 1,
          "confidence": 0.906,
          "width": 214,
          "height": 215,
          "area": 46010,
          "reading_order": 2
        }
      ]
    },
    {
      "id": "page1_detection3",
      "title": "DEPARTMENT OF COMPUTER SCIENCE AND ENGINEERING",
      "level": "H1",
      "page": 1,
      "bbox": [
        91,
        448,
        662,
        522
      ],
      "bbox_normalized": [
        0.1257,
        0.4375,
        0.9144,
        0.5098
      ],
      "confidence": 0.697,
      "children": [
        {
          "id": "page1_detection4",
          "type": "text",
          "content": "Dr. Pawan Singh Mehra Assistant Professor CSE Department",
          "bbox": [
            63,
            813,
            293,
            890
          ],
          "bbox_normalized": [
            0.087,
            0.7939,
            0.4047,
            0.8691
          ],
          "page": 1,
          "confidence": 0.61,
          "width": 230,
          "height": 77,
          "area": 17710,
          "reading_order": 4
        },
        {
          "id": "page1_detection2",
          "type": "text",
          "content": "SUBMITTED BY- Hemang Jain Roll No.: 23/CS/174 Batch: CO-A3",
          "bbox": [
            438,
            778,
            652,
            902
          ],
          "bbox_normalized": [
            0.605,
            0.7598,
            0.9006,
            0.8809
          ],
          "page": 1,
          "confidence": 0.806,
          "width": 214,
          "height": 124,
          "area": 26536,
          "reading_order": 5
        },
        {
          "id": "page2_detection9",
          "title": "VISION AND MISSION",
          "level": "H2",
          "page": 2,
          "bbox": [
            289,
            100,
            469,
            116
          ],
          "bbox_normalized": [
            0.3986,
            0.0977,
            0.6469,
            0.1133
          ],
          "confidence": 0.784,
          "children": []
        },
        {
          "id": "page2_detection3",
          "title": "Yision",
          "level": "H2",
          "page": 2,
          "bbox": [
            107,
            164,
            147,
            178
          ],
          "bbox_normalized": [
            0.1476,
            0.1602,
            0.2028,
            0.1738
          ],
          "confidence": 0.879,
          "children": [
            {
              "id": "page2_detection1",
              "type": "text",
              "content": "Department of Computer Science & Engineering to be a leading world class technology department playing ts role as a key node in national and global knowledge network, thus empowering the computer science industry with the wings of knowledge and power of innovation.",
              "bbox": [
                106,
                193,
                627,
                259
              ],
              "bbox_normalized": [
                0.1462,
                0.1885,
                0.8648,
                0.2529
              ],
              "page": 2,
              "confidence": 0.953,
              "width": 521,
              "height": 66,
              "area": 34386,
              "reading_order": 3
            }
          ]
        },
        {
          "id": "page2_detection6",
          "title": "zssion",
          "level": "H2",
          "page": 2,
          "bbox": [
            107,
            311,
            156,
            325
          ],
          "bbox_normalized": [
            0.1476,
            0.3037,
            0.2152,
            0.3174
          ],
          "confidence": 0.832,
          "children": [
            {
              "id": "page2_detection7",
              "type": "text",
              "content": "1he Mission of the department 1s as follows:",
              "bbox": [
                107,
                340,
                367,
                353
              ],
              "bbox_normalized": [
                0.1476,
                0.332,
                0.5062,
                0.3447
              ],
              "page": 2,
              "confidence": 0.83,
              "width": 260,
              "height": 13,
              "area": 3380,
              "reading_order": 5
            },
            {
              "id": "page2_detection8",
              "type": "list_item",
              "content": "1. To nurture talent of students for research, mnovation and excellence in the field of computer engineering starting from Under graduate level.",
              "bbox": [
                76,
                370,
                603,
                413
              ],
              "bbox_normalized": [
                0.1048,
                0.3613,
                0.8317,
                0.4033
              ],
              "page": 2,
              "confidence": 0.794,
              "width": 527,
              "height": 43,
              "area": 22661,
              "reading_order": 6
            },
            {
              "id": "page2_detection4",
              "type": "list_item",
              "content": "2. To develop highly analytical and qualified computer engineers by imparting training on cutting edge technology.",
              "bbox": [
                76,
                430,
                617,
                475
              ],
              "bbox_normalized": [
                0.1048,
                0.4199,
                0.851,
                0.4639
              ],
              "page": 2,
              "confidence": 0.866,
              "width": 541,
              "height": 45,
              "area": 24345,
              "reading_order": 7
            },
            {
              "id": "page2_detection5",
              "type": "list_item",
              "content": "3. To produce socially sensitive computer engineers with professional ethics.",
              "bbox": [
                76,
                493,
                503,
                506
              ],
              "bbox_normalized": [
                0.1048,
                0.4814,
                0.6938,
                0.4941
              ],
              "page": 2,
              "confidence": 0.854,
              "width": 427,
              "height": 13,
              "area": 5551,
              "reading_order": 8
            },
            {
              "id": "page2_detection2",
              "type": "list_item",
              "content": "3. To produce well-rounded, up to date, scientifically tempered, design-oriented engineer and scientists capable of lifelong learning.",
              "bbox": [
                76,
                557,
                594,
                601
              ],
              "bbox_normalized": [
                0.1048,
                0.5439,
                0.8193,
                0.5869
              ],
              "page": 2,
              "confidence": 0.939,
              "width": 518,
              "height": 44,
              "area": 22792,
              "reading_order": 9
            }
          ]
        },
        {
          "id": "page3_detection2",
          "title": "INDEX",
          "level": "H2",
          "page": 3,
          "bbox": [
            338,
            95,
            394,
            111
          ],
          "bbox_normalized": [
            0.4662,
            0.0928,
            0.5434,
            0.1084
          ],
          "confidence": 0.698,
          "children": [
            {
              "id": "page3_detection1",
              "type": "table",
              "content": "BE —— RE Write a C program to simulate the following non- 200824 preemptive CPU scheduling algorithms to find tumaround time and waiting time for a given problem. a) FCFS, b) SIF 2, Write a C program to simulate the following 200824 preemptive CPU scheduling algorithms to find tumaround time and waiting time for a given problem. a) Round Robin b) Priority 3 Write a C program to simulate the following 280824 contiguous memory allocation techniques a) Worst fib) Best ft, c) First fit 4, Write a C program to simulate the following file 04/09/24 allocation strategies. a) Sequential, b) Indexed B Write a C program to simulate Baker's algorithm 11109724 for the purpose of Deadlock avoidance. 6 Write a C program to simulate Banker's algorithm 11109724 for the purpose of Deadlock prevention. 7 Write a C program to simulate page replacement 09/1024 algorithm a) FIFO, b) LRU Write a C program to simulate page replacement 09/1024 algorithm a) LFU, b) Optimal Write a C program to simulate producer consumer 161024 problem using semaphores. Write a C program to simulate disk scheduling 231024 algorithms a) FCFS, b) SCAN.",
              "bbox": [
                73,
                159,
                657,
                906
              ],
              "bbox_normalized": [
                0.1007,
                0.1553,
                0.9062,
                0.8848
              ],
              "page": 3,
              "confidence": 0.963,
              "width": 584,
              "height": 747,
              "area": 436248,
              "reading_order": 2
            }
          ]
        },
        {
          "id": "page4_detection8",
          "title": "Experiment - 1",
          "level": "H2",
          "page": 4,
          "bbox": [
            310,
            92,
            420,
            114
          ],
          "bbox_normalized": [
            0.4276,
            0.0898,
            0.5793,
            0.1113
          ],
          "confidence": 0.689,
          "children": [
            {
              "id": "page4_detection4",
              "type": "text",
              "content": "Aim: Write a C program to simulate the following non-preemptive CPU scheduling algorithms to find turnaround time and waiting time for a given problem. a) FCFS, b) SJF",
              "bbox": [
                81,
                155,
                641,
                195
              ],
              "bbox_normalized": [
                0.1117,
                0.1514,
                0.8841,
                0.1904
              ],
              "page": 4,
              "confidence": 0.919,
              "width": 560,
              "height": 40,
              "area": 22400,
              "reading_order": 2
            }
          ]
        },
        {
          "id": "page4_detection11",
          "title": "Description",
          "level": "H2",
          "page": 4,
          "bbox": [
            81,
            222,
            161,
            241
          ],
          "bbox_normalized": [
            0.1117,
            0.2168,
            0.2221,
            0.2354
          ],
          "confidence": 0.643,
          "children": [
            {
              "id": "page4_detection3",
              "type": "text",
              "content": "FCFS is one of the simplest CPU scheduling algorithms. In this algorithm, the process that arrives first in the ready queue gets executed first. The scheduling is done based on the arrival time of the processes, meaning that processes are served in the order they arrive without preemption. FCFS is easy to implement and understand; however, it can lead to the \"convoy effect,” where short processes wait for a long process to finish, resulting in increased average waiting time.",
              "bbox": [
                81,
                275,
                633,
                377
              ],
              "bbox_normalized": [
                0.1117,
                0.2686,
                0.8731,
                0.3682
              ],
              "page": 4,
              "confidence": 0.96,
              "width": 552,
              "height": 102,
              "area": 56304,
              "reading_order": 4
            }
          ]
        },
        {
          "id": "page4_detection9",
          "title": "Shortest Job First (SJF)",
          "level": "H2",
          "page": 4,
          "bbox": [
            81,
            393,
            220,
            409
          ],
          "bbox_normalized": [
            0.1117,
            0.3838,
            0.3034,
            0.3994
          ],
          "confidence": 0.687,
          "children": [
            {
              "id": "page4_detection2",
              "type": "text",
              "content": "Shortest Job First (SIF) is a non-preemptive scheduling algorithm that selects the process with the smallest burst time (execution time) for execution first. By executing shorter processes before longer ones, SIF can minimize the average waiting time and turnaround time for a set of processes. However, determining the shortest job can be challenging in a real-time system where the lengths of jobs are not known in advance. This algorithm can lead to the \"starvation\" of longer processes if there is a continuous stream of shorter processes arriving.",
              "bbox": [
                80,
                425,
                650,
                527
              ],
              "bbox_normalized": [
                0.1103,
                0.415,
                0.8966,
                0.5146
              ],
              "page": 4,
              "confidence": 0.966,
              "width": 570,
              "height": 102,
              "area": 58140,
              "reading_order": 6
            }
          ]
        },
        {
          "id": "page4_detection5",
          "title": "Theory",
          "level": "H2",
          "page": 4,
          "bbox": [
            81,
            544,
            131,
            562
          ],
          "bbox_normalized": [
            0.1117,
            0.5313,
            0.1807,
            0.5488
          ],
          "confidence": 0.859,
          "children": [
            {
              "id": "page4_detection1",
              "type": "text",
              "content": "CPU scheduling is a crucial aspect of operating systems that determines the order in which processes are executed. The primary goals of CPU scheduling are to maximize CPU utilization, ensure fairmess among processes, minimize tumaround time, waiting time, and response time, and avoid starvation. Different algorithms have different approaches to scheduling, and the choice of algorithm can significantly impact system performance. Non-preemptive algorithms, such as FCFS and SIF, do not allow a currently executing process to be interrupted; instead, they run to completion before the CPU is allocated to the next process.",
              "bbox": [
                80,
                579,
                651,
                697
              ],
              "bbox_normalized": [
                0.1103,
                0.5654,
                0.8979,
                0.6807
              ],
              "page": 4,
              "confidence": 0.968,
              "width": 571,
              "height": 118,
              "area": 67378,
              "reading_order": 8
            }
          ]
        },
        {
          "id": "page4_detection12",
          "title": "Code:",
          "level": "H2",
          "page": 4,
          "bbox": [
            85,
            729,
            129,
            749
          ],
          "bbox_normalized": [
            0.1172,
            0.7119,
            0.1779,
            0.7314
          ],
          "confidence": 0.519,
          "children": [
            {
              "id": "page4_detection7",
              "type": "text",
              "content": "#include <stdio.h>",
              "bbox": [
                81,
                750,
                179,
                767
              ],
              "bbox_normalized": [
                0.1117,
                0.7324,
                0.2469,
                0.749
              ],
              "page": 4,
              "confidence": 0.714,
              "width": 98,
              "height": 17,
              "area": 1666,
              "reading_order": 10
            },
            {
              "id": "page4_detection6",
              "type": "text",
              "content": "int main) { intn; . print \"Enter number of processes: \") scanf(\"%d\", &n);",
              "bbox": [
                79,
                786,
                290,
                854
              ],
              "bbox_normalized": [
                0.109,
                0.7676,
                0.4,
                0.834
              ],
              "page": 4,
              "confidence": 0.734,
              "width": 211,
              "height": 68,
              "area": 14348,
              "reading_order": 11
            },
            {
              "id": "page4_detection10",
              "type": "text",
              "content": "int arrival[n]. burst[n], waiting[n], turnaround[n];",
              "bbox": [
                94,
                871,
                349,
                889
              ],
              "bbox_normalized": [
                0.1297,
                0.8506,
                0.4814,
                0.8682
              ],
              "page": 4,
              "confidence": 0.68,
              "width": 255,
              "height": 18,
              "area": 4590,
              "reading_order": 12
            },
            {
              "id": "page5_detection1",
              "type": "text",
              "content": "wartinglul = for ini = 1 <n; +4) { waiting(i] = waitngfi - 1] + burs - 11; ) for in = 03 <n; ++) { ‘wmaround(i] = waiingfi + burs il; ) print(\"n—— FCFS Scheduling in\"); print \"Process Arrival\\t Burst Waiting { Tumaroundin”): for int = 0: <n; i++) { print\" Ad 9d 5 da, + 1, aval i, burs], waiting], maround{il): ) int toalWaitingF CFS =0, otaTurnaround CFS =0; for in = 0: <n; i++) { total WaitngFCFS += waiting(i: total TumaroundFCFS += turnaround]; ) print(\"Total Waiting Time (FCFS): 9d”, total WaitingF CFS); printf(\"Total Tumaround Time (FCFS): 9d”, otal TumaroundFCFS); for in = 03 <n; ++) { waitingli] = 0; ) for int i= 0: <n- 1; #09) { for (nj =i + 13j < mij) | if burst] > burst[j]) { int tempBurst = burst: burs] = burs: burs] = tempBurst; int tempAival = anivalfil arivall] = arrival; arivall] = tempArival; ) ) ) for in = <n; i++) { waiting(i] = waitngfi - 1] + burs - 11; ) for in = 03 <n; ++) { ‘wmaround(i] = waiting] + burs il; ) print(\"n—— SIF Scheduling i\"); print \"Process't Arrival\\t Burst iW aiting { Tumaroundin”): for (int = 0: <n: iH) |",
              "bbox": [
                92,
                99,
                543,
                996
              ],
              "bbox_normalized": [
                0.1269,
                0.0967,
                0.749,
                0.9727
              ],
              "page": 5,
              "confidence": 0.912,
              "width": 451,
              "height": 897,
              "area": 404547,
              "reading_order": 1
            },
            {
              "id": "page6_detection2",
              "type": "text",
              "content": "printf\" %dt%dt%d\\t%d\\t%d\\n\", 1+ 1, arrival[i], bursti), waiting] 1}, tumaround]i]); } int otalWaitingS JF =, total TumaroundSJF = 0; for (nti =0:i <n: #4) | total WaitingSJF += wating[i]; total TumaroundS JF += tumaround(if} printf \"Total Waiting Time (SJF): %dn\", totalWaitingSJF): printf \"Total Turnaround Time (SIF): %din”, ota TumaroundSJF): retum 0;",
              "bbox": [
                83,
                96,
                539,
                299
              ],
              "bbox_normalized": [
                0.1145,
                0.0938,
                0.7434,
                0.292
              ],
              "page": 6,
              "confidence": 0.916,
              "width": 456,
              "height": 203,
              "area": 92568,
              "reading_order": 1
            }
          ]
        },
        {
          "id": "page6_detection3",
          "title": "Output:",
          "level": "H2",
          "page": 6,
          "bbox": [
            81,
            318,
            136,
            335
          ],
          "bbox_normalized": [
            0.1117,
            0.3105,
            0.1876,
            0.3271
          ],
          "confidence": 0.736,
          "children": [
            {
              "id": "page6_detection1",
              "type": "text",
              "content": "PS D: Viesang\\h) AlFSivoice-segregation\\Smart Farm\\smart-fam cd \"ds \\Hemang\\h) ATS os} Enter. rumber of processes: 4 Enter arrival tim and burst time for process 1: 14 Enter arrival time and burst time for process 2: 2 5 Enter arrival time and burst time for process 3: 3 1 Enter arrival time and burst time for process 4: 4 6 Process Arrival rst Waiting Turnaround 11 4 oe a 2 2 sae 303 1 sw CE Total iting Time (iF): 23 Total Turnaround Time (FCFS): 3 ~-- SIF scheduling Process Arrival Burst baiting Turnaround 13 1 oe a 2 1 4 1s 32 ss ow EN Total waiting Time (536): 16 Total Turnaround Time (SIF): 32 n",
              "bbox": [
                90,
                345,
                563,
                681
              ],
              "bbox_normalized": [
                0.1241,
                0.3369,
                0.7766,
                0.665
              ],
              "page": 6,
              "confidence": 0.923,
              "width": 473,
              "height": 336,
              "area": 158928,
              "reading_order": 3
            }
          ]
        },
        {
          "id": "page7_detection8",
          "title": "Experiment -2",
          "level": "H2",
          "page": 7,
          "bbox": [
            309,
            93,
            421,
            114
          ],
          "bbox_normalized": [
            0.4262,
            0.0908,
            0.5807,
            0.1113
          ],
          "confidence": 0.657,
          "children": [
            {
              "id": "page7_detection4",
              "type": "text",
              "content": "Aim: Write a C program to simulate the following preemptive CPU scheduling algorithms to find turnaround time and waiting time for a given problem. a) Round Robin b) Priority",
              "bbox": [
                81,
                155,
                641,
                195
              ],
              "bbox_normalized": [
                0.1117,
                0.1514,
                0.8841,
                0.1904
              ],
              "page": 7,
              "confidence": 0.926,
              "width": 560,
              "height": 40,
              "area": 22400,
              "reading_order": 2
            }
          ]
        },
        {
          "id": "page7_detection7",
          "title": "Description:",
          "level": "H2",
          "page": 7,
          "bbox": [
            81,
            220,
            167,
            239
          ],
          "bbox_normalized": [
            0.1117,
            0.2148,
            0.2303,
            0.2334
          ],
          "confidence": 0.683,
          "children": [
            {
              "id": "page7_detection1",
              "type": "text",
              "content": "Round Robin (RR): The Round Robin (RR) scheduling algorithm assigns a fixed time quantum (or time slice) to each process ina cyclic order. Each process is given a small portion of CPU time in a round-robin manner. If a process does not finish execution within its time slice, it is placed back in the queue for another tum. This continues until all processes are completed.",
              "bbox": [
                80,
                255,
                648,
                323
              ],
              "bbox_normalized": [
                0.1103,
                0.249,
                0.8938,
                0.3154
              ],
              "page": 7,
              "confidence": 0.952,
              "width": 568,
              "height": 68,
              "area": 38624,
              "reading_order": 4
            },
            {
              "id": "page7_detection2",
              "type": "text",
              "content": "Priority Scheduling: Priority Scheduling assigns priorities to processes, where a higher priority value indicates a higher priority for execution. In the preemptive version of this algorithm, a process with a higher priority can preempt a currently inning process, meaning the currently running process may be interrupted if a new process with a higher priority arrives.",
              "bbox": [
                81,
                338,
                646,
                407
              ],
              "bbox_normalized": [
                0.1117,
                0.3301,
                0.891,
                0.3975
              ],
              "page": 7,
              "confidence": 0.945,
              "width": 565,
              "height": 69,
              "area": 38985,
              "reading_order": 5
            }
          ]
        },
        {
          "id": "page7_detection6",
          "title": "Theory:",
          "level": "H2",
          "page": 7,
          "bbox": [
            81,
            424,
            144,
            443
          ],
          "bbox_normalized": [
            0.1117,
            0.4141,
            0.1986,
            0.4326
          ],
          "confidence": 0.7,
          "children": [
            {
              "id": "page7_detection5",
              "type": "text",
              "content": "Round Robin Scheduling: The process that gets the CPU for a time quantum and does not finish in that quantum is put back into the ready queue, while the next process gets executed. The round-robin algorithm is fair but can result in high turnaround time if processes have large burst times compared to the time quantum.",
              "bbox": [
                80,
                459,
                640,
                528
              ],
              "bbox_normalized": [
                0.1103,
                0.4482,
                0.8828,
                0.5156
              ],
              "page": 7,
              "confidence": 0.86,
              "width": 560,
              "height": 69,
              "area": 38640,
              "reading_order": 7
            },
            {
              "id": "page7_detection3",
              "type": "text",
              "content": "Priority Scheduling: In preemptive priority scheduling, the process with the highest priority (numerically lower value) gets the CPU. If a new process with higher priority arrives while another process is running, the current process is preempted, and the new process is executed.",
              "bbox": [
                80,
                543,
                632,
                596
              ],
              "bbox_normalized": [
                0.1103,
                0.5303,
                0.8717,
                0.582
              ],
              "page": 7,
              "confidence": 0.939,
              "width": 552,
              "height": 53,
              "area": 29256,
              "reading_order": 8
            },
            {
              "id": "page7_detection9",
              "type": "text",
              "content": "finclude <sidio > truct Process | int id: int burst; int arival; int remaining Burs; int waiting, int wmarounds int priority; : void roundR obinstruct Process proc], int, int time Quantum) | int otalTime =0: int completed = 0; inti; int oWaiting = 0, total Tumaround = 0; while (completed <1) { for (i=0; i< m i++) {",
              "bbox": [
                82,
                642,
                417,
                995
              ],
              "bbox_normalized": [
                0.1131,
                0.627,
                0.5752,
                0.9717
              ],
              "page": 7,
              "confidence": 0.613,
              "width": 335,
              "height": 353,
              "area": 118255,
              "reading_order": 9
            },
            {
              "id": "page8_detection1",
              "type": "text",
              "content": "if (proc{i].remainingBurst > 0) { if (rocli] remainingBurst > timeQuantum) { totalTime += time Quantu; proc] remaining Burst — time Quantum; else { totalTime +— proc{i] remainingBurst: procli] waiting = totalTime - procfi] burst, procli]umaround = procfi] waiting + proc|i] burst totalWaiting += proc{i] waiting: totalTumaround + procfi] umaround; procli] remaining Burst = 0; completed-+; ) ) ) ) printf(\"nRound Robin Schedulingin’): printf(\"Process Burs Waiting Tumaroundin\"): for(i=0ri< ms i+) { printf\" t%d 2d 81%dn’. proc. id. proc) burst, proc] waiting. proc(i]tumaround): ) printf(\" Average Waiting Time: %2fn\", (float total Waiting / 1): printf(\" Average Tumaround Time: %. 20\", (float)otal Turnaround /n): ) void priority Scheduling(struct Process proc{], int 1) { int otalTime = 0; int completed = 0; inti; int totalWaiting = 0, total Tamaround = 0; int highestPrioritylds: while (completed < ) { highestPriortyldx = -1; int highestPriority 9999: for(i =0:i< m i++) { if (proc]i].remining Burst > 0 && prac] priority < highestPriority) { highestPriority proc(i. priority; highestPriorityldx =i; ) ) if (highestPriorityldx 1=-1) { total Time + proc{highestPriorityld] remainingBurst: procihighestPriorityldx] waiting ~ total Time - proc[highestPriorityldx] burst prochighestPriorityldx] tumaround proc highestPriorityldx waiting + procihighestPriorityldx] burst; total Waiting += proc highestPriority ld] waiting; total Tumaround += prac[highestPriorityldx] turnaround; procihighestPriorityldx] remaining Burst = 0;",
              "bbox": [
                79,
                94,
                576,
                995
              ],
              "bbox_normalized": [
                0.109,
                0.0918,
                0.7945,
                0.9717
              ],
              "page": 8,
              "confidence": 0.706,
              "width": 497,
              "height": 901,
              "area": 447797,
              "reading_order": 1
            },
            {
              "id": "page9_detection1",
              "type": "text",
              "content": "completed++; ) ) printf(\"nPriority Schedulingn\"): printf(\"Processi Priority tBurs( Waiting Turnaround\\n\"): for(i=0ri< mi) { printf\" did 4% %d 02d\", proc id, proc{il priority, proc burst, procli] waiting, proc(i] tumaround); ) printf(\" Average Waiting Time: %2fn\", (float total Waiting / 1): printf(\" Average Tumaround Time: %. 20\", (float)otal Turnaround /n): ] int main() { int n, timeQuantum; printf(\"Enter number of processes: ); scanf(\"%d\", &n): struct Process proc[n; for (inti = 0; i <n; 44) | printf{\"Enter arrival time, burst time and priority for process %d:\". i + 1); scanf{\"%d %d %d\", &proc[i] rival, profi] burst, &procfi] priority); proc(ilid=i+ 1; proc(i] remaining Burst proc[i] burst proc(i] waiting = 0; procfi]tumaround = 0; ) printf(\"Enter time quantum for Round Robin: \"), scanf(\" 4d\", &time Quantum): roundRobin(proc, n, time Quantum): for (inti = 0; i< n: 44) | proc(i] remaining Burst = proc[i] burst ) priorityScheduling(proc, n); retum 0; y",
              "bbox": [
                80,
                94,
                585,
                837
              ],
              "bbox_normalized": [
                0.1103,
                0.0918,
                0.8069,
                0.8174
              ],
              "page": 9,
              "confidence": 0.901,
              "width": 505,
              "height": 743,
              "area": 375215,
              "reading_order": 1
            }
          ]
        },
        {
          "id": "page10_detection2",
          "title": "vuiput:",
          "level": "H2",
          "page": 10,
          "bbox": [
            89,
            97,
            142,
            110
          ],
          "bbox_normalized": [
            0.1228,
            0.0947,
            0.1959,
            0.1074
          ],
          "confidence": 0.573,
          "children": [
            {
              "id": "page10_detection1",
              "type": "text",
              "content": "-\\os-2 } Enter musber of processes: 4 Enter arrival time, burst time and priority for process 1: 13 1 Enter arrival tise, burst time and priority for process 2: 24 5 Enter arrival tise, burst time and priority for process 3: 3 6 2 Enter arrival tie, burst time and priority for process 4: 4 2 3 Enter time quantum for Round Robin: 2 Round Robin Scheduling Process Burst Waiting Turnaround 1 3 6 9 2 a 7 1u 3 6 9 15 a 2 6 8 Average Waiting Time: 7.00 Average Turnaround Tie: 10.75 priority scheduling Process Priority Burst Waiting Turnaround 1 1 3 0) 3 2 5 a un 15 3 2 6 3 B a H 2 ° nu Average Waiting Time: 5.75 Average Turnaround Time: 9.50 ~",
              "bbox": [
                91,
                121,
                516,
                520
              ],
              "bbox_normalized": [
                0.1255,
                0.1182,
                0.7117,
                0.5078
              ],
              "page": 10,
              "confidence": 0.631,
              "width": 425,
              "height": 399,
              "area": 169575,
              "reading_order": 2
            }
          ]
        },
        {
          "id": "page11_detection14",
          "title": "Experiment -3",
          "level": "H2",
          "page": 11,
          "bbox": [
            309,
            94,
            421,
            115
          ],
          "bbox_normalized": [
            0.4262,
            0.0918,
            0.5807,
            0.1123
          ],
          "confidence": 0.63,
          "children": [
            {
              "id": "page11_detection12",
              "type": "text",
              "content": "Worst fit, b) Best fit, ¢) First fit",
              "bbox": [
                81,
                177,
                269,
                196
              ],
              "bbox_normalized": [
                0.1117,
                0.1729,
                0.371,
                0.1914
              ],
              "page": 11,
              "confidence": 0.664,
              "width": 188,
              "height": 19,
              "area": 3572,
              "reading_order": 2
            }
          ]
        },
        {
          "id": "page11_detection10",
          "title": "Description:",
          "level": "H2",
          "page": 11,
          "bbox": [
            81,
            221,
            167,
            241
          ],
          "bbox_normalized": [
            0.1117,
            0.2158,
            0.2303,
            0.2354
          ],
          "confidence": 0.806,
          "children": [
            {
              "id": "page11_detection3",
              "type": "text",
              "content": "In contiguous memory allocation, the operating system assigns a single contiguous block of memory to each process. The three different allocation strategies (Worst fit, Best fit, First fit) detemine how memory is assigned. Each algorithm has its own method of selecting the memory block, with trade-offs in efficiency and the way memory is utilized.",
              "bbox": [
                81,
                256,
                651,
                324
              ],
              "bbox_normalized": [
                0.1117,
                0.25,
                0.8979,
                0.3164
              ],
              "page": 11,
              "confidence": 0.975,
              "width": 570,
              "height": 68,
              "area": 38760,
              "reading_order": 4
            },
            {
              "id": "page11_detection5",
              "type": "list_item",
              "content": "1. Worst Fit: This algorithm chooses the block of memory that is the largest among all available blocks. This is done under the assumption that leaving large gaps will leave space for future processes.",
              "bbox": [
                103,
                339,
                628,
                392
              ],
              "bbox_normalized": [
                0.1421,
                0.3311,
                0.8662,
                0.3828
              ],
              "page": 11,
              "confidence": 0.968,
              "width": 525,
              "height": 53,
              "area": 27825,
              "reading_order": 5
            },
            {
              "id": "page11_detection1",
              "type": "list_item",
              "content": "2. Best Fit: This algorithm selects the smallest block that is large enough to fit the process, ‘minimizing the leftover unused space in memory.",
              "bbox": [
                103,
                389,
                645,
                426
              ],
              "bbox_normalized": [
                0.1421,
                0.3799,
                0.8897,
                0.416
              ],
              "page": 11,
              "confidence": 0.976,
              "width": 542,
              "height": 37,
              "area": 20054,
              "reading_order": 6
            },
            {
              "id": "page11_detection6",
              "type": "list_item",
              "content": "3. First Fit: This algorithm assigns the first block of memory that is large enough for the process, which is simple and fast but may leave smaller gaps in memory.",
              "bbox": [
                102,
                424,
                636,
                460
              ],
              "bbox_normalized": [
                0.1407,
                0.4141,
                0.8772,
                0.4492
              ],
              "page": 11,
              "confidence": 0.961,
              "width": 534,
              "height": 36,
              "area": 19224,
              "reading_order": 7
            }
          ]
        },
        {
          "id": "page11_detection9",
          "title": "Theory:",
          "level": "H2",
          "page": 11,
          "bbox": [
            81,
            491,
            144,
            512
          ],
          "bbox_normalized": [
            0.1117,
            0.4795,
            0.1986,
            0.5
          ],
          "confidence": 0.861,
          "children": [
            {
              "id": "page11_detection4",
              "type": "text",
              "content": "0 Memory Fragmentation: Over time, as processes are loaded and removed, free memory is split into smaller and smaller blocks. This can lead to internal fragmentation (unused space within allocated blocks) and external fragmentation (unused memory between blocks).",
              "bbox": [
                81,
                528,
                641,
                579
              ],
              "bbox_normalized": [
                0.1117,
                0.5156,
                0.8841,
                0.5654
              ],
              "page": 11,
              "confidence": 0.969,
              "width": 560,
              "height": 51,
              "area": 28560,
              "reading_order": 9
            },
            {
              "id": "page11_detection7",
              "type": "text",
              "content": "11 Contiguous Memory Allocation: In this scheme, cach process is allocated a single continuous block of memory.",
              "bbox": [
                81,
                595,
                593,
                631
              ],
              "bbox_normalized": [
                0.1117,
                0.5811,
                0.8179,
                0.6162
              ],
              "page": 11,
              "confidence": 0.952,
              "width": 512,
              "height": 36,
              "area": 18432,
              "reading_order": 10
            },
            {
              "id": "page11_detection2",
              "type": "text",
              "content": "0 Memory Allocation Algorithms: The three algorithms help in minimizing fragmentation and efficiently allocating memory, but they have different ways of selecting which block to assign toa Process.",
              "bbox": [
                81,
                645,
                630,
                698
              ],
              "bbox_normalized": [
                0.1117,
                0.6299,
                0.869,
                0.6816
              ],
              "page": 11,
              "confidence": 0.975,
              "width": 549,
              "height": 53,
              "area": 29097,
              "reading_order": 11
            }
          ]
        },
        {
          "id": "page11_detection11",
          "title": "Code:",
          "level": "H2",
          "page": 11,
          "bbox": [
            81,
            713,
            124,
            733
          ],
          "bbox_normalized": [
            0.1117,
            0.6963,
            0.171,
            0.7158
          ],
          "confidence": 0.742,
          "children": [
            {
              "id": "page11_detection13",
              "type": "text",
              "content": "#include <stdio.h>",
              "bbox": [
                81,
                733,
                179,
                751
              ],
              "bbox_normalized": [
                0.1117,
                0.7158,
                0.2469,
                0.7334
              ],
              "page": 11,
              "confidence": 0.633,
              "width": 98,
              "height": 18,
              "area": 1764,
              "reading_order": 13
            },
            {
              "id": "page11_detection8",
              "type": "text",
              "content": "void worstFit(int blockSize[], int m, int processSize{], int n) { int allocation(n]: for (inti = 0: 1 #4) | allocation[i] =-1 } for (inti = 0: i< #4) | int maxlndex =-1: for (nt = 05] <mzj+) if (blockSizej] > processSizefi]) | if (maxlndex = -1 | BlockSizelj] > bockSizelmaxindex) | ‘maxindex =f; )",
              "bbox": [
                81,
                769,
                439,
                993
              ],
              "bbox_normalized": [
                0.1117,
                0.751,
                0.6055,
                0.9697
              ],
              "page": 11,
              "confidence": 0.903,
              "width": 358,
              "height": 224,
              "area": 80192,
              "reading_order": 14
            },
            {
              "id": "page12_detection1",
              "type": "text",
              "content": "i } if (maxindex 1=-1) { allocaioni] = maxindex; blockSize[maxndex] = processSizeliJ: } } printf(\"nWarst Fit Allocation'n\"): printf(\"Process No. Process Size Black No.tBlack Sizeln'); for (inti = 0: i< #4) | if allocatonfi] =-1) PAR CAA %d An\", + 1. processSize[i. allocationf] + 1, blockSize allocation]: else PrABA\" 9d 4% Not Allocated i+ 1, processSizell): } ] void bestFiint lockSize], int m, int processSizel], nt) { int allocation(n]: for (inti = 0: 1< #4) | allocation[i] =-1 } for (inti = 0: i< #4) | int bestindex =-15 for (nt = 05] <mzj+) if (blockSizej] >= processSizefil) { if (bestindex —-1 | blockSiz(j] < blockSize{bestindex]) | bastindex =; } } } if (estindex 1= 1) { allocationfi] = bestindex: blockSizelbestindex] = processSizeli; } } printf(\"nBest Fit Allocation’); printf(\"Process No. Process Size Black No.tBlack Sizeln'); for (inti = 0: 1< #4) | if allocationfi] =-1) PAR CAA %d An\", + 1. processSize[i. allocationf] + 1, blockSize allocation]: else PrABA\" 9d 4% Not Allocated i+ 1, processSizell): } ] void firstFit(int blockSize[], int m, int pracessSize[], it n) {",
              "bbox": [
                80,
                97,
                615,
                997
              ],
              "bbox_normalized": [
                0.1103,
                0.0947,
                0.8483,
                0.9736
              ],
              "page": 12,
              "confidence": 0.945,
              "width": 535,
              "height": 900,
              "area": 481500,
              "reading_order": 1
            },
            {
              "id": "page13_detection1",
              "type": "text",
              "content": "int allocation]; for (inti = 0: 1 #4) | allocationfi] =-1: ) for (inti = 0:1 < #4) | for (nt = 05] < mz) if (blockSizej] >= processSizefil) { allocationfi] = J; blockSizelj] = processSizel; break; ) ) ) printf(\"nFirst Fit Allocationn\"): printf(\"Process No. Process Size! Block No Block Sizeln\"): for (inti = 0: i< #4) | if allocation(i] 1=-1) PHB\" %d CAAA An\", + 1. processSize[i. allocationfi] + 1. blockSizelallocatonfi): ele printf\" 4d 4% Not Allocatedn’, i + 1, processSizeli); ) ] int main() { int m,n; printf(\"Enter the number of memory blocks: ); scanf(\" id\", &m); int blockSize[m]: printf(\"Enter the sizes of memory blacks: \"): for (inti = 0: i< m: i++) { scanf{\"%d\", &blockSizeli); ) printf(\"Enter the number of processes: \"), scanf(\"%d\", &n): int processSizefnl; printf(\"Enter the sizes of processes: \"); for (inti = 0: i< #4) | scanf{\"%d\", &processSizefi]): ) worstFit(blockSize, m, processSize, nf. bestFit(block Size, m, processSize, n); firsFit(blockSize, m, processSize, n): retum 0; N",
              "bbox": [
                80,
                90,
                614,
                992
              ],
              "bbox_normalized": [
                0.1103,
                0.0879,
                0.8469,
                0.9688
              ],
              "page": 13,
              "confidence": 0.941,
              "width": 534,
              "height": 902,
              "area": 481668,
              "reading_order": 1
            }
          ]
        },
        {
          "id": "page14_detection1",
          "title": "Output:",
          "level": "H2",
          "page": 14,
          "bbox": [
            88,
            141,
            142,
            155
          ],
          "bbox_normalized": [
            0.1214,
            0.1377,
            0.1959,
            0.1514
          ],
          "confidence": 0.755,
          "children": []
        },
        {
          "id": "page15_detection12",
          "title": "Experiment -4",
          "level": "H2",
          "page": 15,
          "bbox": [
            334,
            94,
            451,
            116
          ],
          "bbox_normalized": [
            0.4217,
            0.0918,
            0.5694,
            0.1133
          ],
          "confidence": 0.611,
          "children": [
            {
              "id": "page15_detection6",
              "type": "text",
              "content": "Aim: Write a C program to simulate the following file allocation strategies. a) Sequential, b) Indexed",
              "bbox": [
                105,
                159,
                673,
                203
              ],
              "bbox_normalized": [
                0.1326,
                0.1553,
                0.8497,
                0.1982
              ],
              "page": 15,
              "confidence": 0.881,
              "width": 568,
              "height": 44,
              "area": 24992,
              "reading_order": 2
            }
          ]
        },
        {
          "id": "page15_detection7",
          "title": "Description:",
          "level": "H2",
          "page": 15,
          "bbox": [
            105,
            229,
            192,
            249
          ],
          "bbox_normalized": [
            0.1326,
            0.2236,
            0.2424,
            0.2432
          ],
          "confidence": 0.817,
          "children": [
            {
              "id": "page15_detection2",
              "type": "text",
              "content": "In Sequential Allocation, files are stored in contiguous blocks on the disk. This means that when a file is created, it occupies a series of consecutive disk blocks, allowing for easy and fast sequential access. However, this method can lead to issues like fragmentation when files are deleted, making it harder to find contiguous free space for new files.",
              "bbox": [
                105,
                265,
                676,
                339
              ],
              "bbox_normalized": [
                0.1326,
                0.2588,
                0.8535,
                0.3311
              ],
              "page": 15,
              "confidence": 0.958,
              "width": 571,
              "height": 74,
              "area": 42254,
              "reading_order": 4
            },
            {
              "id": "page15_detection3",
              "type": "text",
              "content": "In Indexed Allocation, each file has an index block that contains pointers to all the disk blocks allocated to that file. This allows non-contiguous allocation of files, which can lead 0 better utilization of disk space. While accessing a file may require an additional read to get the index block, it significantly reduces fragmentation and allows for efficient file management.",
              "bbox": [
                105,
                355,
                670,
                446
              ],
              "bbox_normalized": [
                0.1326,
                0.3467,
                0.846,
                0.4355
              ],
              "page": 15,
              "confidence": 0.955,
              "width": 565,
              "height": 91,
              "area": 51415,
              "reading_order": 5
            },
            {
              "id": "page15_detection5",
              "type": "text",
              "content": "71 File Allocation: The method by which files are stored in memory and how they are accessed by the operating system. Effective file allocation is essential for maximizing disk utilization and minimizing access time.",
              "bbox": [
                105,
                498,
                670,
                554
              ],
              "bbox_normalized": [
                0.1326,
                0.4863,
                0.846,
                0.541
              ],
              "page": 15,
              "confidence": 0.941,
              "width": 565,
              "height": 56,
              "area": 31640,
              "reading_order": 6
            },
            {
              "id": "page15_detection4",
              "type": "text",
              "content": "| Sequential Allocation: Stores files in a contiguous manner, leading to fast access but potential fragmentation issues.",
              "bbox": [
                105,
                570,
                661,
                607
              ],
              "bbox_normalized": [
                0.1326,
                0.5566,
                0.8346,
                0.5928
              ],
              "page": 15,
              "confidence": 0.947,
              "width": 556,
              "height": 37,
              "area": 20572,
              "reading_order": 7
            },
            {
              "id": "page15_detection1",
              "type": "text",
              "content": "J Indexed Allocation: Uses an index to track file blocks, allowing for non-contiguous storage and better space utilization, though it may introduce overhead due to additional reads.",
              "bbox": [
                105,
                624,
                655,
                679
              ],
              "bbox_normalized": [
                0.1326,
                0.6094,
                0.827,
                0.6631
              ],
              "page": 15,
              "confidence": 0.959,
              "width": 550,
              "height": 55,
              "area": 30250,
              "reading_order": 8
            }
          ]
        },
        {
          "id": "page15_detection8",
          "title": "Code:",
          "level": "H2",
          "page": 15,
          "bbox": [
            109,
            695,
            156,
            718
          ],
          "bbox_normalized": [
            0.1376,
            0.6787,
            0.197,
            0.7012
          ],
          "confidence": 0.8,
          "children": [
            {
              "id": "page15_detection9",
              "type": "text",
              "content": "#include <stdio.h>",
              "bbox": [
                106,
                719,
                207,
                735
              ],
              "bbox_normalized": [
                0.1338,
                0.7021,
                0.2614,
                0.7178
              ],
              "page": 15,
              "confidence": 0.79,
              "width": 101,
              "height": 16,
              "area": 1616,
              "reading_order": 10
            },
            {
              "id": "page15_detection10",
              "type": "text",
              "content": "void sequential Allocation(int fileSizes[], int n, int blockSize) { int allocated[r); for (inti = 0; <n; i+) { if (blockSize >= fileSizesfi]) { allocated[i] = 1; lockSize -= fileSizesli); else { allocated[i] 0; ’ ¥",
              "bbox": [
                106,
                755,
                443,
                936
              ],
              "bbox_normalized": [
                0.1338,
                0.7373,
                0.5593,
                0.9141
              ],
              "page": 15,
              "confidence": 0.782,
              "width": 337,
              "height": 181,
              "area": 60997,
              "reading_order": 11
            },
            {
              "id": "page15_detection11",
              "type": "text",
              "content": "printf\" nSequential Allocation'n\"); orintf(\"File No.\\tFile Size'tAllocated\\n\"):",
              "bbox": [
                118,
                958,
                345,
                993
              ],
              "bbox_normalized": [
                0.149,
                0.9355,
                0.4356,
                0.9697
              ],
              "page": 15,
              "confidence": 0.613,
              "width": 227,
              "height": 35,
              "area": 7945,
              "reading_order": 12
            },
            {
              "id": "page16_detection1",
              "type": "text",
              "content": "for (inti =0;i <n; i+) { printf \"odd sin\", i + 1, fleSizesfi], allocated[i] ? \"Yes\" : \"Nof); ’ } void indexedAllocation(int fileSizes[), int n) { int index(n]; printf(\"nindexed Allocation'n’); printf(\"File No tFile Size'tIndex Block\\n\"); for (inti = 0; <n; 1+) { index[i) =i * 5; // Example index block position printf \"od dod”, i + 1, fileSizes(i). index(i]); ’ } int main() { int; printf(\"Enter the number of files: \"); scanfi\"%d\", &n); int fileSizes[n); printf(\"Enter the sizes of the files: \"); for (inti = 0; <m; i+) { seanf(\"%%d\", &fleSizes(il); ’ int blockSize; printf(\"Enter the total size of the disk block: ); scanfi\"Vd\", &eblockSize); sequentialAllocation(fileSizes, n, blockSize); indexedAllocation(fileSizes, n); retum 0; }",
              "bbox": [
                104,
                94,
                532,
                756
              ],
              "bbox_normalized": [
                0.1313,
                0.0918,
                0.6717,
                0.7383
              ],
              "page": 16,
              "confidence": 0.929,
              "width": 428,
              "height": 662,
              "area": 283336,
              "reading_order": 1
            }
          ]
        },
        {
          "id": "page17_detection1",
          "title": "Output:",
          "level": "H2",
          "page": 17,
          "bbox": [
            111,
            95,
            169,
            112
          ],
          "bbox_normalized": [
            0.1402,
            0.0928,
            0.2134,
            0.1094
          ],
          "confidence": 0.738,
          "children": [
            {
              "id": "page17_detection2",
              "type": "text",
              "content": "Cl a: Vemang\\n) AlN Nos } Enter the number of files: 3 enter the sizes of the files: 50 100 150 enter the total size of the disk block: 300 Sequential Allocation File No. File Size Allocated 1 so Yes 2 100 Yes 3 150 Yes Indexed Allocation File No. File size Index Block 1 0 0 2 100 5 3 150 10 PS D:\\Hemang\\hj AIMS\\voice-segregation\\smart Farm\\smart-farm> |",
              "bbox": [
                111,
                144,
                674,
                444
              ],
              "bbox_normalized": [
                0.1402,
                0.1406,
                0.851,
                0.4336
              ],
              "page": 17,
              "confidence": 0.595,
              "width": 563,
              "height": 300,
              "area": 168900,
              "reading_order": 2
            }
          ]
        },
        {
          "id": "page18_detection10",
          "title": "Experiment - 5",
          "level": "H2",
          "page": 18,
          "bbox": [
            333,
            94,
            452,
            116
          ],
          "bbox_normalized": [
            0.4205,
            0.0918,
            0.5707,
            0.1133
          ],
          "confidence": 0.656,
          "children": [
            {
              "id": "page18_detection2",
              "type": "text",
              "content": "Aim: Write a C program to simulate Banker's algorithm for the purpose of Deadlock avoidance.",
              "bbox": [
                104,
                140,
                674,
                183
              ],
              "bbox_normalized": [
                0.1313,
                0.1367,
                0.851,
                0.1787
              ],
              "page": 18,
              "confidence": 0.958,
              "width": 570,
              "height": 43,
              "area": 24510,
              "reading_order": 2
            }
          ]
        },
        {
          "id": "page18_detection6",
          "title": "Description:",
          "level": "H2",
          "page": 18,
          "bbox": [
            105,
            211,
            188,
            230
          ],
          "bbox_normalized": [
            0.1326,
            0.2061,
            0.2374,
            0.2246
          ],
          "confidence": 0.837,
          "children": [
            {
              "id": "page18_detection1",
              "type": "text",
              "content": "The Banker's algorithm works by simulating the allocation of resources to processes based on their maximum needs and current availability. Each process must declare its maximum resource needs in advance. When a process requests resources, the system checks if granting that request would leave the system in a safe state. Ifthe request can be granted while keeping the system ina safe state, the resources are allocated; otherwise, the process must wait. The algorithm effectively prevents deadlock by ensuring that resource allocation always leads to a safe sequence of execution for the processes.",
              "bbox": [
                104,
                238,
                683,
                364
              ],
              "bbox_normalized": [
                0.1313,
                0.2324,
                0.8624,
                0.3555
              ],
              "page": 18,
              "confidence": 0.967,
              "width": 579,
              "height": 126,
              "area": 72954,
              "reading_order": 4
            }
          ]
        },
        {
          "id": "page18_detection8",
          "title": "Theory:",
          "level": "H2",
          "page": 18,
          "bbox": [
            105,
            391,
            162,
            409
          ],
          "bbox_normalized": [
            0.1326,
            0.3818,
            0.2045,
            0.3994
          ],
          "confidence": 0.749,
          "children": [
            {
              "id": "page18_detection5",
              "type": "text",
              "content": "| Deadlock: A situation in which two or more processes are unable to proceed because each is waiting for the other to release resources.",
              "bbox": [
                105,
                423,
                660,
                461
              ],
              "bbox_normalized": [
                0.1326,
                0.4131,
                0.8333,
                0.4502
              ],
              "page": 18,
              "confidence": 0.859,
              "width": 555,
              "height": 38,
              "area": 21090,
              "reading_order": 6
            },
            {
              "id": "page18_detection7",
              "type": "text",
              "content": "71 Safe State: A condition where the system can allocate resources to processes in a manner that guarantees all processes can complete without causing deadlock.",
              "bbox": [
                105,
                460,
                637,
                497
              ],
              "bbox_normalized": [
                0.1326,
                0.4492,
                0.8043,
                0.4854
              ],
              "page": 18,
              "confidence": 0.798,
              "width": 532,
              "height": 37,
              "area": 19684,
              "reading_order": 7
            },
            {
              "id": "page18_detection3",
              "type": "text",
              "content": "I Resource Allocation: The process of assigning available resources to various processes in a system. The Banker's algorithm simulates this allocation while ensuring the system remains in a safe state.",
              "bbox": [
                105,
                500,
                675,
                555
              ],
              "bbox_normalized": [
                0.1326,
                0.4883,
                0.8523,
                0.542
              ],
              "page": 18,
              "confidence": 0.938,
              "width": 570,
              "height": 55,
              "area": 31350,
              "reading_order": 8
            },
            {
              "id": "page18_detection9",
              "type": "text",
              "content": "#include <stdio.h>",
              "bbox": [
                105,
                600,
                207,
                616
              ],
              "bbox_normalized": [
                0.1326,
                0.5859,
                0.2614,
                0.6016
              ],
              "page": 18,
              "confidence": 0.661,
              "width": 102,
              "height": 16,
              "area": 1632,
              "reading_order": 9
            },
            {
              "id": "page18_detection4",
              "type": "text",
              "content": "nt main() { into, mij; printf(\" Enter number of processes: \"); scanf{\"%d\", &n); printf(\" Enter number of resources: ); seanf{\"%d\", &em); int max{n]fm), allotfn)[m), need[o])[m], avail[m]; printf(\"Enter maximum resources for each process in\") for (i=0:i <n; #4) { printf \"Process %d: \"i + 1); for (j= 0: < mij) | scanfi \"Vd\", &max[i][j]): ’ ’ printf(\"Enter allocated resources for each process-n\"); for (1-0: <n; #4) { printf \"Process %d: *, i + 1);",
              "bbox": [
                107,
                636,
                421,
                1005
              ],
              "bbox_normalized": [
                0.1351,
                0.6211,
                0.5316,
                0.9814
              ],
              "page": 18,
              "confidence": 0.864,
              "width": 314,
              "height": 369,
              "area": 115866,
              "reading_order": 10
            },
            {
              "id": "page19_detection1",
              "type": "text",
              "content": "for (j= 0: <m; j++) { scanfl\"%%d\", &allot[il[il ’ } printf(\" Enter available resources: a\"); for = 0: < mj) { scanf{(\"%d\", &avail[j]); } for (i= 0: < m i++) { for (j= 0: =m; j++) { need(ilfj) = max(il(] - allo); ’ } int finish{n], safeSeq[n], index = 0; for (i=0:i< m i++) { finish[i] = 0; } while (index <n) { int found = 0; for (i= 0: <m; +4) { if (finish[i] == 0) { intj; for (= 0: <m: j++) { if (meed(iJfj] > avail[]) { break: ’ ’ iff =m){ for (= 0;j<m; j++) { avail] += alloti[j: b safeSeqfindex++] =i; fnish[i] = 1; found = 1; ’ ’ ’ if (found == 0) { printf(\"System is not in 2 safe state in”); rem 0; ’ } printf{\"System is in a safe state \\nSafe sequence is: \"); for (i=0;i< mn i++) {",
              "bbox": [
                117,
                93,
                417,
                996
              ],
              "bbox_normalized": [
                0.1477,
                0.0908,
                0.5265,
                0.9727
              ],
              "page": 19,
              "confidence": 0.935,
              "width": 300,
              "height": 903,
              "area": 270900,
              "reading_order": 1
            },
            {
              "id": "page20_detection2",
              "type": "text",
              "content": "prantfi™d \", safeSeq[i] + 1); ’ printf(\"n\"); retum 0; }",
              "bbox": [
                104,
                96,
                292,
                203
              ],
              "bbox_normalized": [
                0.1313,
                0.0938,
                0.3687,
                0.1982
              ],
              "page": 20,
              "confidence": 0.926,
              "width": 188,
              "height": 107,
              "area": 20116,
              "reading_order": 1
            }
          ]
        },
        {
          "id": "page20_detection3",
          "title": "Output:",
          "level": "H2",
          "page": 20,
          "bbox": [
            105,
            222,
            159,
            238
          ],
          "bbox_normalized": [
            0.1326,
            0.2168,
            0.2008,
            0.2324
          ],
          "confidence": 0.577,
          "children": [
            {
              "id": "page20_detection1",
              "type": "text",
              "content": "PS D:\\Hemang\\h) AIMS\\voice-segregation\\Smart Farm\\smart-farm> cd ~d:\\Hemang\\hj AIMSAv SS } Enter number of processes: 5 Enter number of resources: 3 Enter maximm resources for each process: Process 1: 4.3 2 Process 2: 12 2 Process 3: 5 0 2 Process 4: 22 2 Process 5: 2 3 3 enter allocated resources for each process: Process 1: © 10 Process 2: 20 Process 3: 30 2 Process 4: 211 Process 5: 00 2 Enter available resources: 342 system is in a safe state. safe sequence is: 23451 PS D:\\Hemang\\hj AIMS\\voice-segregation\\smart Farm\\smart-farm> [|",
              "bbox": [
                106,
                241,
                679,
                583
              ],
              "bbox_normalized": [
                0.1338,
                0.2354,
                0.8573,
                0.5693
              ],
              "page": 20,
              "confidence": 0.929,
              "width": 573,
              "height": 342,
              "area": 195966,
              "reading_order": 3
            }
          ]
        },
        {
          "id": "page21_detection7",
          "title": "Experiment - 6",
          "level": "H2",
          "page": 21,
          "bbox": [
            309,
            95,
            421,
            114
          ],
          "bbox_normalized": [
            0.4262,
            0.0928,
            0.5807,
            0.1113
          ],
          "confidence": 0.761,
          "children": [
            {
              "id": "page21_detection8",
              "type": "text",
              "content": "Aim: Write a C program to simulate Banker's algorithm for the purpose of Deadlock prevention",
              "bbox": [
                82,
                156,
                642,
                171
              ],
              "bbox_normalized": [
                0.1131,
                0.1523,
                0.8855,
                0.167
              ],
              "page": 21,
              "confidence": 0.758,
              "width": 560,
              "height": 15,
              "area": 8400,
              "reading_order": 2
            }
          ]
        },
        {
          "id": "page21_detection6",
          "title": "Description:",
          "level": "H2",
          "page": 21,
          "bbox": [
            81,
            199,
            166,
            217
          ],
          "bbox_normalized": [
            0.1117,
            0.1943,
            0.229,
            0.2119
          ],
          "confidence": 0.843,
          "children": [
            {
              "id": "page21_detection1",
              "type": "text",
              "content": "The Banker's al gorithm operates by managing resource allocation based on the maximum needs of processes and the currently available resources. When a process requests resources, the algorithm checks whether granting the request would keep the system in a safe state. This is done by simulating the allocation and detemining if all processes can finish with the available resources. If the request can be safely granted, the resources are allocated; otherwise, the process must wait. This method prevents deadlock by ensuring that the system always has a valid sequence of resource allocations that allows all processes to complete.",
              "bbox": [
                81,
                219,
                642,
                365
              ],
              "bbox_normalized": [
                0.1117,
                0.2139,
                0.8855,
                0.3564
              ],
              "page": 21,
              "confidence": 0.979,
              "width": 561,
              "height": 146,
              "area": 81906,
              "reading_order": 4
            }
          ]
        },
        {
          "id": "page21_detection5",
          "title": "Theory:",
          "level": "H2",
          "page": 21,
          "bbox": [
            81,
            392,
            139,
            409
          ],
          "bbox_normalized": [
            0.1117,
            0.3828,
            0.1917,
            0.3994
          ],
          "confidence": 0.863,
          "children": [
            {
              "id": "page21_detection3",
              "type": "text",
              "content": "1 Deadlock: A situation where two or more processes cannot proceed because each 1s waiting for the other to release resources.",
              "bbox": [
                82,
                411,
                642,
                448
              ],
              "bbox_normalized": [
                0.1131,
                0.4014,
                0.8855,
                0.4375
              ],
              "page": 21,
              "confidence": 0.926,
              "width": 560,
              "height": 37,
              "area": 20720,
              "reading_order": 6
            },
            {
              "id": "page21_detection4",
              "type": "text",
              "content": "II\" Safe State: A condition where resource allocation to processes is such that the system can guarantee that all processes will complete without entering a deadlock.",
              "bbox": [
                80,
                454,
                641,
                492
              ],
              "bbox_normalized": [
                0.1103,
                0.4434,
                0.8841,
                0.4805
              ],
              "page": 21,
              "confidence": 0.897,
              "width": 561,
              "height": 38,
              "area": 21318,
              "reading_order": 7
            },
            {
              "id": "page21_detection2",
              "type": "text",
              "content": "0 Resource Allocation: The act of distributing available resources to processes. The Banker's algorithm prevents deadlock by ensuring that resources are allocated in a way that maintains a safe state.",
              "bbox": [
                80,
                497,
                642,
                557
              ],
              "bbox_normalized": [
                0.1103,
                0.4854,
                0.8855,
                0.5439
              ],
              "page": 21,
              "confidence": 0.931,
              "width": 562,
              "height": 60,
              "area": 33720,
              "reading_order": 8
            }
          ]
        },
        {
          "id": "page21_detection11",
          "title": "Code:",
          "level": "H2",
          "page": 21,
          "bbox": [
            86,
            582,
            128,
            603
          ],
          "bbox_normalized": [
            0.1186,
            0.5684,
            0.1766,
            0.5889
          ],
          "confidence": 0.671,
          "children": [
            {
              "id": "page21_detection10",
              "type": "text",
              "content": "#include <stdio.h>",
              "bbox": [
                82,
                603,
                176,
                620
              ],
              "bbox_normalized": [
                0.1131,
                0.5889,
                0.2428,
                0.6055
              ],
              "page": 21,
              "confidence": 0.695,
              "width": 94,
              "height": 17,
              "area": 1598,
              "reading_order": 10
            },
            {
              "id": "page21_detection9",
              "type": "text",
              "content": "ot main) { intn, mij: printf(\"Enter number of processes: ); scanf(\" Yd\", &n): printf(\"Enter number of resources: \"): scanf(\" id\", &m); int max(n]{m], alloin]fm), need[n][m], avail[m}: printf(\"Enter maximum resources for each process-in\"): for(i=0:i<n; i+) { printf \"Process %d: i + 1) for (=0:j< m+) | scanf(\"%d\", &emax(i][]). ) ) printf(\"Enter allocated resources for each process:in'): for(i=0:i< ni) { printf \"Process %d: i + 1) for (= 0; < mej) {",
              "bbox": [
                85,
                630,
                378,
                1002
              ],
              "bbox_normalized": [
                0.1172,
                0.6152,
                0.5214,
                0.9785
              ],
              "page": 21,
              "confidence": 0.698,
              "width": 293,
              "height": 372,
              "area": 108996,
              "reading_order": 11
            },
            {
              "id": "page22_detection1",
              "type": "text",
              "content": "scanfi\"%d\", &allot[i][j]); ) ) printf(\"Enter available resources:in\"); for (= 0: < mi ++) { scanf(\"%dt, &avail]): ) for(i=0ri< min) | for G=05< mij) | need] = max(il[] - alot: ) ) int finish], safeSecfn]. index = 0: for(i= 05m iv) { finish] = 0: ) while (index <n) { int found = 0; for (1=0;i< m i++) { if (finish{i] = 0) { ints for 1-0: <mi ji) | (nec) > avail] break: ) ) if(G==m) { for(1= 0: <mi jo) avail] += allo: ) safeSeqfindex+] =i: finish] = 1: found= 1; ) ) ) if (found = 0) { print\" System is not in a safe state in\"); rem; ) ) printf(\"System is in a safe state InSafe sequence is: \"); for(i=0ri< mir) | printf\". safeSeafi] + 1): ) printf(\"in\");",
              "bbox": [
                90,
                95,
                371,
                979
              ],
              "bbox_normalized": [
                0.1241,
                0.0928,
                0.5117,
                0.9561
              ],
              "page": 22,
              "confidence": 0.926,
              "width": 281,
              "height": 884,
              "area": 248404,
              "reading_order": 1
            },
            {
              "id": "page23_detection1",
              "type": "text",
              "content": "PS D:\\Hemang\\hj AIMS\\voice-segregation\\Smart Farm\\smart-farm> cd ~d:iHemanging AIFS \\0s-6 } Enter nusber of processes: 5 Enter number of resources: 3 Enter maximum resources for each process: Process 1: 25 3 Process 2: 32 2 Process 3: 4.0 2 Process 4: 22 2 Process 5: 3 3 3 Enter allocated resources for each process: Process 1: 0.10 Process 2: 20 0 Process 3: 30 2 Process 4: 211 Process 5: 0 0 4 Enter available resources: 231 System is in a safe state. safe sequence is: 34512 N",
              "bbox": [
                97,
                185,
                679,
                516
              ],
              "bbox_normalized": [
                0.1338,
                0.1807,
                0.9366,
                0.5039
              ],
              "page": 23,
              "confidence": 0.875,
              "width": 582,
              "height": 331,
              "area": 192642,
              "reading_order": 1
            }
          ]
        },
        {
          "id": "page24_detection10",
          "title": "Experiment — 7",
          "level": "H2",
          "page": 24,
          "bbox": [
            297,
            92,
            412,
            113
          ],
          "bbox_normalized": [
            0.4097,
            0.0898,
            0.5683,
            0.1104
          ],
          "confidence": 0.742,
          "children": [
            {
              "id": "page24_detection8",
              "type": "text",
              "content": "Aim: Write a C program to simulate page replacement algorithm a) FIE",
              "bbox": [
                83,
                146,
                467,
                163
              ],
              "bbox_normalized": [
                0.1145,
                0.1426,
                0.6441,
                0.1592
              ],
              "page": 24,
              "confidence": 0.84,
              "width": 384,
              "height": 17,
              "area": 6528,
              "reading_order": 2
            }
          ]
        },
        {
          "id": "page24_detection7",
          "title": "Description",
          "level": "H2",
          "page": 24,
          "bbox": [
            81,
            177,
            162,
            197
          ],
          "bbox_normalized": [
            0.1117,
            0.1729,
            0.2234,
            0.1924
          ],
          "confidence": 0.874,
          "children": [
            {
              "id": "page24_detection1",
              "type": "text",
              "content": "Page replacement algorithms are used when a program accesses more pages than can fit in memory. The algorithm needs to decide which page to replace when the memory is full. FIFO and LRU are two popular page replacement strategies:",
              "bbox": [
                81,
                209,
                645,
                257
              ],
              "bbox_normalized": [
                0.1117,
                0.2041,
                0.8897,
                0.251
              ],
              "page": 24,
              "confidence": 0.979,
              "width": 564,
              "height": 48,
              "area": 27072,
              "reading_order": 4
            },
            {
              "id": "page24_detection2",
              "type": "list_item",
              "content": "+ FIFO (First-In-First-Out): In FIFO, the oldest page in memory (the one that was loaded first) is replaced when a new page needs to be loaded,",
              "bbox": [
                103,
                273,
                651,
                305
              ],
              "bbox_normalized": [
                0.1421,
                0.2666,
                0.8979,
                0.2979
              ],
              "page": 24,
              "confidence": 0.97,
              "width": 548,
              "height": 32,
              "area": 17536,
              "reading_order": 5
            },
            {
              "id": "page24_detection3",
              "type": "list_item",
              "content": "* LRU (Least Recently Used): In LRU, the page that has not been used for the longest time is replaced when a new page needs to be loaded,",
              "bbox": [
                103,
                304,
                628,
                336
              ],
              "bbox_normalized": [
                0.1421,
                0.2969,
                0.8662,
                0.3281
              ],
              "page": 24,
              "confidence": 0.97,
              "width": 525,
              "height": 32,
              "area": 16800,
              "reading_order": 6
            }
          ]
        },
        {
          "id": "page24_detection9",
          "title": "Theor",
          "level": "H2",
          "page": 24,
          "bbox": [
            80,
            352,
            127,
            372
          ],
          "bbox_normalized": [
            0.1103,
            0.3438,
            0.1752,
            0.3633
          ],
          "confidence": 0.775,
          "children": [
            {
              "id": "page24_detection6",
              "type": "text",
              "content": "M1 FIFO (First-In-First-Out): FIFO is a simple page replacement algorithm. It keeps track of the pages in memory in the order they were loaded. When a new page needs to be loaded into memory and memory is full, it replaces the page that has been in memory the longest",
              "bbox": [
                81,
                401,
                650,
                449
              ],
              "bbox_normalized": [
                0.1117,
                0.3916,
                0.8966,
                0.4385
              ],
              "page": 24,
              "confidence": 0.919,
              "width": 569,
              "height": 48,
              "area": 27312,
              "reading_order": 8
            },
            {
              "id": "page24_detection4",
              "type": "text",
              "content": "\" LRU (Least Recently Used): LRU replaces the page that has not been used for the longest time. It keeps track of the access history of the pages and selects the least recently accessed page for replacement when needed.",
              "bbox": [
                81,
                465,
                647,
                513
              ],
              "bbox_normalized": [
                0.1117,
                0.4541,
                0.8924,
                0.501
              ],
              "page": 24,
              "confidence": 0.968,
              "width": 566,
              "height": 48,
              "area": 27168,
              "reading_order": 9
            }
          ]
        },
        {
          "id": "page24_detection11",
          "title": "Cod",
          "level": "H2",
          "page": 24,
          "bbox": [
            81,
            552,
            112,
            574
          ],
          "bbox_normalized": [
            0.1117,
            0.5391,
            0.1545,
            0.5605
          ],
          "confidence": 0.689,
          "children": []
        },
        {
          "id": "page24_detection12",
          "title": "e:",
          "level": "H2",
          "page": 24,
          "bbox": [
            81,
            575,
            93,
            592
          ],
          "bbox_normalized": [
            0.1117,
            0.5615,
            0.1283,
            0.5781
          ],
          "confidence": 0.556,
          "children": [
            {
              "id": "page24_detection5",
              "type": "text",
              "content": "incline <sidio.&> void fifoPageReplacementint pages). intr nt capaci) | int pageFauts = 0: int framelcapacin int count = 0; for inti =0: = capaci: i++) rameli] 15 for (inti = 0; <n; iH) | int flag = 0: for inj =0:) < capaci: j++) { if (@ramelj) = pages() { flag: break; i i if(flag=0) { framefcount] = pages(: count = (count + 1) Yocapacin; pageFalis +; i i printf(’FIFO Page Faults: din’. pageFauls): }",
              "bbox": [
                80,
                607,
                386,
                1001
              ],
              "bbox_normalized": [
                0.1103,
                0.5928,
                0.5324,
                0.9775
              ],
              "page": 24,
              "confidence": 0.963,
              "width": 306,
              "height": 394,
              "area": 120564,
              "reading_order": 12
            },
            {
              "id": "page25_detection1",
              "type": "text",
              "content": "void frufageleplacement{int pages|], mtn, mt capaciiy) | int pageFaults = 0: int framelcapacin int timelcapuacin: int count = 0; for (inti =0: = capaci: i++) { framefi]=-1: time[i] =I: ) for inti =0ci< i++) { int flag = 0: for in = 0: < capaci: j++) { if @ramelj) = pages() { flag 1: timef] = count bres: ) ) if (flag=0) { inti =0; for (in = 1: < capaci j++) { if imefj] = timefinu) ru =: ) framefira] = pages(ls timeliru] = count pageFauls +; ) count; ) printf(\"LRU Page Faults: %d'n\", pageFaults); } int main) { int pages] = 17.0.1, 2.0,3.0,4.2,3,0,3.25; int n= sizeof{ pages) / sizeof{pages[0]): int capacity = 3: fifoPageReplacementpages, n, capacity): IuPageReplacament (pages, n. capacity): retum 0; ,",
              "bbox": [
                80,
                116,
                386,
                800
              ],
              "bbox_normalized": [
                0.1103,
                0.1133,
                0.5324,
                0.7813
              ],
              "page": 25,
              "confidence": 0.945,
              "width": 306,
              "height": 684,
              "area": 209304,
              "reading_order": 1
            },
            {
              "id": "page25_detection2",
              "type": "text",
              "content": "\\B-7 } FIFO Page Faults: 10 LRU Page Faults: 9 PS D:\\Hemang\\hj AIMS\\voice-segregation\\smart Farm\\smart-farm",
              "bbox": [
                89,
                863,
                502,
                925
              ],
              "bbox_normalized": [
                0.1228,
                0.8428,
                0.6924,
                0.9033
              ],
              "page": 25,
              "confidence": 0.893,
              "width": 413,
              "height": 62,
              "area": 25606,
              "reading_order": 2
            }
          ]
        },
        {
          "id": "page26_detection10",
          "title": "Experiment — 8",
          "level": "H2",
          "page": 26,
          "bbox": [
            297,
            92,
            412,
            113
          ],
          "bbox_normalized": [
            0.4097,
            0.0898,
            0.5683,
            0.1104
          ],
          "confidence": 0.736,
          "children": [
            {
              "id": "page26_detection9",
              "type": "text",
              "content": "m: Write a C program to simulate page replacement algorithm a) LFU,",
              "bbox": [
                96,
                147,
                480,
                163
              ],
              "bbox_normalized": [
                0.1324,
                0.1436,
                0.6621,
                0.1592
              ],
              "page": 26,
              "confidence": 0.748,
              "width": 384,
              "height": 16,
              "area": 6144,
              "reading_order": 2
            }
          ]
        },
        {
          "id": "page26_detection7",
          "title": "Description:",
          "level": "H2",
          "page": 26,
          "bbox": [
            81,
            177,
            167,
            197
          ],
          "bbox_normalized": [
            0.1117,
            0.1729,
            0.2303,
            0.1924
          ],
          "confidence": 0.809,
          "children": [
            {
              "id": "page26_detection5",
              "type": "text",
              "content": "Page replacement algorithms are used when a program requires more memory than is available. In such cases, pages are replaced based on certain strategies:",
              "bbox": [
                80,
                208,
                643,
                244
              ],
              "bbox_normalized": [
                0.1103,
                0.2031,
                0.8869,
                0.2383
              ],
              "page": 26,
              "confidence": 0.955,
              "width": 563,
              "height": 36,
              "area": 20268,
              "reading_order": 4
            },
            {
              "id": "page26_detection2",
              "type": "list_item",
              "content": "+ LFU (Least Frequently Used): The LFU algorithm replaces the page that has been used the least number of times. This means that pages that have not been frequently accessed are replaced first.",
              "bbox": [
                103,
                258,
                650,
                310
              ],
              "bbox_normalized": [
                0.1421,
                0.252,
                0.8966,
                0.3027
              ],
              "page": 26,
              "confidence": 0.978,
              "width": 547,
              "height": 52,
              "area": 28444,
              "reading_order": 5
            },
            {
              "id": "page26_detection3",
              "type": "list_item",
              "content": "+ Optimal: The Optimal page replacement algorithm replaces the page that will not be used for the longest period of time in the future. It is theoretically the best algorithm, but it requires knowledge of future page references, which is not possible in real scenarios.",
              "bbox": [
                103,
                309,
                646,
                361
              ],
              "bbox_normalized": [
                0.1421,
                0.3018,
                0.891,
                0.3525
              ],
              "page": 26,
              "confidence": 0.974,
              "width": 543,
              "height": 52,
              "area": 28236,
              "reading_order": 6
            }
          ]
        },
        {
          "id": "page26_detection12",
          "title": "Theory:",
          "level": "H2",
          "page": 26,
          "bbox": [
            81,
            376,
            139,
            396
          ],
          "bbox_normalized": [
            0.1117,
            0.3672,
            0.1917,
            0.3867
          ],
          "confidence": 0.676,
          "children": [
            {
              "id": "page26_detection1",
              "type": "list_item",
              "content": "+ LFU (Least Frequently Used): LFU replaces the page with the least frequency of access. The algorithm keeps track of the number of times each page is accessed. When a page fault occurs and a new page must be loaded, the page with the least access count is chosen for replacement.",
              "bbox": [
                103,
                406,
                645,
                476
              ],
              "bbox_normalized": [
                0.1421,
                0.3965,
                0.8897,
                0.4648
              ],
              "page": 26,
              "confidence": 0.98,
              "width": 542,
              "height": 70,
              "area": 37940,
              "reading_order": 8
            },
            {
              "id": "page26_detection4",
              "type": "list_item",
              "content": "+ Optimal: The Optimal algorithm is based on future page reference information. It predicts which page will be needed furthest in the future and replaces it. This algorithm is ideal but impractical, as it requires future knowledge.",
              "bbox": [
                102,
                474,
                639,
                526
              ],
              "bbox_normalized": [
                0.1407,
                0.4629,
                0.8814,
                0.5137
              ],
              "page": 26,
              "confidence": 0.968,
              "width": 537,
              "height": 52,
              "area": 27924,
              "reading_order": 9
            }
          ]
        },
        {
          "id": "page26_detection11",
          "title": "Code:",
          "level": "H2",
          "page": 26,
          "bbox": [
            81,
            554,
            124,
            574
          ],
          "bbox_normalized": [
            0.1117,
            0.541,
            0.171,
            0.5605
          ],
          "confidence": 0.73,
          "children": [
            {
              "id": "page26_detection8",
              "type": "text",
              "content": "#include <stdio.h>",
              "bbox": [
                81,
                588,
                179,
                604
              ],
              "bbox_normalized": [
                0.1117,
                0.5742,
                0.2469,
                0.5898
              ],
              "page": 26,
              "confidence": 0.76,
              "width": 98,
              "height": 16,
              "area": 1568,
              "reading_order": 11
            },
            {
              "id": "page26_detection6",
              "type": "text",
              "content": "void IfuPageReplacement(int pages{], int, int capacity) | int pageFaults = 0: int frame{capaciny]. feclcapacin’: int count = 0; for (inti =0: = capaci: i++) { framefi]=-1: freqli] =O; } for (inti = 0; <n; i++) | int flag = 0: for inj =0:) < capaci: j++) { if @ramelj] = pages() { freq: flag 1: bres: i i if (flag=0) { int minFreq = fre0], minlndex = 0: for (in = 1: = capaci; j++) { if (eqlj] < minfrea) | ‘minFreq = freqj];",
              "bbox": [
                83,
                621,
                383,
                1003
              ],
              "bbox_normalized": [
                0.1145,
                0.6064,
                0.5283,
                0.9795
              ],
              "page": 26,
              "confidence": 0.946,
              "width": 300,
              "height": 382,
              "area": 114600,
              "reading_order": 12
            },
            {
              "id": "page27_detection1",
              "type": "text",
              "content": "minlodex =: i } ramefminladex] = pages: freqlminindex] = 1: pageFaults +; i i printf(\"LFU Page Fauls: Yd, ageFault); i int findOptimalPage(int pages(]. nt in framel] nt currentndes, int capaci) | int maxDistance = pageToReplace =-1: for (inti =0: = capaci: i++) | ine for = currentindexs <i) | if rameli) = pags(j) { if > maxDistance) { maxDistance =j: pageToReplace ~framelil i bres: i i ifG=m{ rerum framefil i i retum page ToReplace: i void optimalPageReplacament(int pages(. int. int capaci) | int pageFaults = 0: int framelcapacin: for (inti =0: = capaci: i++) rameli] =~ 1: for (inti = 0; <n; i+) | int flag = 0: for inj = 03) < capaci: j++) { if (@ramelj] = pages() { flag: bres: i i if(flag=0) { if (i < capacity) | frameli] = pagestl: else { int pageToReplace = findOptimalPage(pages n frame, i+ 1, capaci): for (int = 05 capacins +4) | if (framelj) — pageToReplace) { frame(j] = pages; break:",
              "bbox": [
                78,
                85,
                504,
                993
              ],
              "bbox_normalized": [
                0.1076,
                0.083,
                0.6952,
                0.9697
              ],
              "page": 27,
              "confidence": 0.895,
              "width": 426,
              "height": 908,
              "area": 386808,
              "reading_order": 1
            },
            {
              "id": "page28_detection1",
              "type": "text",
              "content": "’ ) ) pageFaulisi-+, ) ) printf(\"Optimal Page Faults: %dn\", pageFaults) ) int main() { int pages(] = {7,0,1,2,0,3,0.4,2,3,0.3,2); int n = sizeof pages) sizeof{pages[0] int capacity = 3; IfuPageReplacement (pages, n. capacity). optimalPageR placement (pages, n, capacity): retum 0; i",
              "bbox": [
                79,
                99,
                345,
                387
              ],
              "bbox_normalized": [
                0.109,
                0.0967,
                0.4759,
                0.3779
              ],
              "page": 28,
              "confidence": 0.87,
              "width": 266,
              "height": 288,
              "area": 76608,
              "reading_order": 1
            },
            {
              "id": "page28_detection2",
              "type": "text",
              "content": "N58} FU page Faults: 9 optimal Page Faults: 7 PS D:\\Hemang\\hj AIMS\\voice-segregation\\smart Farm\\smart-farm>",
              "bbox": [
                91,
                463,
                484,
                522
              ],
              "bbox_normalized": [
                0.1255,
                0.4521,
                0.6676,
                0.5098
              ],
              "page": 28,
              "confidence": 0.704,
              "width": 393,
              "height": 59,
              "area": 23187,
              "reading_order": 2
            }
          ]
        },
        {
          "id": "page29_detection14",
          "title": "Experiment — 9",
          "level": "H2",
          "page": 29,
          "bbox": [
            297,
            92,
            413,
            113
          ],
          "bbox_normalized": [
            0.4097,
            0.0898,
            0.5697,
            0.1104
          ],
          "confidence": 0.713,
          "children": [
            {
              "id": "page29_detection13",
              "type": "text",
              "content": "m: Write a C program to simulate producer-consumer problem using s¢",
              "bbox": [
                96,
                147,
                480,
                163
              ],
              "bbox_normalized": [
                0.1324,
                0.1436,
                0.6621,
                0.1592
              ],
              "page": 29,
              "confidence": 0.744,
              "width": 384,
              "height": 16,
              "area": 6144,
              "reading_order": 2
            },
            {
              "id": "page29_detection18",
              "type": "text",
              "content": "Description:",
              "bbox": [
                81,
                189,
                167,
                209
              ],
              "bbox_normalized": [
                0.1117,
                0.1846,
                0.2303,
                0.2041
              ],
              "page": 29,
              "confidence": 0.591,
              "width": 86,
              "height": 20,
              "area": 1720,
              "reading_order": 3
            },
            {
              "id": "page29_detection7",
              "type": "text",
              "content": "The Producer-Consumer problem involves two main processes:",
              "bbox": [
                81,
                237,
                471,
                255
              ],
              "bbox_normalized": [
                0.1117,
                0.2314,
                0.6497,
                0.249
              ],
              "page": 29,
              "confidence": 0.929,
              "width": 390,
              "height": 18,
              "area": 7020,
              "reading_order": 4
            },
            {
              "id": "page29_detection8",
              "type": "list_item",
              "content": "« The Consumer: This process consumes items from the buffer.",
              "bbox": [
                103,
                288,
                494,
                306
              ],
              "bbox_normalized": [
                0.1421,
                0.2813,
                0.6814,
                0.2988
              ],
              "page": 29,
              "confidence": 0.921,
              "width": 391,
              "height": 18,
              "area": 7038,
              "reading_order": 5
            },
            {
              "id": "page29_detection6",
              "type": "list_item",
              "content": "The Producer: This process generates items and stores them in a shared buffer.",
              "bbox": [
                102,
                270,
                594,
                289
              ],
              "bbox_normalized": [
                0.1407,
                0.2637,
                0.8193,
                0.2822
              ],
              "page": 29,
              "confidence": 0.931,
              "width": 492,
              "height": 19,
              "area": 9348,
              "reading_order": 6
            },
            {
              "id": "page29_detection15",
              "type": "text",
              "content": "The semaphore is a synchronization mechanism used to manage access to the shared buffer:",
              "bbox": [
                80,
                322,
                627,
                340
              ],
              "bbox_normalized": [
                0.1103,
                0.3145,
                0.8648,
                0.332
              ],
              "page": 29,
              "confidence": 0.702,
              "width": 547,
              "height": 18,
              "area": 9846,
              "reading_order": 7
            },
            {
              "id": "page29_detection2",
              "type": "list_item",
              "content": "+ A mutex semaphore (binary semaphore) is used to ensure mutual exclusion while accessing the buffer.",
              "bbox": [
                102,
                354,
                613,
                390
              ],
              "bbox_normalized": [
                0.1407,
                0.3457,
                0.8455,
                0.3809
              ],
              "page": 29,
              "confidence": 0.962,
              "width": 511,
              "height": 36,
              "area": 18396,
              "reading_order": 8
            },
            {
              "id": "page29_detection1",
              "type": "list_item",
              "content": "+ A full semaphore is used to track how many items are in the buffer, ensuring the consumer waits if the buffer is empty.",
              "bbox": [
                103,
                389,
                604,
                424
              ],
              "bbox_normalized": [
                0.1421,
                0.3799,
                0.8331,
                0.4141
              ],
              "page": 29,
              "confidence": 0.965,
              "width": 501,
              "height": 35,
              "area": 17535,
              "reading_order": 9
            },
            {
              "id": "page29_detection4",
              "type": "list_item",
              "content": "+ An empty semaphore tracks how many empty spaces are available in the buffer, ensuring the producer waits if the buffer is full",
              "bbox": [
                102,
                422,
                603,
                458
              ],
              "bbox_normalized": [
                0.1407,
                0.4121,
                0.8317,
                0.4473
              ],
              "page": 29,
              "confidence": 0.961,
              "width": 501,
              "height": 36,
              "area": 18036,
              "reading_order": 10
            },
            {
              "id": "page29_detection3",
              "type": "text",
              "content": "The problem can be solved by using semaphores to avoid race conditions and ensure proper synchronization between the producer and consumer.",
              "bbox": [
                80,
                473,
                622,
                508
              ],
              "bbox_normalized": [
                0.1103,
                0.4619,
                0.8579,
                0.4961
              ],
              "page": 29,
              "confidence": 0.961,
              "width": 542,
              "height": 35,
              "area": 18970,
              "reading_order": 11
            },
            {
              "id": "page29_detection5",
              "type": "text",
              "content": "Producer-Consumer Problem: The producer-consumer problem involves two types of processes: the producer, which generates data (e.g., adding items to a buffer), and the consumer, which consumes data from this buffer. The buffer has limited capacity, so producers must wait if it's full, and consumers must wait if it's empty.",
              "bbox": [
                80,
                587,
                653,
                654
              ],
              "bbox_normalized": [
                0.1103,
                0.5732,
                0.9007,
                0.6387
              ],
              "page": 29,
              "confidence": 0.944,
              "width": 573,
              "height": 67,
              "area": 38391,
              "reading_order": 12
            },
            {
              "id": "page29_detection17",
              "type": "text",
              "content": "Semaphores: Semaphores are used to handle process synchroniza",
              "bbox": [
                83,
                654,
                467,
                671
              ],
              "bbox_normalized": [
                0.1145,
                0.6387,
                0.6441,
                0.6553
              ],
              "page": 29,
              "confidence": 0.626,
              "width": 384,
              "height": 17,
              "area": 6528,
              "reading_order": 13
            },
            {
              "id": "page29_detection16",
              "type": "text",
              "content": "2.A semaphore full tracks the filled slots.",
              "bbox": [
                80,
                687,
                302,
                702
              ],
              "bbox_normalized": [
                0.1103,
                0.6709,
                0.4166,
                0.6855
              ],
              "page": 29,
              "confidence": 0.639,
              "width": 222,
              "height": 15,
              "area": 3330,
              "reading_order": 14
            },
            {
              "id": "page29_detection9",
              "type": "text",
              "content": "3.A mutex semaphore ensures mutual exclusion, allowing only one process to modify the buffer at a time.",
              "bbox": [
                80,
                701,
                623,
                733
              ],
              "bbox_normalized": [
                0.1103,
                0.6846,
                0.8593,
                0.7158
              ],
              "page": 29,
              "confidence": 0.91,
              "width": 543,
              "height": 32,
              "area": 17376,
              "reading_order": 15
            }
          ]
        },
        {
          "id": "page29_detection11",
          "title": "Code:",
          "level": "H2",
          "page": 29,
          "bbox": [
            81,
            751,
            125,
            768
          ],
          "bbox_normalized": [
            0.1117,
            0.7334,
            0.1724,
            0.75
          ],
          "confidence": 0.804,
          "children": [
            {
              "id": "page29_detection10",
              "type": "text",
              "content": "#include <stdio.h> include <sidlibh> ¥include <unistd.h>",
              "bbox": [
                81,
                787,
                183,
                837
              ],
              "bbox_normalized": [
                0.1117,
                0.7686,
                0.2524,
                0.8174
              ],
              "page": 29,
              "confidence": 0.812,
              "width": 102,
              "height": 50,
              "area": 5100,
              "reading_order": 17
            },
            {
              "id": "page29_detection12",
              "type": "text",
              "content": "#define BUFFER SIZE 5 int buffer{BUFFER_SIZE]; int in= 0, out =0; int count = 0;",
              "bbox": [
                81,
                856,
                224,
                923
              ],
              "bbox_normalized": [
                0.1117,
                0.8359,
                0.309,
                0.9014
              ],
              "page": 29,
              "confidence": 0.762,
              "width": 143,
              "height": 67,
              "area": 9581,
              "reading_order": 18
            },
            {
              "id": "page30_detection1",
              "type": "text",
              "content": "Tetum; } bufferfin] = rem; in= (in 1) % BUFFER_SIZE; count; printf(\"Produced: Yd’, item): ] int consume() { if (count — 0) { printf{\"Buffr is empty. Waiting to consume.'n\"); retum 1; ) int tem = bufferfout]; out = (out + 1) % BUFFER_SIZE; count, printf(\" Consumed: %dn\", item): retum item; ] int main() { int items_to_produce = 10; int produce interval = I // seconds between produce actions int consume_interval =2; // seconds between consume actions for (inti = 0; i < tems_to_produce; i++) { produce + 1); sleep(produce_interval); if count 0) { consume); sleep(consume interval); ) )",
              "bbox": [
                80,
                99,
                416,
                708
              ],
              "bbox_normalized": [
                0.1103,
                0.0967,
                0.5738,
                0.6914
              ],
              "page": 30,
              "confidence": 0.738,
              "width": 336,
              "height": 609,
              "area": 204624,
              "reading_order": 1
            }
          ]
        },
        {
          "id": "page32_detection4",
          "title": "Experiment-10",
          "level": "H2",
          "page": 32,
          "bbox": [
            300,
            92,
            410,
            113
          ],
          "bbox_normalized": [
            0.4138,
            0.0898,
            0.5655,
            0.1104
          ],
          "confidence": 0.764,
          "children": [
            {
              "id": "page32_detection8",
              "type": "text",
              "content": "Aim: Write a C program to simulate disk scheduling algorithms a) FCFS, b) SCAN",
              "bbox": [
                81,
                125,
                574,
                145
              ],
              "bbox_normalized": [
                0.1117,
                0.1221,
                0.7917,
                0.1416
              ],
              "page": 32,
              "confidence": 0.547,
              "width": 493,
              "height": 20,
              "area": 9860,
              "reading_order": 2
            }
          ]
        },
        {
          "id": "page32_detection6",
          "title": "Description:",
          "level": "H2",
          "page": 32,
          "bbox": [
            81,
            158,
            160,
            175
          ],
          "bbox_normalized": [
            0.1117,
            0.1543,
            0.2207,
            0.1709
          ],
          "confidence": 0.699,
          "children": [
            {
              "id": "page32_detection1",
              "type": "text",
              "content": "This experiment implements two disk scheduling algorithms. FCFS services requests in the order they arrive, while SCAN moves the disk arm back and forth across the request queue, servicing requests as it reaches them in each direct",
              "bbox": [
                80,
                189,
                620,
                241
              ],
              "bbox_normalized": [
                0.1103,
                0.1846,
                0.8552,
                0.2354
              ],
              "page": 32,
              "confidence": 0.964,
              "width": 540,
              "height": 52,
              "area": 28080,
              "reading_order": 4
            },
            {
              "id": "page32_detection7",
              "type": "text",
              "content": "Theory:",
              "bbox": [
                81,
                254,
                134,
                272
              ],
              "bbox_normalized": [
                0.1117,
                0.248,
                0.1848,
                0.2656
              ],
              "page": 32,
              "confidence": 0.636,
              "width": 53,
              "height": 18,
              "area": 954,
              "reading_order": 5
            },
            {
              "id": "page32_detection2",
              "type": "text",
              "content": "FCFS (First-Come, First-Served): The simplest disk scheduling algorithm, where requests are serviced in the order they amive. While easy to implement, it does not optimize seek time, and requests on opposite sides of the disk can increase the time required.",
              "bbox": [
                80,
                285,
                635,
                337
              ],
              "bbox_normalized": [
                0.1103,
                0.2783,
                0.8759,
                0.3291
              ],
              "page": 32,
              "confidence": 0.866,
              "width": 555,
              "height": 52,
              "area": 28860,
              "reading_order": 6
            },
            {
              "id": "page32_detection3",
              "type": "text",
              "content": "SCAN: Also known as the \"elevator algorithm,” SCAN moves the disk arm in one direction, servicing all requests, then reverses direction once the end is reached. This approach reduces the overall seek time by eliminating excessive arm movement and ensures that no requests are left waiting indefinitely.",
              "bbox": [
                80,
                335,
                645,
                404
              ],
              "bbox_normalized": [
                0.1103,
                0.3271,
                0.8897,
                0.3945
              ],
              "page": 32,
              "confidence": 0.821,
              "width": 565,
              "height": 69,
              "area": 38985,
              "reading_order": 7
            }
          ]
        },
        {
          "id": "page32_detection9",
          "title": "Code:",
          "level": "H2",
          "page": 32,
          "bbox": [
            81,
            418,
            122,
            436
          ],
          "bbox_normalized": [
            0.1117,
            0.4082,
            0.1683,
            0.4258
          ],
          "confidence": 0.522,
          "children": [
            {
              "id": "page32_detection5",
              "type": "text",
              "content": "#include <stdlib.h> void fefint requests], int, int ead) { int seck time 0; printf(\"nFCFS Disk Scheduling!in'): for (inti = 0; i< ni; 44) { printf{\"Moving from %d to %d\\n\", head, requests]: seek _time += abs(requesisli] - head); head = requess[i); ) printf(\"Total Seek Time (FCFS): %din\", sek_time): ] void scanlint requests() int n, int head. int direction, int disk size) { int seck time 0; printf(\"nSCAN Disk Scheduling\"); for (inti = 0; i< n- 1:4) { for (nj =i +13 < mj) | if (requests[i] > requests) { inttemp = requests requesis(i) = requests); requesis[j] = temp; ) ) ) int, current_position ~ head: if direction —1) { for i= 0; i< n && requess(i] < head: i++);",
              "bbox": [
                80,
                459,
                433,
                1011
              ],
              "bbox_normalized": [
                0.1103,
                0.4482,
                0.5972,
                0.9873
              ],
              "page": 32,
              "confidence": 0.736,
              "width": 353,
              "height": 552,
              "area": 194856,
              "reading_order": 9
            },
            {
              "id": "page33_detection1",
              "type": "text",
              "content": "while i <n) { printf\" Moving from %d to %din\", current_position, requests]. seck time += abs(reguesisi] - current position); current_position = requesisfi+ +1; } if (current_position < disk size - 1) { printf\" Moving from %d to %d\\n\", current_position, disk_size - seek time += abs(disk_size - | - curtent_position): current_position =disk_size - 1; ) for i i= 0; i) { printf\" Moving from %d to %d\\n\", current_position, requests]; seek time += abs(reguesisi] - current position); current_position = requests; } else | for(i =n - 1; i>=0 && requesis(i] > head: i=); while (>=0) { printf\" Moving from %d 0 %din\", current_position, requests]. seck time += abs(reguesisi] - current position); current_position = requestsfi-]: } if (curtent_position > 0) printf\" Moving from %d to %d\\n\", current_position, 0); seek time += current_position: current_position = 0: } for (i++ i <miith) { printf\" Moving from %d to %din\", current_position, requests]. seek time += abs(reguesisi] - current position); current_position = requests; ) ) printf(\"Total Seek Time (SCAN): %dn’, seck time); ] int main() { itn, head, direction, disk size; printf(\"Enter the number of requests: ): scanf(\" Yd\", &n): int requestsfnl; printf(\"Enter the requests\"); for (inti = 0: i< n: #4) { seanf(\"%od\", &requestsfl); ) printf(\"Enter initial head position: \"): scanf(\"%d\", &head); printf(\"Enter disk size: \"); scanfl\" id\", &disk_size);",
              "bbox": [
                80,
                94,
                458,
                997
              ],
              "bbox_normalized": [
                0.1103,
                0.0918,
                0.6317,
                0.9736
              ],
              "page": 33,
              "confidence": 0.955,
              "width": 378,
              "height": 903,
              "area": 341334,
              "reading_order": 1
            },
            {
              "id": "page34_detection2",
              "type": "text",
              "content": "printf(\"Enter direction (1 for high, 0 for low): *); scanf(\"%d\", &direction);",
              "bbox": [
                94,
                96,
                346,
                128
              ],
              "bbox_normalized": [
                0.1297,
                0.0938,
                0.4772,
                0.125
              ],
              "page": 34,
              "confidence": 0.524,
              "width": 252,
              "height": 32,
              "area": 8064,
              "reading_order": 1
            }
          ]
        },
        {
          "id": "page34_detection1",
          "title": "Output:",
          "level": "H2",
          "page": 34,
          "bbox": [
            81,
            296,
            133,
            312
          ],
          "bbox_normalized": [
            0.1117,
            0.2891,
            0.1834,
            0.3047
          ],
          "confidence": 0.732,
          "children": []
        }
      ]
    }
  ],
  "allDetections": [
    {
      "id": "page1_detection5",
      "bbox": [
        186,
        139,
        564,
        168
      ],
      "bbox_normalized": [
        0.2569,
        0.1357,
        0.779,
        0.1641
      ],
      "label": "Text",
      "confidence": 0.568,
      "area": 10962,
      "center": [
        375,
        154
      ],
      "width": 378,
      "height": 29,
      "extractedText": "(Formerly Delhi College of Engineering)",
      "reading_order": 1,
      "pageNumber": 1,
      "sourceImagePath": "temp_images\\page-01.png",
      "annotatedImagePath": "output\\annotated_frames\\page_1_annotated.png",
      "pageWidth": 724,
      "pageHeight": 1024
    },
    {
      "id": "page1_detection1",
      "bbox": [
        255,
        187,
        469,
        402
      ],
      "bbox_normalized": [
        0.3522,
        0.1826,
        0.6478,
        0.3926
      ],
      "label": "Picture",
      "confidence": 0.906,
      "area": 46010,
      "center": [
        362,
        295
      ],
      "width": 214,
      "height": 215,
      "extractedText": "[Picture - image content]",
      "reading_order": 2,
      "pageNumber": 1,
      "sourceImagePath": "temp_images\\page-01.png",
      "annotatedImagePath": "output\\annotated_frames\\page_1_annotated.png",
      "pageWidth": 724,
      "pageHeight": 1024
    },
    {
      "id": "page1_detection3",
      "bbox": [
        91,
        448,
        662,
        522
      ],
      "bbox_normalized": [
        0.1257,
        0.4375,
        0.9144,
        0.5098
      ],
      "label": "Title",
      "confidence": 0.697,
      "area": 42254,
      "center": [
        377,
        485
      ],
      "width": 571,
      "height": 74,
      "extractedText": "DEPARTMENT OF COMPUTER SCIENCE AND ENGINEERING",
      "reading_order": 3,
      "pageNumber": 1,
      "sourceImagePath": "temp_images\\page-01.png",
      "annotatedImagePath": "output\\annotated_frames\\page_1_annotated.png",
      "pageWidth": 724,
      "pageHeight": 1024
    },
    {
      "id": "page1_detection4",
      "bbox": [
        63,
        813,
        293,
        890
      ],
      "bbox_normalized": [
        0.087,
        0.7939,
        0.4047,
        0.8691
      ],
      "label": "Text",
      "confidence": 0.61,
      "area": 17710,
      "center": [
        178,
        852
      ],
      "width": 230,
      "height": 77,
      "extractedText": "Dr. Pawan Singh Mehra Assistant Professor CSE Department",
      "reading_order": 4,
      "pageNumber": 1,
      "sourceImagePath": "temp_images\\page-01.png",
      "annotatedImagePath": "output\\annotated_frames\\page_1_annotated.png",
      "pageWidth": 724,
      "pageHeight": 1024
    },
    {
      "id": "page1_detection2",
      "bbox": [
        438,
        778,
        652,
        902
      ],
      "bbox_normalized": [
        0.605,
        0.7598,
        0.9006,
        0.8809
      ],
      "label": "Text",
      "confidence": 0.806,
      "area": 26536,
      "center": [
        545,
        840
      ],
      "width": 214,
      "height": 124,
      "extractedText": "SUBMITTED BY- Hemang Jain Roll No.: 23/CS/174 Batch: CO-A3",
      "reading_order": 5,
      "pageNumber": 1,
      "sourceImagePath": "temp_images\\page-01.png",
      "annotatedImagePath": "output\\annotated_frames\\page_1_annotated.png",
      "pageWidth": 724,
      "pageHeight": 1024
    },
    {
      "id": "page2_detection9",
      "bbox": [
        289,
        100,
        469,
        116
      ],
      "bbox_normalized": [
        0.3986,
        0.0977,
        0.6469,
        0.1133
      ],
      "label": "Section-header",
      "confidence": 0.784,
      "area": 2880,
      "center": [
        379,
        108
      ],
      "width": 180,
      "height": 16,
      "extractedText": "VISION AND MISSION",
      "reading_order": 1,
      "pageNumber": 2,
      "sourceImagePath": "temp_images\\page-02.png",
      "annotatedImagePath": "output\\annotated_frames\\page_2_annotated.png",
      "pageWidth": 725,
      "pageHeight": 1024
    },
    {
      "id": "page2_detection3",
      "bbox": [
        107,
        164,
        147,
        178
      ],
      "bbox_normalized": [
        0.1476,
        0.1602,
        0.2028,
        0.1738
      ],
      "label": "Section-header",
      "confidence": 0.879,
      "area": 560,
      "center": [
        127,
        171
      ],
      "width": 40,
      "height": 14,
      "extractedText": "Yision",
      "reading_order": 2,
      "pageNumber": 2,
      "sourceImagePath": "temp_images\\page-02.png",
      "annotatedImagePath": "output\\annotated_frames\\page_2_annotated.png",
      "pageWidth": 725,
      "pageHeight": 1024
    },
    {
      "id": "page2_detection1",
      "bbox": [
        106,
        193,
        627,
        259
      ],
      "bbox_normalized": [
        0.1462,
        0.1885,
        0.8648,
        0.2529
      ],
      "label": "Text",
      "confidence": 0.953,
      "area": 34386,
      "center": [
        367,
        226
      ],
      "width": 521,
      "height": 66,
      "extractedText": "Department of Computer Science & Engineering to be a leading world class technology department playing ts role as a key node in national and global knowledge network, thus empowering the computer science industry with the wings of knowledge and power of innovation.",
      "reading_order": 3,
      "pageNumber": 2,
      "sourceImagePath": "temp_images\\page-02.png",
      "annotatedImagePath": "output\\annotated_frames\\page_2_annotated.png",
      "pageWidth": 725,
      "pageHeight": 1024
    },
    {
      "id": "page2_detection6",
      "bbox": [
        107,
        311,
        156,
        325
      ],
      "bbox_normalized": [
        0.1476,
        0.3037,
        0.2152,
        0.3174
      ],
      "label": "Section-header",
      "confidence": 0.832,
      "area": 686,
      "center": [
        132,
        318
      ],
      "width": 49,
      "height": 14,
      "extractedText": "zssion",
      "reading_order": 4,
      "pageNumber": 2,
      "sourceImagePath": "temp_images\\page-02.png",
      "annotatedImagePath": "output\\annotated_frames\\page_2_annotated.png",
      "pageWidth": 725,
      "pageHeight": 1024
    },
    {
      "id": "page2_detection7",
      "bbox": [
        107,
        340,
        367,
        353
      ],
      "bbox_normalized": [
        0.1476,
        0.332,
        0.5062,
        0.3447
      ],
      "label": "Text",
      "confidence": 0.83,
      "area": 3380,
      "center": [
        237,
        347
      ],
      "width": 260,
      "height": 13,
      "extractedText": "1he Mission of the department 1s as follows:",
      "reading_order": 5,
      "pageNumber": 2,
      "sourceImagePath": "temp_images\\page-02.png",
      "annotatedImagePath": "output\\annotated_frames\\page_2_annotated.png",
      "pageWidth": 725,
      "pageHeight": 1024
    },
    {
      "id": "page2_detection8",
      "bbox": [
        76,
        370,
        603,
        413
      ],
      "bbox_normalized": [
        0.1048,
        0.3613,
        0.8317,
        0.4033
      ],
      "label": "List-item",
      "confidence": 0.794,
      "area": 22661,
      "center": [
        340,
        392
      ],
      "width": 527,
      "height": 43,
      "extractedText": "1. To nurture talent of students for research, mnovation and excellence in the field of computer engineering starting from Under graduate level.",
      "reading_order": 6,
      "pageNumber": 2,
      "sourceImagePath": "temp_images\\page-02.png",
      "annotatedImagePath": "output\\annotated_frames\\page_2_annotated.png",
      "pageWidth": 725,
      "pageHeight": 1024
    },
    {
      "id": "page2_detection4",
      "bbox": [
        76,
        430,
        617,
        475
      ],
      "bbox_normalized": [
        0.1048,
        0.4199,
        0.851,
        0.4639
      ],
      "label": "List-item",
      "confidence": 0.866,
      "area": 24345,
      "center": [
        347,
        453
      ],
      "width": 541,
      "height": 45,
      "extractedText": "2. To develop highly analytical and qualified computer engineers by imparting training on cutting edge technology.",
      "reading_order": 7,
      "pageNumber": 2,
      "sourceImagePath": "temp_images\\page-02.png",
      "annotatedImagePath": "output\\annotated_frames\\page_2_annotated.png",
      "pageWidth": 725,
      "pageHeight": 1024
    },
    {
      "id": "page2_detection5",
      "bbox": [
        76,
        493,
        503,
        506
      ],
      "bbox_normalized": [
        0.1048,
        0.4814,
        0.6938,
        0.4941
      ],
      "label": "List-item",
      "confidence": 0.854,
      "area": 5551,
      "center": [
        290,
        500
      ],
      "width": 427,
      "height": 13,
      "extractedText": "3. To produce socially sensitive computer engineers with professional ethics.",
      "reading_order": 8,
      "pageNumber": 2,
      "sourceImagePath": "temp_images\\page-02.png",
      "annotatedImagePath": "output\\annotated_frames\\page_2_annotated.png",
      "pageWidth": 725,
      "pageHeight": 1024
    },
    {
      "id": "page2_detection2",
      "bbox": [
        76,
        557,
        594,
        601
      ],
      "bbox_normalized": [
        0.1048,
        0.5439,
        0.8193,
        0.5869
      ],
      "label": "List-item",
      "confidence": 0.939,
      "area": 22792,
      "center": [
        335,
        579
      ],
      "width": 518,
      "height": 44,
      "extractedText": "3. To produce well-rounded, up to date, scientifically tempered, design-oriented engineer and scientists capable of lifelong learning.",
      "reading_order": 9,
      "pageNumber": 2,
      "sourceImagePath": "temp_images\\page-02.png",
      "annotatedImagePath": "output\\annotated_frames\\page_2_annotated.png",
      "pageWidth": 725,
      "pageHeight": 1024
    },
    {
      "id": "page3_detection2",
      "bbox": [
        338,
        95,
        394,
        111
      ],
      "bbox_normalized": [
        0.4662,
        0.0928,
        0.5434,
        0.1084
      ],
      "label": "Section-header",
      "confidence": 0.698,
      "area": 896,
      "center": [
        366,
        103
      ],
      "width": 56,
      "height": 16,
      "extractedText": "INDEX",
      "reading_order": 1,
      "pageNumber": 3,
      "sourceImagePath": "temp_images\\page-03.png",
      "annotatedImagePath": "output\\annotated_frames\\page_3_annotated.png",
      "pageWidth": 725,
      "pageHeight": 1024
    },
    {
      "id": "page3_detection1",
      "bbox": [
        73,
        159,
        657,
        906
      ],
      "bbox_normalized": [
        0.1007,
        0.1553,
        0.9062,
        0.8848
      ],
      "label": "Table",
      "confidence": 0.963,
      "area": 436248,
      "center": [
        365,
        533
      ],
      "width": 584,
      "height": 747,
      "extractedText": "BE —— RE Write a C program to simulate the following non- 200824 preemptive CPU scheduling algorithms to find tumaround time and waiting time for a given problem. a) FCFS, b) SIF 2, Write a C program to simulate the following 200824 preemptive CPU scheduling algorithms to find tumaround time and waiting time for a given problem. a) Round Robin b) Priority 3 Write a C program to simulate the following 280824 contiguous memory allocation techniques a) Worst fib) Best ft, c) First fit 4, Write a C program to simulate the following file 04/09/24 allocation strategies. a) Sequential, b) Indexed B Write a C program to simulate Baker's algorithm 11109724 for the purpose of Deadlock avoidance. 6 Write a C program to simulate Banker's algorithm 11109724 for the purpose of Deadlock prevention. 7 Write a C program to simulate page replacement 09/1024 algorithm a) FIFO, b) LRU Write a C program to simulate page replacement 09/1024 algorithm a) LFU, b) Optimal Write a C program to simulate producer consumer 161024 problem using semaphores. Write a C program to simulate disk scheduling 231024 algorithms a) FCFS, b) SCAN.",
      "reading_order": 2,
      "pageNumber": 3,
      "sourceImagePath": "temp_images\\page-03.png",
      "annotatedImagePath": "output\\annotated_frames\\page_3_annotated.png",
      "pageWidth": 725,
      "pageHeight": 1024
    },
    {
      "id": "page4_detection8",
      "bbox": [
        310,
        92,
        420,
        114
      ],
      "bbox_normalized": [
        0.4276,
        0.0898,
        0.5793,
        0.1113
      ],
      "label": "Section-header",
      "confidence": 0.689,
      "area": 2420,
      "center": [
        365,
        103
      ],
      "width": 110,
      "height": 22,
      "extractedText": "Experiment - 1",
      "reading_order": 1,
      "pageNumber": 4,
      "sourceImagePath": "temp_images\\page-04.png",
      "annotatedImagePath": "output\\annotated_frames\\page_4_annotated.png",
      "pageWidth": 725,
      "pageHeight": 1024
    },
    {
      "id": "page4_detection4",
      "bbox": [
        81,
        155,
        641,
        195
      ],
      "bbox_normalized": [
        0.1117,
        0.1514,
        0.8841,
        0.1904
      ],
      "label": "Text",
      "confidence": 0.919,
      "area": 22400,
      "center": [
        361,
        175
      ],
      "width": 560,
      "height": 40,
      "extractedText": "Aim: Write a C program to simulate the following non-preemptive CPU scheduling algorithms to find turnaround time and waiting time for a given problem. a) FCFS, b) SJF",
      "reading_order": 2,
      "pageNumber": 4,
      "sourceImagePath": "temp_images\\page-04.png",
      "annotatedImagePath": "output\\annotated_frames\\page_4_annotated.png",
      "pageWidth": 725,
      "pageHeight": 1024
    },
    {
      "id": "page4_detection11",
      "bbox": [
        81,
        222,
        161,
        241
      ],
      "bbox_normalized": [
        0.1117,
        0.2168,
        0.2221,
        0.2354
      ],
      "label": "Section-header",
      "confidence": 0.643,
      "area": 1520,
      "center": [
        121,
        232
      ],
      "width": 80,
      "height": 19,
      "extractedText": "Description",
      "reading_order": 3,
      "pageNumber": 4,
      "sourceImagePath": "temp_images\\page-04.png",
      "annotatedImagePath": "output\\annotated_frames\\page_4_annotated.png",
      "pageWidth": 725,
      "pageHeight": 1024
    },
    {
      "id": "page4_detection3",
      "bbox": [
        81,
        275,
        633,
        377
      ],
      "bbox_normalized": [
        0.1117,
        0.2686,
        0.8731,
        0.3682
      ],
      "label": "Text",
      "confidence": 0.96,
      "area": 56304,
      "center": [
        357,
        326
      ],
      "width": 552,
      "height": 102,
      "extractedText": "FCFS is one of the simplest CPU scheduling algorithms. In this algorithm, the process that arrives first in the ready queue gets executed first. The scheduling is done based on the arrival time of the processes, meaning that processes are served in the order they arrive without preemption. FCFS is easy to implement and understand; however, it can lead to the \"convoy effect,” where short processes wait for a long process to finish, resulting in increased average waiting time.",
      "reading_order": 4,
      "pageNumber": 4,
      "sourceImagePath": "temp_images\\page-04.png",
      "annotatedImagePath": "output\\annotated_frames\\page_4_annotated.png",
      "pageWidth": 725,
      "pageHeight": 1024
    },
    {
      "id": "page4_detection9",
      "bbox": [
        81,
        393,
        220,
        409
      ],
      "bbox_normalized": [
        0.1117,
        0.3838,
        0.3034,
        0.3994
      ],
      "label": "Section-header",
      "confidence": 0.687,
      "area": 2224,
      "center": [
        151,
        401
      ],
      "width": 139,
      "height": 16,
      "extractedText": "Shortest Job First (SJF)",
      "reading_order": 5,
      "pageNumber": 4,
      "sourceImagePath": "temp_images\\page-04.png",
      "annotatedImagePath": "output\\annotated_frames\\page_4_annotated.png",
      "pageWidth": 725,
      "pageHeight": 1024
    },
    {
      "id": "page4_detection2",
      "bbox": [
        80,
        425,
        650,
        527
      ],
      "bbox_normalized": [
        0.1103,
        0.415,
        0.8966,
        0.5146
      ],
      "label": "Text",
      "confidence": 0.966,
      "area": 58140,
      "center": [
        365,
        476
      ],
      "width": 570,
      "height": 102,
      "extractedText": "Shortest Job First (SIF) is a non-preemptive scheduling algorithm that selects the process with the smallest burst time (execution time) for execution first. By executing shorter processes before longer ones, SIF can minimize the average waiting time and turnaround time for a set of processes. However, determining the shortest job can be challenging in a real-time system where the lengths of jobs are not known in advance. This algorithm can lead to the \"starvation\" of longer processes if there is a continuous stream of shorter processes arriving.",
      "reading_order": 6,
      "pageNumber": 4,
      "sourceImagePath": "temp_images\\page-04.png",
      "annotatedImagePath": "output\\annotated_frames\\page_4_annotated.png",
      "pageWidth": 725,
      "pageHeight": 1024
    },
    {
      "id": "page4_detection5",
      "bbox": [
        81,
        544,
        131,
        562
      ],
      "bbox_normalized": [
        0.1117,
        0.5313,
        0.1807,
        0.5488
      ],
      "label": "Section-header",
      "confidence": 0.859,
      "area": 900,
      "center": [
        106,
        553
      ],
      "width": 50,
      "height": 18,
      "extractedText": "Theory",
      "reading_order": 7,
      "pageNumber": 4,
      "sourceImagePath": "temp_images\\page-04.png",
      "annotatedImagePath": "output\\annotated_frames\\page_4_annotated.png",
      "pageWidth": 725,
      "pageHeight": 1024
    },
    {
      "id": "page4_detection1",
      "bbox": [
        80,
        579,
        651,
        697
      ],
      "bbox_normalized": [
        0.1103,
        0.5654,
        0.8979,
        0.6807
      ],
      "label": "Text",
      "confidence": 0.968,
      "area": 67378,
      "center": [
        366,
        638
      ],
      "width": 571,
      "height": 118,
      "extractedText": "CPU scheduling is a crucial aspect of operating systems that determines the order in which processes are executed. The primary goals of CPU scheduling are to maximize CPU utilization, ensure fairmess among processes, minimize tumaround time, waiting time, and response time, and avoid starvation. Different algorithms have different approaches to scheduling, and the choice of algorithm can significantly impact system performance. Non-preemptive algorithms, such as FCFS and SIF, do not allow a currently executing process to be interrupted; instead, they run to completion before the CPU is allocated to the next process.",
      "reading_order": 8,
      "pageNumber": 4,
      "sourceImagePath": "temp_images\\page-04.png",
      "annotatedImagePath": "output\\annotated_frames\\page_4_annotated.png",
      "pageWidth": 725,
      "pageHeight": 1024
    },
    {
      "id": "page4_detection12",
      "bbox": [
        85,
        729,
        129,
        749
      ],
      "bbox_normalized": [
        0.1172,
        0.7119,
        0.1779,
        0.7314
      ],
      "label": "Section-header",
      "confidence": 0.519,
      "area": 880,
      "center": [
        107,
        739
      ],
      "width": 44,
      "height": 20,
      "extractedText": "Code:",
      "reading_order": 9,
      "pageNumber": 4,
      "sourceImagePath": "temp_images\\page-04.png",
      "annotatedImagePath": "output\\annotated_frames\\page_4_annotated.png",
      "pageWidth": 725,
      "pageHeight": 1024
    },
    {
      "id": "page4_detection7",
      "bbox": [
        81,
        750,
        179,
        767
      ],
      "bbox_normalized": [
        0.1117,
        0.7324,
        0.2469,
        0.749
      ],
      "label": "Text",
      "confidence": 0.714,
      "area": 1666,
      "center": [
        130,
        759
      ],
      "width": 98,
      "height": 17,
      "extractedText": "#include <stdio.h>",
      "reading_order": 10,
      "pageNumber": 4,
      "sourceImagePath": "temp_images\\page-04.png",
      "annotatedImagePath": "output\\annotated_frames\\page_4_annotated.png",
      "pageWidth": 725,
      "pageHeight": 1024
    },
    {
      "id": "page4_detection6",
      "bbox": [
        79,
        786,
        290,
        854
      ],
      "bbox_normalized": [
        0.109,
        0.7676,
        0.4,
        0.834
      ],
      "label": "Text",
      "confidence": 0.734,
      "area": 14348,
      "center": [
        185,
        820
      ],
      "width": 211,
      "height": 68,
      "extractedText": "int main) { intn; . print \"Enter number of processes: \") scanf(\"%d\", &n);",
      "reading_order": 11,
      "pageNumber": 4,
      "sourceImagePath": "temp_images\\page-04.png",
      "annotatedImagePath": "output\\annotated_frames\\page_4_annotated.png",
      "pageWidth": 725,
      "pageHeight": 1024
    },
    {
      "id": "page4_detection10",
      "bbox": [
        94,
        871,
        349,
        889
      ],
      "bbox_normalized": [
        0.1297,
        0.8506,
        0.4814,
        0.8682
      ],
      "label": "Text",
      "confidence": 0.68,
      "area": 4590,
      "center": [
        222,
        880
      ],
      "width": 255,
      "height": 18,
      "extractedText": "int arrival[n]. burst[n], waiting[n], turnaround[n];",
      "reading_order": 12,
      "pageNumber": 4,
      "sourceImagePath": "temp_images\\page-04.png",
      "annotatedImagePath": "output\\annotated_frames\\page_4_annotated.png",
      "pageWidth": 725,
      "pageHeight": 1024
    },
    {
      "id": "page5_detection1",
      "bbox": [
        92,
        99,
        543,
        996
      ],
      "bbox_normalized": [
        0.1269,
        0.0967,
        0.749,
        0.9727
      ],
      "label": "Text",
      "confidence": 0.912,
      "area": 404547,
      "center": [
        318,
        548
      ],
      "width": 451,
      "height": 897,
      "extractedText": "wartinglul = for ini = 1 <n; +4) { waiting(i] = waitngfi - 1] + burs - 11; ) for in = 03 <n; ++) { ‘wmaround(i] = waiingfi + burs il; ) print(\"n—— FCFS Scheduling in\"); print \"Process Arrival\\t Burst Waiting { Tumaroundin”): for int = 0: <n; i++) { print\" Ad 9d 5 da, + 1, aval i, burs], waiting], maround{il): ) int toalWaitingF CFS =0, otaTurnaround CFS =0; for in = 0: <n; i++) { total WaitngFCFS += waiting(i: total TumaroundFCFS += turnaround]; ) print(\"Total Waiting Time (FCFS): 9d”, total WaitingF CFS); printf(\"Total Tumaround Time (FCFS): 9d”, otal TumaroundFCFS); for in = 03 <n; ++) { waitingli] = 0; ) for int i= 0: <n- 1; #09) { for (nj =i + 13j < mij) | if burst] > burst[j]) { int tempBurst = burst: burs] = burs: burs] = tempBurst; int tempAival = anivalfil arivall] = arrival; arivall] = tempArival; ) ) ) for in = <n; i++) { waiting(i] = waitngfi - 1] + burs - 11; ) for in = 03 <n; ++) { ‘wmaround(i] = waiting] + burs il; ) print(\"n—— SIF Scheduling i\"); print \"Process't Arrival\\t Burst iW aiting { Tumaroundin”): for (int = 0: <n: iH) |",
      "reading_order": 1,
      "pageNumber": 5,
      "sourceImagePath": "temp_images\\page-05.png",
      "annotatedImagePath": "output\\annotated_frames\\page_5_annotated.png",
      "pageWidth": 725,
      "pageHeight": 1024
    },
    {
      "id": "page6_detection2",
      "bbox": [
        83,
        96,
        539,
        299
      ],
      "bbox_normalized": [
        0.1145,
        0.0938,
        0.7434,
        0.292
      ],
      "label": "Text",
      "confidence": 0.916,
      "area": 92568,
      "center": [
        311,
        198
      ],
      "width": 456,
      "height": 203,
      "extractedText": "printf\" %dt%dt%d\\t%d\\t%d\\n\", 1+ 1, arrival[i], bursti), waiting] 1}, tumaround]i]); } int otalWaitingS JF =, total TumaroundSJF = 0; for (nti =0:i <n: #4) | total WaitingSJF += wating[i]; total TumaroundS JF += tumaround(if} printf \"Total Waiting Time (SJF): %dn\", totalWaitingSJF): printf \"Total Turnaround Time (SIF): %din”, ota TumaroundSJF): retum 0;",
      "reading_order": 1,
      "pageNumber": 6,
      "sourceImagePath": "temp_images\\page-06.png",
      "annotatedImagePath": "output\\annotated_frames\\page_6_annotated.png",
      "pageWidth": 725,
      "pageHeight": 1024
    },
    {
      "id": "page6_detection3",
      "bbox": [
        81,
        318,
        136,
        335
      ],
      "bbox_normalized": [
        0.1117,
        0.3105,
        0.1876,
        0.3271
      ],
      "label": "Section-header",
      "confidence": 0.736,
      "area": 935,
      "center": [
        109,
        327
      ],
      "width": 55,
      "height": 17,
      "extractedText": "Output:",
      "reading_order": 2,
      "pageNumber": 6,
      "sourceImagePath": "temp_images\\page-06.png",
      "annotatedImagePath": "output\\annotated_frames\\page_6_annotated.png",
      "pageWidth": 725,
      "pageHeight": 1024
    },
    {
      "id": "page6_detection1",
      "bbox": [
        90,
        345,
        563,
        681
      ],
      "bbox_normalized": [
        0.1241,
        0.3369,
        0.7766,
        0.665
      ],
      "label": "Text",
      "confidence": 0.923,
      "area": 158928,
      "center": [
        327,
        513
      ],
      "width": 473,
      "height": 336,
      "extractedText": "PS D: Viesang\\h) AlFSivoice-segregation\\Smart Farm\\smart-fam cd \"ds \\Hemang\\h) ATS os} Enter. rumber of processes: 4 Enter arrival tim and burst time for process 1: 14 Enter arrival time and burst time for process 2: 2 5 Enter arrival time and burst time for process 3: 3 1 Enter arrival time and burst time for process 4: 4 6 Process Arrival rst Waiting Turnaround 11 4 oe a 2 2 sae 303 1 sw CE Total iting Time (iF): 23 Total Turnaround Time (FCFS): 3 ~-- SIF scheduling Process Arrival Burst baiting Turnaround 13 1 oe a 2 1 4 1s 32 ss ow EN Total waiting Time (536): 16 Total Turnaround Time (SIF): 32 n",
      "reading_order": 3,
      "pageNumber": 6,
      "sourceImagePath": "temp_images\\page-06.png",
      "annotatedImagePath": "output\\annotated_frames\\page_6_annotated.png",
      "pageWidth": 725,
      "pageHeight": 1024
    },
    {
      "id": "page7_detection8",
      "bbox": [
        309,
        93,
        421,
        114
      ],
      "bbox_normalized": [
        0.4262,
        0.0908,
        0.5807,
        0.1113
      ],
      "label": "Section-header",
      "confidence": 0.657,
      "area": 2352,
      "center": [
        365,
        104
      ],
      "width": 112,
      "height": 21,
      "extractedText": "Experiment -2",
      "reading_order": 1,
      "pageNumber": 7,
      "sourceImagePath": "temp_images\\page-07.png",
      "annotatedImagePath": "output\\annotated_frames\\page_7_annotated.png",
      "pageWidth": 725,
      "pageHeight": 1024
    },
    {
      "id": "page7_detection4",
      "bbox": [
        81,
        155,
        641,
        195
      ],
      "bbox_normalized": [
        0.1117,
        0.1514,
        0.8841,
        0.1904
      ],
      "label": "Text",
      "confidence": 0.926,
      "area": 22400,
      "center": [
        361,
        175
      ],
      "width": 560,
      "height": 40,
      "extractedText": "Aim: Write a C program to simulate the following preemptive CPU scheduling algorithms to find turnaround time and waiting time for a given problem. a) Round Robin b) Priority",
      "reading_order": 2,
      "pageNumber": 7,
      "sourceImagePath": "temp_images\\page-07.png",
      "annotatedImagePath": "output\\annotated_frames\\page_7_annotated.png",
      "pageWidth": 725,
      "pageHeight": 1024
    },
    {
      "id": "page7_detection7",
      "bbox": [
        81,
        220,
        167,
        239
      ],
      "bbox_normalized": [
        0.1117,
        0.2148,
        0.2303,
        0.2334
      ],
      "label": "Section-header",
      "confidence": 0.683,
      "area": 1634,
      "center": [
        124,
        230
      ],
      "width": 86,
      "height": 19,
      "extractedText": "Description:",
      "reading_order": 3,
      "pageNumber": 7,
      "sourceImagePath": "temp_images\\page-07.png",
      "annotatedImagePath": "output\\annotated_frames\\page_7_annotated.png",
      "pageWidth": 725,
      "pageHeight": 1024
    },
    {
      "id": "page7_detection1",
      "bbox": [
        80,
        255,
        648,
        323
      ],
      "bbox_normalized": [
        0.1103,
        0.249,
        0.8938,
        0.3154
      ],
      "label": "Text",
      "confidence": 0.952,
      "area": 38624,
      "center": [
        364,
        289
      ],
      "width": 568,
      "height": 68,
      "extractedText": "Round Robin (RR): The Round Robin (RR) scheduling algorithm assigns a fixed time quantum (or time slice) to each process ina cyclic order. Each process is given a small portion of CPU time in a round-robin manner. If a process does not finish execution within its time slice, it is placed back in the queue for another tum. This continues until all processes are completed.",
      "reading_order": 4,
      "pageNumber": 7,
      "sourceImagePath": "temp_images\\page-07.png",
      "annotatedImagePath": "output\\annotated_frames\\page_7_annotated.png",
      "pageWidth": 725,
      "pageHeight": 1024
    },
    {
      "id": "page7_detection2",
      "bbox": [
        81,
        338,
        646,
        407
      ],
      "bbox_normalized": [
        0.1117,
        0.3301,
        0.891,
        0.3975
      ],
      "label": "Text",
      "confidence": 0.945,
      "area": 38985,
      "center": [
        364,
        373
      ],
      "width": 565,
      "height": 69,
      "extractedText": "Priority Scheduling: Priority Scheduling assigns priorities to processes, where a higher priority value indicates a higher priority for execution. In the preemptive version of this algorithm, a process with a higher priority can preempt a currently inning process, meaning the currently running process may be interrupted if a new process with a higher priority arrives.",
      "reading_order": 5,
      "pageNumber": 7,
      "sourceImagePath": "temp_images\\page-07.png",
      "annotatedImagePath": "output\\annotated_frames\\page_7_annotated.png",
      "pageWidth": 725,
      "pageHeight": 1024
    },
    {
      "id": "page7_detection6",
      "bbox": [
        81,
        424,
        144,
        443
      ],
      "bbox_normalized": [
        0.1117,
        0.4141,
        0.1986,
        0.4326
      ],
      "label": "Section-header",
      "confidence": 0.7,
      "area": 1197,
      "center": [
        113,
        434
      ],
      "width": 63,
      "height": 19,
      "extractedText": "Theory:",
      "reading_order": 6,
      "pageNumber": 7,
      "sourceImagePath": "temp_images\\page-07.png",
      "annotatedImagePath": "output\\annotated_frames\\page_7_annotated.png",
      "pageWidth": 725,
      "pageHeight": 1024
    },
    {
      "id": "page7_detection5",
      "bbox": [
        80,
        459,
        640,
        528
      ],
      "bbox_normalized": [
        0.1103,
        0.4482,
        0.8828,
        0.5156
      ],
      "label": "Text",
      "confidence": 0.86,
      "area": 38640,
      "center": [
        360,
        494
      ],
      "width": 560,
      "height": 69,
      "extractedText": "Round Robin Scheduling: The process that gets the CPU for a time quantum and does not finish in that quantum is put back into the ready queue, while the next process gets executed. The round-robin algorithm is fair but can result in high turnaround time if processes have large burst times compared to the time quantum.",
      "reading_order": 7,
      "pageNumber": 7,
      "sourceImagePath": "temp_images\\page-07.png",
      "annotatedImagePath": "output\\annotated_frames\\page_7_annotated.png",
      "pageWidth": 725,
      "pageHeight": 1024
    },
    {
      "id": "page7_detection3",
      "bbox": [
        80,
        543,
        632,
        596
      ],
      "bbox_normalized": [
        0.1103,
        0.5303,
        0.8717,
        0.582
      ],
      "label": "Text",
      "confidence": 0.939,
      "area": 29256,
      "center": [
        356,
        570
      ],
      "width": 552,
      "height": 53,
      "extractedText": "Priority Scheduling: In preemptive priority scheduling, the process with the highest priority (numerically lower value) gets the CPU. If a new process with higher priority arrives while another process is running, the current process is preempted, and the new process is executed.",
      "reading_order": 8,
      "pageNumber": 7,
      "sourceImagePath": "temp_images\\page-07.png",
      "annotatedImagePath": "output\\annotated_frames\\page_7_annotated.png",
      "pageWidth": 725,
      "pageHeight": 1024
    },
    {
      "id": "page7_detection9",
      "bbox": [
        82,
        642,
        417,
        995
      ],
      "bbox_normalized": [
        0.1131,
        0.627,
        0.5752,
        0.9717
      ],
      "label": "Text",
      "confidence": 0.613,
      "area": 118255,
      "center": [
        250,
        819
      ],
      "width": 335,
      "height": 353,
      "extractedText": "finclude <sidio > truct Process | int id: int burst; int arival; int remaining Burs; int waiting, int wmarounds int priority; : void roundR obinstruct Process proc], int, int time Quantum) | int otalTime =0: int completed = 0; inti; int oWaiting = 0, total Tumaround = 0; while (completed <1) { for (i=0; i< m i++) {",
      "reading_order": 9,
      "pageNumber": 7,
      "sourceImagePath": "temp_images\\page-07.png",
      "annotatedImagePath": "output\\annotated_frames\\page_7_annotated.png",
      "pageWidth": 725,
      "pageHeight": 1024
    },
    {
      "id": "page8_detection1",
      "bbox": [
        79,
        94,
        576,
        995
      ],
      "bbox_normalized": [
        0.109,
        0.0918,
        0.7945,
        0.9717
      ],
      "label": "Text",
      "confidence": 0.706,
      "area": 447797,
      "center": [
        328,
        545
      ],
      "width": 497,
      "height": 901,
      "extractedText": "if (proc{i].remainingBurst > 0) { if (rocli] remainingBurst > timeQuantum) { totalTime += time Quantu; proc] remaining Burst — time Quantum; else { totalTime +— proc{i] remainingBurst: procli] waiting = totalTime - procfi] burst, procli]umaround = procfi] waiting + proc|i] burst totalWaiting += proc{i] waiting: totalTumaround + procfi] umaround; procli] remaining Burst = 0; completed-+; ) ) ) ) printf(\"nRound Robin Schedulingin’): printf(\"Process Burs Waiting Tumaroundin\"): for(i=0ri< ms i+) { printf\" t%d 2d 81%dn’. proc. id. proc) burst, proc] waiting. proc(i]tumaround): ) printf(\" Average Waiting Time: %2fn\", (float total Waiting / 1): printf(\" Average Tumaround Time: %. 20\", (float)otal Turnaround /n): ) void priority Scheduling(struct Process proc{], int 1) { int otalTime = 0; int completed = 0; inti; int totalWaiting = 0, total Tamaround = 0; int highestPrioritylds: while (completed < ) { highestPriortyldx = -1; int highestPriority 9999: for(i =0:i< m i++) { if (proc]i].remining Burst > 0 && prac] priority < highestPriority) { highestPriority proc(i. priority; highestPriorityldx =i; ) ) if (highestPriorityldx 1=-1) { total Time + proc{highestPriorityld] remainingBurst: procihighestPriorityldx] waiting ~ total Time - proc[highestPriorityldx] burst prochighestPriorityldx] tumaround proc highestPriorityldx waiting + procihighestPriorityldx] burst; total Waiting += proc highestPriority ld] waiting; total Tumaround += prac[highestPriorityldx] turnaround; procihighestPriorityldx] remaining Burst = 0;",
      "reading_order": 1,
      "pageNumber": 8,
      "sourceImagePath": "temp_images\\page-08.png",
      "annotatedImagePath": "output\\annotated_frames\\page_8_annotated.png",
      "pageWidth": 725,
      "pageHeight": 1024
    },
    {
      "id": "page9_detection1",
      "bbox": [
        80,
        94,
        585,
        837
      ],
      "bbox_normalized": [
        0.1103,
        0.0918,
        0.8069,
        0.8174
      ],
      "label": "Text",
      "confidence": 0.901,
      "area": 375215,
      "center": [
        333,
        466
      ],
      "width": 505,
      "height": 743,
      "extractedText": "completed++; ) ) printf(\"nPriority Schedulingn\"): printf(\"Processi Priority tBurs( Waiting Turnaround\\n\"): for(i=0ri< mi) { printf\" did 4% %d 02d\", proc id, proc{il priority, proc burst, procli] waiting, proc(i] tumaround); ) printf(\" Average Waiting Time: %2fn\", (float total Waiting / 1): printf(\" Average Tumaround Time: %. 20\", (float)otal Turnaround /n): ] int main() { int n, timeQuantum; printf(\"Enter number of processes: ); scanf(\"%d\", &n): struct Process proc[n; for (inti = 0; i <n; 44) | printf{\"Enter arrival time, burst time and priority for process %d:\". i + 1); scanf{\"%d %d %d\", &proc[i] rival, profi] burst, &procfi] priority); proc(ilid=i+ 1; proc(i] remaining Burst proc[i] burst proc(i] waiting = 0; procfi]tumaround = 0; ) printf(\"Enter time quantum for Round Robin: \"), scanf(\" 4d\", &time Quantum): roundRobin(proc, n, time Quantum): for (inti = 0; i< n: 44) | proc(i] remaining Burst = proc[i] burst ) priorityScheduling(proc, n); retum 0; y",
      "reading_order": 1,
      "pageNumber": 9,
      "sourceImagePath": "temp_images\\page-09.png",
      "annotatedImagePath": "output\\annotated_frames\\page_9_annotated.png",
      "pageWidth": 725,
      "pageHeight": 1024
    },
    {
      "id": "page10_detection2",
      "bbox": [
        89,
        97,
        142,
        110
      ],
      "bbox_normalized": [
        0.1228,
        0.0947,
        0.1959,
        0.1074
      ],
      "label": "Section-header",
      "confidence": 0.573,
      "area": 689,
      "center": [
        116,
        104
      ],
      "width": 53,
      "height": 13,
      "extractedText": "vuiput:",
      "reading_order": 1,
      "pageNumber": 10,
      "sourceImagePath": "temp_images\\page-10.png",
      "annotatedImagePath": "output\\annotated_frames\\page_10_annotated.png",
      "pageWidth": 725,
      "pageHeight": 1024
    },
    {
      "id": "page10_detection1",
      "bbox": [
        91,
        121,
        516,
        520
      ],
      "bbox_normalized": [
        0.1255,
        0.1182,
        0.7117,
        0.5078
      ],
      "label": "Text",
      "confidence": 0.631,
      "area": 169575,
      "center": [
        304,
        321
      ],
      "width": 425,
      "height": 399,
      "extractedText": "-\\os-2 } Enter musber of processes: 4 Enter arrival time, burst time and priority for process 1: 13 1 Enter arrival tise, burst time and priority for process 2: 24 5 Enter arrival tise, burst time and priority for process 3: 3 6 2 Enter arrival tie, burst time and priority for process 4: 4 2 3 Enter time quantum for Round Robin: 2 Round Robin Scheduling Process Burst Waiting Turnaround 1 3 6 9 2 a 7 1u 3 6 9 15 a 2 6 8 Average Waiting Time: 7.00 Average Turnaround Tie: 10.75 priority scheduling Process Priority Burst Waiting Turnaround 1 1 3 0) 3 2 5 a un 15 3 2 6 3 B a H 2 ° nu Average Waiting Time: 5.75 Average Turnaround Time: 9.50 ~",
      "reading_order": 2,
      "pageNumber": 10,
      "sourceImagePath": "temp_images\\page-10.png",
      "annotatedImagePath": "output\\annotated_frames\\page_10_annotated.png",
      "pageWidth": 725,
      "pageHeight": 1024
    },
    {
      "id": "page11_detection14",
      "bbox": [
        309,
        94,
        421,
        115
      ],
      "bbox_normalized": [
        0.4262,
        0.0918,
        0.5807,
        0.1123
      ],
      "label": "Section-header",
      "confidence": 0.63,
      "area": 2352,
      "center": [
        365,
        105
      ],
      "width": 112,
      "height": 21,
      "extractedText": "Experiment -3",
      "reading_order": 1,
      "pageNumber": 11,
      "sourceImagePath": "temp_images\\page-11.png",
      "annotatedImagePath": "output\\annotated_frames\\page_11_annotated.png",
      "pageWidth": 725,
      "pageHeight": 1024
    },
    {
      "id": "page11_detection12",
      "bbox": [
        81,
        177,
        269,
        196
      ],
      "bbox_normalized": [
        0.1117,
        0.1729,
        0.371,
        0.1914
      ],
      "label": "Text",
      "confidence": 0.664,
      "area": 3572,
      "center": [
        175,
        187
      ],
      "width": 188,
      "height": 19,
      "extractedText": "Worst fit, b) Best fit, ¢) First fit",
      "reading_order": 2,
      "pageNumber": 11,
      "sourceImagePath": "temp_images\\page-11.png",
      "annotatedImagePath": "output\\annotated_frames\\page_11_annotated.png",
      "pageWidth": 725,
      "pageHeight": 1024
    },
    {
      "id": "page11_detection10",
      "bbox": [
        81,
        221,
        167,
        241
      ],
      "bbox_normalized": [
        0.1117,
        0.2158,
        0.2303,
        0.2354
      ],
      "label": "Section-header",
      "confidence": 0.806,
      "area": 1720,
      "center": [
        124,
        231
      ],
      "width": 86,
      "height": 20,
      "extractedText": "Description:",
      "reading_order": 3,
      "pageNumber": 11,
      "sourceImagePath": "temp_images\\page-11.png",
      "annotatedImagePath": "output\\annotated_frames\\page_11_annotated.png",
      "pageWidth": 725,
      "pageHeight": 1024
    },
    {
      "id": "page11_detection3",
      "bbox": [
        81,
        256,
        651,
        324
      ],
      "bbox_normalized": [
        0.1117,
        0.25,
        0.8979,
        0.3164
      ],
      "label": "Text",
      "confidence": 0.975,
      "area": 38760,
      "center": [
        366,
        290
      ],
      "width": 570,
      "height": 68,
      "extractedText": "In contiguous memory allocation, the operating system assigns a single contiguous block of memory to each process. The three different allocation strategies (Worst fit, Best fit, First fit) detemine how memory is assigned. Each algorithm has its own method of selecting the memory block, with trade-offs in efficiency and the way memory is utilized.",
      "reading_order": 4,
      "pageNumber": 11,
      "sourceImagePath": "temp_images\\page-11.png",
      "annotatedImagePath": "output\\annotated_frames\\page_11_annotated.png",
      "pageWidth": 725,
      "pageHeight": 1024
    },
    {
      "id": "page11_detection5",
      "bbox": [
        103,
        339,
        628,
        392
      ],
      "bbox_normalized": [
        0.1421,
        0.3311,
        0.8662,
        0.3828
      ],
      "label": "List-item",
      "confidence": 0.968,
      "area": 27825,
      "center": [
        366,
        366
      ],
      "width": 525,
      "height": 53,
      "extractedText": "1. Worst Fit: This algorithm chooses the block of memory that is the largest among all available blocks. This is done under the assumption that leaving large gaps will leave space for future processes.",
      "reading_order": 5,
      "pageNumber": 11,
      "sourceImagePath": "temp_images\\page-11.png",
      "annotatedImagePath": "output\\annotated_frames\\page_11_annotated.png",
      "pageWidth": 725,
      "pageHeight": 1024
    },
    {
      "id": "page11_detection1",
      "bbox": [
        103,
        389,
        645,
        426
      ],
      "bbox_normalized": [
        0.1421,
        0.3799,
        0.8897,
        0.416
      ],
      "label": "List-item",
      "confidence": 0.976,
      "area": 20054,
      "center": [
        374,
        408
      ],
      "width": 542,
      "height": 37,
      "extractedText": "2. Best Fit: This algorithm selects the smallest block that is large enough to fit the process, ‘minimizing the leftover unused space in memory.",
      "reading_order": 6,
      "pageNumber": 11,
      "sourceImagePath": "temp_images\\page-11.png",
      "annotatedImagePath": "output\\annotated_frames\\page_11_annotated.png",
      "pageWidth": 725,
      "pageHeight": 1024
    },
    {
      "id": "page11_detection6",
      "bbox": [
        102,
        424,
        636,
        460
      ],
      "bbox_normalized": [
        0.1407,
        0.4141,
        0.8772,
        0.4492
      ],
      "label": "List-item",
      "confidence": 0.961,
      "area": 19224,
      "center": [
        369,
        442
      ],
      "width": 534,
      "height": 36,
      "extractedText": "3. First Fit: This algorithm assigns the first block of memory that is large enough for the process, which is simple and fast but may leave smaller gaps in memory.",
      "reading_order": 7,
      "pageNumber": 11,
      "sourceImagePath": "temp_images\\page-11.png",
      "annotatedImagePath": "output\\annotated_frames\\page_11_annotated.png",
      "pageWidth": 725,
      "pageHeight": 1024
    },
    {
      "id": "page11_detection9",
      "bbox": [
        81,
        491,
        144,
        512
      ],
      "bbox_normalized": [
        0.1117,
        0.4795,
        0.1986,
        0.5
      ],
      "label": "Section-header",
      "confidence": 0.861,
      "area": 1323,
      "center": [
        113,
        502
      ],
      "width": 63,
      "height": 21,
      "extractedText": "Theory:",
      "reading_order": 8,
      "pageNumber": 11,
      "sourceImagePath": "temp_images\\page-11.png",
      "annotatedImagePath": "output\\annotated_frames\\page_11_annotated.png",
      "pageWidth": 725,
      "pageHeight": 1024
    },
    {
      "id": "page11_detection4",
      "bbox": [
        81,
        528,
        641,
        579
      ],
      "bbox_normalized": [
        0.1117,
        0.5156,
        0.8841,
        0.5654
      ],
      "label": "Text",
      "confidence": 0.969,
      "area": 28560,
      "center": [
        361,
        554
      ],
      "width": 560,
      "height": 51,
      "extractedText": "0 Memory Fragmentation: Over time, as processes are loaded and removed, free memory is split into smaller and smaller blocks. This can lead to internal fragmentation (unused space within allocated blocks) and external fragmentation (unused memory between blocks).",
      "reading_order": 9,
      "pageNumber": 11,
      "sourceImagePath": "temp_images\\page-11.png",
      "annotatedImagePath": "output\\annotated_frames\\page_11_annotated.png",
      "pageWidth": 725,
      "pageHeight": 1024
    },
    {
      "id": "page11_detection7",
      "bbox": [
        81,
        595,
        593,
        631
      ],
      "bbox_normalized": [
        0.1117,
        0.5811,
        0.8179,
        0.6162
      ],
      "label": "Text",
      "confidence": 0.952,
      "area": 18432,
      "center": [
        337,
        613
      ],
      "width": 512,
      "height": 36,
      "extractedText": "11 Contiguous Memory Allocation: In this scheme, cach process is allocated a single continuous block of memory.",
      "reading_order": 10,
      "pageNumber": 11,
      "sourceImagePath": "temp_images\\page-11.png",
      "annotatedImagePath": "output\\annotated_frames\\page_11_annotated.png",
      "pageWidth": 725,
      "pageHeight": 1024
    },
    {
      "id": "page11_detection2",
      "bbox": [
        81,
        645,
        630,
        698
      ],
      "bbox_normalized": [
        0.1117,
        0.6299,
        0.869,
        0.6816
      ],
      "label": "Text",
      "confidence": 0.975,
      "area": 29097,
      "center": [
        356,
        672
      ],
      "width": 549,
      "height": 53,
      "extractedText": "0 Memory Allocation Algorithms: The three algorithms help in minimizing fragmentation and efficiently allocating memory, but they have different ways of selecting which block to assign toa Process.",
      "reading_order": 11,
      "pageNumber": 11,
      "sourceImagePath": "temp_images\\page-11.png",
      "annotatedImagePath": "output\\annotated_frames\\page_11_annotated.png",
      "pageWidth": 725,
      "pageHeight": 1024
    },
    {
      "id": "page11_detection11",
      "bbox": [
        81,
        713,
        124,
        733
      ],
      "bbox_normalized": [
        0.1117,
        0.6963,
        0.171,
        0.7158
      ],
      "label": "Section-header",
      "confidence": 0.742,
      "area": 860,
      "center": [
        103,
        723
      ],
      "width": 43,
      "height": 20,
      "extractedText": "Code:",
      "reading_order": 12,
      "pageNumber": 11,
      "sourceImagePath": "temp_images\\page-11.png",
      "annotatedImagePath": "output\\annotated_frames\\page_11_annotated.png",
      "pageWidth": 725,
      "pageHeight": 1024
    },
    {
      "id": "page11_detection13",
      "bbox": [
        81,
        733,
        179,
        751
      ],
      "bbox_normalized": [
        0.1117,
        0.7158,
        0.2469,
        0.7334
      ],
      "label": "Text",
      "confidence": 0.633,
      "area": 1764,
      "center": [
        130,
        742
      ],
      "width": 98,
      "height": 18,
      "extractedText": "#include <stdio.h>",
      "reading_order": 13,
      "pageNumber": 11,
      "sourceImagePath": "temp_images\\page-11.png",
      "annotatedImagePath": "output\\annotated_frames\\page_11_annotated.png",
      "pageWidth": 725,
      "pageHeight": 1024
    },
    {
      "id": "page11_detection8",
      "bbox": [
        81,
        769,
        439,
        993
      ],
      "bbox_normalized": [
        0.1117,
        0.751,
        0.6055,
        0.9697
      ],
      "label": "Text",
      "confidence": 0.903,
      "area": 80192,
      "center": [
        260,
        881
      ],
      "width": 358,
      "height": 224,
      "extractedText": "void worstFit(int blockSize[], int m, int processSize{], int n) { int allocation(n]: for (inti = 0: 1 #4) | allocation[i] =-1 } for (inti = 0: i< #4) | int maxlndex =-1: for (nt = 05] <mzj+) if (blockSizej] > processSizefi]) | if (maxlndex = -1 | BlockSizelj] > bockSizelmaxindex) | ‘maxindex =f; )",
      "reading_order": 14,
      "pageNumber": 11,
      "sourceImagePath": "temp_images\\page-11.png",
      "annotatedImagePath": "output\\annotated_frames\\page_11_annotated.png",
      "pageWidth": 725,
      "pageHeight": 1024
    },
    {
      "id": "page12_detection1",
      "bbox": [
        80,
        97,
        615,
        997
      ],
      "bbox_normalized": [
        0.1103,
        0.0947,
        0.8483,
        0.9736
      ],
      "label": "Text",
      "confidence": 0.945,
      "area": 481500,
      "center": [
        348,
        547
      ],
      "width": 535,
      "height": 900,
      "extractedText": "i } if (maxindex 1=-1) { allocaioni] = maxindex; blockSize[maxndex] = processSizeliJ: } } printf(\"nWarst Fit Allocation'n\"): printf(\"Process No. Process Size Black No.tBlack Sizeln'); for (inti = 0: i< #4) | if allocatonfi] =-1) PAR CAA %d An\", + 1. processSize[i. allocationf] + 1, blockSize allocation]: else PrABA\" 9d 4% Not Allocated i+ 1, processSizell): } ] void bestFiint lockSize], int m, int processSizel], nt) { int allocation(n]: for (inti = 0: 1< #4) | allocation[i] =-1 } for (inti = 0: i< #4) | int bestindex =-15 for (nt = 05] <mzj+) if (blockSizej] >= processSizefil) { if (bestindex —-1 | blockSiz(j] < blockSize{bestindex]) | bastindex =; } } } if (estindex 1= 1) { allocationfi] = bestindex: blockSizelbestindex] = processSizeli; } } printf(\"nBest Fit Allocation’); printf(\"Process No. Process Size Black No.tBlack Sizeln'); for (inti = 0: 1< #4) | if allocationfi] =-1) PAR CAA %d An\", + 1. processSize[i. allocationf] + 1, blockSize allocation]: else PrABA\" 9d 4% Not Allocated i+ 1, processSizell): } ] void firstFit(int blockSize[], int m, int pracessSize[], it n) {",
      "reading_order": 1,
      "pageNumber": 12,
      "sourceImagePath": "temp_images\\page-12.png",
      "annotatedImagePath": "output\\annotated_frames\\page_12_annotated.png",
      "pageWidth": 725,
      "pageHeight": 1024
    },
    {
      "id": "page13_detection1",
      "bbox": [
        80,
        90,
        614,
        992
      ],
      "bbox_normalized": [
        0.1103,
        0.0879,
        0.8469,
        0.9688
      ],
      "label": "Text",
      "confidence": 0.941,
      "area": 481668,
      "center": [
        347,
        541
      ],
      "width": 534,
      "height": 902,
      "extractedText": "int allocation]; for (inti = 0: 1 #4) | allocationfi] =-1: ) for (inti = 0:1 < #4) | for (nt = 05] < mz) if (blockSizej] >= processSizefil) { allocationfi] = J; blockSizelj] = processSizel; break; ) ) ) printf(\"nFirst Fit Allocationn\"): printf(\"Process No. Process Size! Block No Block Sizeln\"): for (inti = 0: i< #4) | if allocation(i] 1=-1) PHB\" %d CAAA An\", + 1. processSize[i. allocationfi] + 1. blockSizelallocatonfi): ele printf\" 4d 4% Not Allocatedn’, i + 1, processSizeli); ) ] int main() { int m,n; printf(\"Enter the number of memory blocks: ); scanf(\" id\", &m); int blockSize[m]: printf(\"Enter the sizes of memory blacks: \"): for (inti = 0: i< m: i++) { scanf{\"%d\", &blockSizeli); ) printf(\"Enter the number of processes: \"), scanf(\"%d\", &n): int processSizefnl; printf(\"Enter the sizes of processes: \"); for (inti = 0: i< #4) | scanf{\"%d\", &processSizefi]): ) worstFit(blockSize, m, processSize, nf. bestFit(block Size, m, processSize, n); firsFit(blockSize, m, processSize, n): retum 0; N",
      "reading_order": 1,
      "pageNumber": 13,
      "sourceImagePath": "temp_images\\page-13.png",
      "annotatedImagePath": "output\\annotated_frames\\page_13_annotated.png",
      "pageWidth": 725,
      "pageHeight": 1024
    },
    {
      "id": "page14_detection1",
      "bbox": [
        88,
        141,
        142,
        155
      ],
      "bbox_normalized": [
        0.1214,
        0.1377,
        0.1959,
        0.1514
      ],
      "label": "Section-header",
      "confidence": 0.755,
      "area": 756,
      "center": [
        115,
        148
      ],
      "width": 54,
      "height": 14,
      "extractedText": "Output:",
      "reading_order": 1,
      "pageNumber": 14,
      "sourceImagePath": "temp_images\\page-14.png",
      "annotatedImagePath": "output\\annotated_frames\\page_14_annotated.png",
      "pageWidth": 725,
      "pageHeight": 1024
    },
    {
      "id": "page15_detection12",
      "bbox": [
        334,
        94,
        451,
        116
      ],
      "bbox_normalized": [
        0.4217,
        0.0918,
        0.5694,
        0.1133
      ],
      "label": "Section-header",
      "confidence": 0.611,
      "area": 2574,
      "center": [
        393,
        105
      ],
      "width": 117,
      "height": 22,
      "extractedText": "Experiment -4",
      "reading_order": 1,
      "pageNumber": 15,
      "sourceImagePath": "temp_images\\page-15.png",
      "annotatedImagePath": "output\\annotated_frames\\page_15_annotated.png",
      "pageWidth": 792,
      "pageHeight": 1024
    },
    {
      "id": "page15_detection6",
      "bbox": [
        105,
        159,
        673,
        203
      ],
      "bbox_normalized": [
        0.1326,
        0.1553,
        0.8497,
        0.1982
      ],
      "label": "Text",
      "confidence": 0.881,
      "area": 24992,
      "center": [
        389,
        181
      ],
      "width": 568,
      "height": 44,
      "extractedText": "Aim: Write a C program to simulate the following file allocation strategies. a) Sequential, b) Indexed",
      "reading_order": 2,
      "pageNumber": 15,
      "sourceImagePath": "temp_images\\page-15.png",
      "annotatedImagePath": "output\\annotated_frames\\page_15_annotated.png",
      "pageWidth": 792,
      "pageHeight": 1024
    },
    {
      "id": "page15_detection7",
      "bbox": [
        105,
        229,
        192,
        249
      ],
      "bbox_normalized": [
        0.1326,
        0.2236,
        0.2424,
        0.2432
      ],
      "label": "Section-header",
      "confidence": 0.817,
      "area": 1740,
      "center": [
        149,
        239
      ],
      "width": 87,
      "height": 20,
      "extractedText": "Description:",
      "reading_order": 3,
      "pageNumber": 15,
      "sourceImagePath": "temp_images\\page-15.png",
      "annotatedImagePath": "output\\annotated_frames\\page_15_annotated.png",
      "pageWidth": 792,
      "pageHeight": 1024
    },
    {
      "id": "page15_detection2",
      "bbox": [
        105,
        265,
        676,
        339
      ],
      "bbox_normalized": [
        0.1326,
        0.2588,
        0.8535,
        0.3311
      ],
      "label": "Text",
      "confidence": 0.958,
      "area": 42254,
      "center": [
        391,
        302
      ],
      "width": 571,
      "height": 74,
      "extractedText": "In Sequential Allocation, files are stored in contiguous blocks on the disk. This means that when a file is created, it occupies a series of consecutive disk blocks, allowing for easy and fast sequential access. However, this method can lead to issues like fragmentation when files are deleted, making it harder to find contiguous free space for new files.",
      "reading_order": 4,
      "pageNumber": 15,
      "sourceImagePath": "temp_images\\page-15.png",
      "annotatedImagePath": "output\\annotated_frames\\page_15_annotated.png",
      "pageWidth": 792,
      "pageHeight": 1024
    },
    {
      "id": "page15_detection3",
      "bbox": [
        105,
        355,
        670,
        446
      ],
      "bbox_normalized": [
        0.1326,
        0.3467,
        0.846,
        0.4355
      ],
      "label": "Text",
      "confidence": 0.955,
      "area": 51415,
      "center": [
        388,
        401
      ],
      "width": 565,
      "height": 91,
      "extractedText": "In Indexed Allocation, each file has an index block that contains pointers to all the disk blocks allocated to that file. This allows non-contiguous allocation of files, which can lead 0 better utilization of disk space. While accessing a file may require an additional read to get the index block, it significantly reduces fragmentation and allows for efficient file management.",
      "reading_order": 5,
      "pageNumber": 15,
      "sourceImagePath": "temp_images\\page-15.png",
      "annotatedImagePath": "output\\annotated_frames\\page_15_annotated.png",
      "pageWidth": 792,
      "pageHeight": 1024
    },
    {
      "id": "page15_detection5",
      "bbox": [
        105,
        498,
        670,
        554
      ],
      "bbox_normalized": [
        0.1326,
        0.4863,
        0.846,
        0.541
      ],
      "label": "Text",
      "confidence": 0.941,
      "area": 31640,
      "center": [
        388,
        526
      ],
      "width": 565,
      "height": 56,
      "extractedText": "71 File Allocation: The method by which files are stored in memory and how they are accessed by the operating system. Effective file allocation is essential for maximizing disk utilization and minimizing access time.",
      "reading_order": 6,
      "pageNumber": 15,
      "sourceImagePath": "temp_images\\page-15.png",
      "annotatedImagePath": "output\\annotated_frames\\page_15_annotated.png",
      "pageWidth": 792,
      "pageHeight": 1024
    },
    {
      "id": "page15_detection4",
      "bbox": [
        105,
        570,
        661,
        607
      ],
      "bbox_normalized": [
        0.1326,
        0.5566,
        0.8346,
        0.5928
      ],
      "label": "Text",
      "confidence": 0.947,
      "area": 20572,
      "center": [
        383,
        589
      ],
      "width": 556,
      "height": 37,
      "extractedText": "| Sequential Allocation: Stores files in a contiguous manner, leading to fast access but potential fragmentation issues.",
      "reading_order": 7,
      "pageNumber": 15,
      "sourceImagePath": "temp_images\\page-15.png",
      "annotatedImagePath": "output\\annotated_frames\\page_15_annotated.png",
      "pageWidth": 792,
      "pageHeight": 1024
    },
    {
      "id": "page15_detection1",
      "bbox": [
        105,
        624,
        655,
        679
      ],
      "bbox_normalized": [
        0.1326,
        0.6094,
        0.827,
        0.6631
      ],
      "label": "Text",
      "confidence": 0.959,
      "area": 30250,
      "center": [
        380,
        652
      ],
      "width": 550,
      "height": 55,
      "extractedText": "J Indexed Allocation: Uses an index to track file blocks, allowing for non-contiguous storage and better space utilization, though it may introduce overhead due to additional reads.",
      "reading_order": 8,
      "pageNumber": 15,
      "sourceImagePath": "temp_images\\page-15.png",
      "annotatedImagePath": "output\\annotated_frames\\page_15_annotated.png",
      "pageWidth": 792,
      "pageHeight": 1024
    },
    {
      "id": "page15_detection8",
      "bbox": [
        109,
        695,
        156,
        718
      ],
      "bbox_normalized": [
        0.1376,
        0.6787,
        0.197,
        0.7012
      ],
      "label": "Section-header",
      "confidence": 0.8,
      "area": 1081,
      "center": [
        133,
        707
      ],
      "width": 47,
      "height": 23,
      "extractedText": "Code:",
      "reading_order": 9,
      "pageNumber": 15,
      "sourceImagePath": "temp_images\\page-15.png",
      "annotatedImagePath": "output\\annotated_frames\\page_15_annotated.png",
      "pageWidth": 792,
      "pageHeight": 1024
    },
    {
      "id": "page15_detection9",
      "bbox": [
        106,
        719,
        207,
        735
      ],
      "bbox_normalized": [
        0.1338,
        0.7021,
        0.2614,
        0.7178
      ],
      "label": "Text",
      "confidence": 0.79,
      "area": 1616,
      "center": [
        157,
        727
      ],
      "width": 101,
      "height": 16,
      "extractedText": "#include <stdio.h>",
      "reading_order": 10,
      "pageNumber": 15,
      "sourceImagePath": "temp_images\\page-15.png",
      "annotatedImagePath": "output\\annotated_frames\\page_15_annotated.png",
      "pageWidth": 792,
      "pageHeight": 1024
    },
    {
      "id": "page15_detection10",
      "bbox": [
        106,
        755,
        443,
        936
      ],
      "bbox_normalized": [
        0.1338,
        0.7373,
        0.5593,
        0.9141
      ],
      "label": "Text",
      "confidence": 0.782,
      "area": 60997,
      "center": [
        275,
        846
      ],
      "width": 337,
      "height": 181,
      "extractedText": "void sequential Allocation(int fileSizes[], int n, int blockSize) { int allocated[r); for (inti = 0; <n; i+) { if (blockSize >= fileSizesfi]) { allocated[i] = 1; lockSize -= fileSizesli); else { allocated[i] 0; ’ ¥",
      "reading_order": 11,
      "pageNumber": 15,
      "sourceImagePath": "temp_images\\page-15.png",
      "annotatedImagePath": "output\\annotated_frames\\page_15_annotated.png",
      "pageWidth": 792,
      "pageHeight": 1024
    },
    {
      "id": "page15_detection11",
      "bbox": [
        118,
        958,
        345,
        993
      ],
      "bbox_normalized": [
        0.149,
        0.9355,
        0.4356,
        0.9697
      ],
      "label": "Text",
      "confidence": 0.613,
      "area": 7945,
      "center": [
        232,
        976
      ],
      "width": 227,
      "height": 35,
      "extractedText": "printf\" nSequential Allocation'n\"); orintf(\"File No.\\tFile Size'tAllocated\\n\"):",
      "reading_order": 12,
      "pageNumber": 15,
      "sourceImagePath": "temp_images\\page-15.png",
      "annotatedImagePath": "output\\annotated_frames\\page_15_annotated.png",
      "pageWidth": 792,
      "pageHeight": 1024
    },
    {
      "id": "page16_detection1",
      "bbox": [
        104,
        94,
        532,
        756
      ],
      "bbox_normalized": [
        0.1313,
        0.0918,
        0.6717,
        0.7383
      ],
      "label": "Text",
      "confidence": 0.929,
      "area": 283336,
      "center": [
        318,
        425
      ],
      "width": 428,
      "height": 662,
      "extractedText": "for (inti =0;i <n; i+) { printf \"odd sin\", i + 1, fleSizesfi], allocated[i] ? \"Yes\" : \"Nof); ’ } void indexedAllocation(int fileSizes[), int n) { int index(n]; printf(\"nindexed Allocation'n’); printf(\"File No tFile Size'tIndex Block\\n\"); for (inti = 0; <n; 1+) { index[i) =i * 5; // Example index block position printf \"od dod”, i + 1, fileSizes(i). index(i]); ’ } int main() { int; printf(\"Enter the number of files: \"); scanfi\"%d\", &n); int fileSizes[n); printf(\"Enter the sizes of the files: \"); for (inti = 0; <m; i+) { seanf(\"%%d\", &fleSizes(il); ’ int blockSize; printf(\"Enter the total size of the disk block: ); scanfi\"Vd\", &eblockSize); sequentialAllocation(fileSizes, n, blockSize); indexedAllocation(fileSizes, n); retum 0; }",
      "reading_order": 1,
      "pageNumber": 16,
      "sourceImagePath": "temp_images\\page-16.png",
      "annotatedImagePath": "output\\annotated_frames\\page_16_annotated.png",
      "pageWidth": 792,
      "pageHeight": 1024
    },
    {
      "id": "page17_detection1",
      "bbox": [
        111,
        95,
        169,
        112
      ],
      "bbox_normalized": [
        0.1402,
        0.0928,
        0.2134,
        0.1094
      ],
      "label": "Section-header",
      "confidence": 0.738,
      "area": 986,
      "center": [
        140,
        104
      ],
      "width": 58,
      "height": 17,
      "extractedText": "Output:",
      "reading_order": 1,
      "pageNumber": 17,
      "sourceImagePath": "temp_images\\page-17.png",
      "annotatedImagePath": "output\\annotated_frames\\page_17_annotated.png",
      "pageWidth": 792,
      "pageHeight": 1024
    },
    {
      "id": "page17_detection2",
      "bbox": [
        111,
        144,
        674,
        444
      ],
      "bbox_normalized": [
        0.1402,
        0.1406,
        0.851,
        0.4336
      ],
      "label": "Text",
      "confidence": 0.595,
      "area": 168900,
      "center": [
        393,
        294
      ],
      "width": 563,
      "height": 300,
      "extractedText": "Cl a: Vemang\\n) AlN Nos } Enter the number of files: 3 enter the sizes of the files: 50 100 150 enter the total size of the disk block: 300 Sequential Allocation File No. File Size Allocated 1 so Yes 2 100 Yes 3 150 Yes Indexed Allocation File No. File size Index Block 1 0 0 2 100 5 3 150 10 PS D:\\Hemang\\hj AIMS\\voice-segregation\\smart Farm\\smart-farm> |",
      "reading_order": 2,
      "pageNumber": 17,
      "sourceImagePath": "temp_images\\page-17.png",
      "annotatedImagePath": "output\\annotated_frames\\page_17_annotated.png",
      "pageWidth": 792,
      "pageHeight": 1024
    },
    {
      "id": "page18_detection10",
      "bbox": [
        333,
        94,
        452,
        116
      ],
      "bbox_normalized": [
        0.4205,
        0.0918,
        0.5707,
        0.1133
      ],
      "label": "Section-header",
      "confidence": 0.656,
      "area": 2618,
      "center": [
        393,
        105
      ],
      "width": 119,
      "height": 22,
      "extractedText": "Experiment - 5",
      "reading_order": 1,
      "pageNumber": 18,
      "sourceImagePath": "temp_images\\page-18.png",
      "annotatedImagePath": "output\\annotated_frames\\page_18_annotated.png",
      "pageWidth": 792,
      "pageHeight": 1024
    },
    {
      "id": "page18_detection2",
      "bbox": [
        104,
        140,
        674,
        183
      ],
      "bbox_normalized": [
        0.1313,
        0.1367,
        0.851,
        0.1787
      ],
      "label": "Text",
      "confidence": 0.958,
      "area": 24510,
      "center": [
        389,
        162
      ],
      "width": 570,
      "height": 43,
      "extractedText": "Aim: Write a C program to simulate Banker's algorithm for the purpose of Deadlock avoidance.",
      "reading_order": 2,
      "pageNumber": 18,
      "sourceImagePath": "temp_images\\page-18.png",
      "annotatedImagePath": "output\\annotated_frames\\page_18_annotated.png",
      "pageWidth": 792,
      "pageHeight": 1024
    },
    {
      "id": "page18_detection6",
      "bbox": [
        105,
        211,
        188,
        230
      ],
      "bbox_normalized": [
        0.1326,
        0.2061,
        0.2374,
        0.2246
      ],
      "label": "Section-header",
      "confidence": 0.837,
      "area": 1577,
      "center": [
        147,
        221
      ],
      "width": 83,
      "height": 19,
      "extractedText": "Description:",
      "reading_order": 3,
      "pageNumber": 18,
      "sourceImagePath": "temp_images\\page-18.png",
      "annotatedImagePath": "output\\annotated_frames\\page_18_annotated.png",
      "pageWidth": 792,
      "pageHeight": 1024
    },
    {
      "id": "page18_detection1",
      "bbox": [
        104,
        238,
        683,
        364
      ],
      "bbox_normalized": [
        0.1313,
        0.2324,
        0.8624,
        0.3555
      ],
      "label": "Text",
      "confidence": 0.967,
      "area": 72954,
      "center": [
        394,
        301
      ],
      "width": 579,
      "height": 126,
      "extractedText": "The Banker's algorithm works by simulating the allocation of resources to processes based on their maximum needs and current availability. Each process must declare its maximum resource needs in advance. When a process requests resources, the system checks if granting that request would leave the system in a safe state. Ifthe request can be granted while keeping the system ina safe state, the resources are allocated; otherwise, the process must wait. The algorithm effectively prevents deadlock by ensuring that resource allocation always leads to a safe sequence of execution for the processes.",
      "reading_order": 4,
      "pageNumber": 18,
      "sourceImagePath": "temp_images\\page-18.png",
      "annotatedImagePath": "output\\annotated_frames\\page_18_annotated.png",
      "pageWidth": 792,
      "pageHeight": 1024
    },
    {
      "id": "page18_detection8",
      "bbox": [
        105,
        391,
        162,
        409
      ],
      "bbox_normalized": [
        0.1326,
        0.3818,
        0.2045,
        0.3994
      ],
      "label": "Section-header",
      "confidence": 0.749,
      "area": 1026,
      "center": [
        134,
        400
      ],
      "width": 57,
      "height": 18,
      "extractedText": "Theory:",
      "reading_order": 5,
      "pageNumber": 18,
      "sourceImagePath": "temp_images\\page-18.png",
      "annotatedImagePath": "output\\annotated_frames\\page_18_annotated.png",
      "pageWidth": 792,
      "pageHeight": 1024
    },
    {
      "id": "page18_detection5",
      "bbox": [
        105,
        423,
        660,
        461
      ],
      "bbox_normalized": [
        0.1326,
        0.4131,
        0.8333,
        0.4502
      ],
      "label": "Text",
      "confidence": 0.859,
      "area": 21090,
      "center": [
        383,
        442
      ],
      "width": 555,
      "height": 38,
      "extractedText": "| Deadlock: A situation in which two or more processes are unable to proceed because each is waiting for the other to release resources.",
      "reading_order": 6,
      "pageNumber": 18,
      "sourceImagePath": "temp_images\\page-18.png",
      "annotatedImagePath": "output\\annotated_frames\\page_18_annotated.png",
      "pageWidth": 792,
      "pageHeight": 1024
    },
    {
      "id": "page18_detection7",
      "bbox": [
        105,
        460,
        637,
        497
      ],
      "bbox_normalized": [
        0.1326,
        0.4492,
        0.8043,
        0.4854
      ],
      "label": "Text",
      "confidence": 0.798,
      "area": 19684,
      "center": [
        371,
        479
      ],
      "width": 532,
      "height": 37,
      "extractedText": "71 Safe State: A condition where the system can allocate resources to processes in a manner that guarantees all processes can complete without causing deadlock.",
      "reading_order": 7,
      "pageNumber": 18,
      "sourceImagePath": "temp_images\\page-18.png",
      "annotatedImagePath": "output\\annotated_frames\\page_18_annotated.png",
      "pageWidth": 792,
      "pageHeight": 1024
    },
    {
      "id": "page18_detection3",
      "bbox": [
        105,
        500,
        675,
        555
      ],
      "bbox_normalized": [
        0.1326,
        0.4883,
        0.8523,
        0.542
      ],
      "label": "Text",
      "confidence": 0.938,
      "area": 31350,
      "center": [
        390,
        528
      ],
      "width": 570,
      "height": 55,
      "extractedText": "I Resource Allocation: The process of assigning available resources to various processes in a system. The Banker's algorithm simulates this allocation while ensuring the system remains in a safe state.",
      "reading_order": 8,
      "pageNumber": 18,
      "sourceImagePath": "temp_images\\page-18.png",
      "annotatedImagePath": "output\\annotated_frames\\page_18_annotated.png",
      "pageWidth": 792,
      "pageHeight": 1024
    },
    {
      "id": "page18_detection9",
      "bbox": [
        105,
        600,
        207,
        616
      ],
      "bbox_normalized": [
        0.1326,
        0.5859,
        0.2614,
        0.6016
      ],
      "label": "Text",
      "confidence": 0.661,
      "area": 1632,
      "center": [
        156,
        608
      ],
      "width": 102,
      "height": 16,
      "extractedText": "#include <stdio.h>",
      "reading_order": 9,
      "pageNumber": 18,
      "sourceImagePath": "temp_images\\page-18.png",
      "annotatedImagePath": "output\\annotated_frames\\page_18_annotated.png",
      "pageWidth": 792,
      "pageHeight": 1024
    },
    {
      "id": "page18_detection4",
      "bbox": [
        107,
        636,
        421,
        1005
      ],
      "bbox_normalized": [
        0.1351,
        0.6211,
        0.5316,
        0.9814
      ],
      "label": "Text",
      "confidence": 0.864,
      "area": 115866,
      "center": [
        264,
        821
      ],
      "width": 314,
      "height": 369,
      "extractedText": "nt main() { into, mij; printf(\" Enter number of processes: \"); scanf{\"%d\", &n); printf(\" Enter number of resources: ); seanf{\"%d\", &em); int max{n]fm), allotfn)[m), need[o])[m], avail[m]; printf(\"Enter maximum resources for each process in\") for (i=0:i <n; #4) { printf \"Process %d: \"i + 1); for (j= 0: < mij) | scanfi \"Vd\", &max[i][j]): ’ ’ printf(\"Enter allocated resources for each process-n\"); for (1-0: <n; #4) { printf \"Process %d: *, i + 1);",
      "reading_order": 10,
      "pageNumber": 18,
      "sourceImagePath": "temp_images\\page-18.png",
      "annotatedImagePath": "output\\annotated_frames\\page_18_annotated.png",
      "pageWidth": 792,
      "pageHeight": 1024
    },
    {
      "id": "page19_detection1",
      "bbox": [
        117,
        93,
        417,
        996
      ],
      "bbox_normalized": [
        0.1477,
        0.0908,
        0.5265,
        0.9727
      ],
      "label": "Text",
      "confidence": 0.935,
      "area": 270900,
      "center": [
        267,
        545
      ],
      "width": 300,
      "height": 903,
      "extractedText": "for (j= 0: <m; j++) { scanfl\"%%d\", &allot[il[il ’ } printf(\" Enter available resources: a\"); for = 0: < mj) { scanf{(\"%d\", &avail[j]); } for (i= 0: < m i++) { for (j= 0: =m; j++) { need(ilfj) = max(il(] - allo); ’ } int finish{n], safeSeq[n], index = 0; for (i=0:i< m i++) { finish[i] = 0; } while (index <n) { int found = 0; for (i= 0: <m; +4) { if (finish[i] == 0) { intj; for (= 0: <m: j++) { if (meed(iJfj] > avail[]) { break: ’ ’ iff =m){ for (= 0;j<m; j++) { avail] += alloti[j: b safeSeqfindex++] =i; fnish[i] = 1; found = 1; ’ ’ ’ if (found == 0) { printf(\"System is not in 2 safe state in”); rem 0; ’ } printf{\"System is in a safe state \\nSafe sequence is: \"); for (i=0;i< mn i++) {",
      "reading_order": 1,
      "pageNumber": 19,
      "sourceImagePath": "temp_images\\page-19.png",
      "annotatedImagePath": "output\\annotated_frames\\page_19_annotated.png",
      "pageWidth": 792,
      "pageHeight": 1024
    },
    {
      "id": "page20_detection2",
      "bbox": [
        104,
        96,
        292,
        203
      ],
      "bbox_normalized": [
        0.1313,
        0.0938,
        0.3687,
        0.1982
      ],
      "label": "Text",
      "confidence": 0.926,
      "area": 20116,
      "center": [
        198,
        150
      ],
      "width": 188,
      "height": 107,
      "extractedText": "prantfi™d \", safeSeq[i] + 1); ’ printf(\"n\"); retum 0; }",
      "reading_order": 1,
      "pageNumber": 20,
      "sourceImagePath": "temp_images\\page-20.png",
      "annotatedImagePath": "output\\annotated_frames\\page_20_annotated.png",
      "pageWidth": 792,
      "pageHeight": 1024
    },
    {
      "id": "page20_detection3",
      "bbox": [
        105,
        222,
        159,
        238
      ],
      "bbox_normalized": [
        0.1326,
        0.2168,
        0.2008,
        0.2324
      ],
      "label": "Section-header",
      "confidence": 0.577,
      "area": 864,
      "center": [
        132,
        230
      ],
      "width": 54,
      "height": 16,
      "extractedText": "Output:",
      "reading_order": 2,
      "pageNumber": 20,
      "sourceImagePath": "temp_images\\page-20.png",
      "annotatedImagePath": "output\\annotated_frames\\page_20_annotated.png",
      "pageWidth": 792,
      "pageHeight": 1024
    },
    {
      "id": "page20_detection1",
      "bbox": [
        106,
        241,
        679,
        583
      ],
      "bbox_normalized": [
        0.1338,
        0.2354,
        0.8573,
        0.5693
      ],
      "label": "Text",
      "confidence": 0.929,
      "area": 195966,
      "center": [
        393,
        412
      ],
      "width": 573,
      "height": 342,
      "extractedText": "PS D:\\Hemang\\h) AIMS\\voice-segregation\\Smart Farm\\smart-farm> cd ~d:\\Hemang\\hj AIMSAv SS } Enter number of processes: 5 Enter number of resources: 3 Enter maximm resources for each process: Process 1: 4.3 2 Process 2: 12 2 Process 3: 5 0 2 Process 4: 22 2 Process 5: 2 3 3 enter allocated resources for each process: Process 1: © 10 Process 2: 20 Process 3: 30 2 Process 4: 211 Process 5: 00 2 Enter available resources: 342 system is in a safe state. safe sequence is: 23451 PS D:\\Hemang\\hj AIMS\\voice-segregation\\smart Farm\\smart-farm> [|",
      "reading_order": 3,
      "pageNumber": 20,
      "sourceImagePath": "temp_images\\page-20.png",
      "annotatedImagePath": "output\\annotated_frames\\page_20_annotated.png",
      "pageWidth": 792,
      "pageHeight": 1024
    },
    {
      "id": "page21_detection7",
      "bbox": [
        309,
        95,
        421,
        114
      ],
      "bbox_normalized": [
        0.4262,
        0.0928,
        0.5807,
        0.1113
      ],
      "label": "Section-header",
      "confidence": 0.761,
      "area": 2128,
      "center": [
        365,
        105
      ],
      "width": 112,
      "height": 19,
      "extractedText": "Experiment - 6",
      "reading_order": 1,
      "pageNumber": 21,
      "sourceImagePath": "temp_images\\page-21.png",
      "annotatedImagePath": "output\\annotated_frames\\page_21_annotated.png",
      "pageWidth": 725,
      "pageHeight": 1024
    },
    {
      "id": "page21_detection8",
      "bbox": [
        82,
        156,
        642,
        171
      ],
      "bbox_normalized": [
        0.1131,
        0.1523,
        0.8855,
        0.167
      ],
      "label": "Text",
      "confidence": 0.758,
      "area": 8400,
      "center": [
        362,
        164
      ],
      "width": 560,
      "height": 15,
      "extractedText": "Aim: Write a C program to simulate Banker's algorithm for the purpose of Deadlock prevention",
      "reading_order": 2,
      "pageNumber": 21,
      "sourceImagePath": "temp_images\\page-21.png",
      "annotatedImagePath": "output\\annotated_frames\\page_21_annotated.png",
      "pageWidth": 725,
      "pageHeight": 1024
    },
    {
      "id": "page21_detection6",
      "bbox": [
        81,
        199,
        166,
        217
      ],
      "bbox_normalized": [
        0.1117,
        0.1943,
        0.229,
        0.2119
      ],
      "label": "Section-header",
      "confidence": 0.843,
      "area": 1530,
      "center": [
        124,
        208
      ],
      "width": 85,
      "height": 18,
      "extractedText": "Description:",
      "reading_order": 3,
      "pageNumber": 21,
      "sourceImagePath": "temp_images\\page-21.png",
      "annotatedImagePath": "output\\annotated_frames\\page_21_annotated.png",
      "pageWidth": 725,
      "pageHeight": 1024
    },
    {
      "id": "page21_detection1",
      "bbox": [
        81,
        219,
        642,
        365
      ],
      "bbox_normalized": [
        0.1117,
        0.2139,
        0.8855,
        0.3564
      ],
      "label": "Text",
      "confidence": 0.979,
      "area": 81906,
      "center": [
        362,
        292
      ],
      "width": 561,
      "height": 146,
      "extractedText": "The Banker's al gorithm operates by managing resource allocation based on the maximum needs of processes and the currently available resources. When a process requests resources, the algorithm checks whether granting the request would keep the system in a safe state. This is done by simulating the allocation and detemining if all processes can finish with the available resources. If the request can be safely granted, the resources are allocated; otherwise, the process must wait. This method prevents deadlock by ensuring that the system always has a valid sequence of resource allocations that allows all processes to complete.",
      "reading_order": 4,
      "pageNumber": 21,
      "sourceImagePath": "temp_images\\page-21.png",
      "annotatedImagePath": "output\\annotated_frames\\page_21_annotated.png",
      "pageWidth": 725,
      "pageHeight": 1024
    },
    {
      "id": "page21_detection5",
      "bbox": [
        81,
        392,
        139,
        409
      ],
      "bbox_normalized": [
        0.1117,
        0.3828,
        0.1917,
        0.3994
      ],
      "label": "Section-header",
      "confidence": 0.863,
      "area": 986,
      "center": [
        110,
        401
      ],
      "width": 58,
      "height": 17,
      "extractedText": "Theory:",
      "reading_order": 5,
      "pageNumber": 21,
      "sourceImagePath": "temp_images\\page-21.png",
      "annotatedImagePath": "output\\annotated_frames\\page_21_annotated.png",
      "pageWidth": 725,
      "pageHeight": 1024
    },
    {
      "id": "page21_detection3",
      "bbox": [
        82,
        411,
        642,
        448
      ],
      "bbox_normalized": [
        0.1131,
        0.4014,
        0.8855,
        0.4375
      ],
      "label": "Text",
      "confidence": 0.926,
      "area": 20720,
      "center": [
        362,
        430
      ],
      "width": 560,
      "height": 37,
      "extractedText": "1 Deadlock: A situation where two or more processes cannot proceed because each 1s waiting for the other to release resources.",
      "reading_order": 6,
      "pageNumber": 21,
      "sourceImagePath": "temp_images\\page-21.png",
      "annotatedImagePath": "output\\annotated_frames\\page_21_annotated.png",
      "pageWidth": 725,
      "pageHeight": 1024
    },
    {
      "id": "page21_detection4",
      "bbox": [
        80,
        454,
        641,
        492
      ],
      "bbox_normalized": [
        0.1103,
        0.4434,
        0.8841,
        0.4805
      ],
      "label": "Text",
      "confidence": 0.897,
      "area": 21318,
      "center": [
        361,
        473
      ],
      "width": 561,
      "height": 38,
      "extractedText": "II\" Safe State: A condition where resource allocation to processes is such that the system can guarantee that all processes will complete without entering a deadlock.",
      "reading_order": 7,
      "pageNumber": 21,
      "sourceImagePath": "temp_images\\page-21.png",
      "annotatedImagePath": "output\\annotated_frames\\page_21_annotated.png",
      "pageWidth": 725,
      "pageHeight": 1024
    },
    {
      "id": "page21_detection2",
      "bbox": [
        80,
        497,
        642,
        557
      ],
      "bbox_normalized": [
        0.1103,
        0.4854,
        0.8855,
        0.5439
      ],
      "label": "Text",
      "confidence": 0.931,
      "area": 33720,
      "center": [
        361,
        527
      ],
      "width": 562,
      "height": 60,
      "extractedText": "0 Resource Allocation: The act of distributing available resources to processes. The Banker's algorithm prevents deadlock by ensuring that resources are allocated in a way that maintains a safe state.",
      "reading_order": 8,
      "pageNumber": 21,
      "sourceImagePath": "temp_images\\page-21.png",
      "annotatedImagePath": "output\\annotated_frames\\page_21_annotated.png",
      "pageWidth": 725,
      "pageHeight": 1024
    },
    {
      "id": "page21_detection11",
      "bbox": [
        86,
        582,
        128,
        603
      ],
      "bbox_normalized": [
        0.1186,
        0.5684,
        0.1766,
        0.5889
      ],
      "label": "Section-header",
      "confidence": 0.671,
      "area": 882,
      "center": [
        107,
        593
      ],
      "width": 42,
      "height": 21,
      "extractedText": "Code:",
      "reading_order": 9,
      "pageNumber": 21,
      "sourceImagePath": "temp_images\\page-21.png",
      "annotatedImagePath": "output\\annotated_frames\\page_21_annotated.png",
      "pageWidth": 725,
      "pageHeight": 1024
    },
    {
      "id": "page21_detection10",
      "bbox": [
        82,
        603,
        176,
        620
      ],
      "bbox_normalized": [
        0.1131,
        0.5889,
        0.2428,
        0.6055
      ],
      "label": "Text",
      "confidence": 0.695,
      "area": 1598,
      "center": [
        129,
        612
      ],
      "width": 94,
      "height": 17,
      "extractedText": "#include <stdio.h>",
      "reading_order": 10,
      "pageNumber": 21,
      "sourceImagePath": "temp_images\\page-21.png",
      "annotatedImagePath": "output\\annotated_frames\\page_21_annotated.png",
      "pageWidth": 725,
      "pageHeight": 1024
    },
    {
      "id": "page21_detection9",
      "bbox": [
        85,
        630,
        378,
        1002
      ],
      "bbox_normalized": [
        0.1172,
        0.6152,
        0.5214,
        0.9785
      ],
      "label": "Text",
      "confidence": 0.698,
      "area": 108996,
      "center": [
        232,
        816
      ],
      "width": 293,
      "height": 372,
      "extractedText": "ot main) { intn, mij: printf(\"Enter number of processes: ); scanf(\" Yd\", &n): printf(\"Enter number of resources: \"): scanf(\" id\", &m); int max(n]{m], alloin]fm), need[n][m], avail[m}: printf(\"Enter maximum resources for each process-in\"): for(i=0:i<n; i+) { printf \"Process %d: i + 1) for (=0:j< m+) | scanf(\"%d\", &emax(i][]). ) ) printf(\"Enter allocated resources for each process:in'): for(i=0:i< ni) { printf \"Process %d: i + 1) for (= 0; < mej) {",
      "reading_order": 11,
      "pageNumber": 21,
      "sourceImagePath": "temp_images\\page-21.png",
      "annotatedImagePath": "output\\annotated_frames\\page_21_annotated.png",
      "pageWidth": 725,
      "pageHeight": 1024
    },
    {
      "id": "page22_detection1",
      "bbox": [
        90,
        95,
        371,
        979
      ],
      "bbox_normalized": [
        0.1241,
        0.0928,
        0.5117,
        0.9561
      ],
      "label": "Text",
      "confidence": 0.926,
      "area": 248404,
      "center": [
        231,
        537
      ],
      "width": 281,
      "height": 884,
      "extractedText": "scanfi\"%d\", &allot[i][j]); ) ) printf(\"Enter available resources:in\"); for (= 0: < mi ++) { scanf(\"%dt, &avail]): ) for(i=0ri< min) | for G=05< mij) | need] = max(il[] - alot: ) ) int finish], safeSecfn]. index = 0: for(i= 05m iv) { finish] = 0: ) while (index <n) { int found = 0; for (1=0;i< m i++) { if (finish{i] = 0) { ints for 1-0: <mi ji) | (nec) > avail] break: ) ) if(G==m) { for(1= 0: <mi jo) avail] += allo: ) safeSeqfindex+] =i: finish] = 1: found= 1; ) ) ) if (found = 0) { print\" System is not in a safe state in\"); rem; ) ) printf(\"System is in a safe state InSafe sequence is: \"); for(i=0ri< mir) | printf\". safeSeafi] + 1): ) printf(\"in\");",
      "reading_order": 1,
      "pageNumber": 22,
      "sourceImagePath": "temp_images\\page-22.png",
      "annotatedImagePath": "output\\annotated_frames\\page_22_annotated.png",
      "pageWidth": 725,
      "pageHeight": 1024
    },
    {
      "id": "page23_detection1",
      "bbox": [
        97,
        185,
        679,
        516
      ],
      "bbox_normalized": [
        0.1338,
        0.1807,
        0.9366,
        0.5039
      ],
      "label": "Text",
      "confidence": 0.875,
      "area": 192642,
      "center": [
        388,
        351
      ],
      "width": 582,
      "height": 331,
      "extractedText": "PS D:\\Hemang\\hj AIMS\\voice-segregation\\Smart Farm\\smart-farm> cd ~d:iHemanging AIFS \\0s-6 } Enter nusber of processes: 5 Enter number of resources: 3 Enter maximum resources for each process: Process 1: 25 3 Process 2: 32 2 Process 3: 4.0 2 Process 4: 22 2 Process 5: 3 3 3 Enter allocated resources for each process: Process 1: 0.10 Process 2: 20 0 Process 3: 30 2 Process 4: 211 Process 5: 0 0 4 Enter available resources: 231 System is in a safe state. safe sequence is: 34512 N",
      "reading_order": 1,
      "pageNumber": 23,
      "sourceImagePath": "temp_images\\page-23.png",
      "annotatedImagePath": "output\\annotated_frames\\page_23_annotated.png",
      "pageWidth": 725,
      "pageHeight": 1024
    },
    {
      "id": "page24_detection10",
      "bbox": [
        297,
        92,
        412,
        113
      ],
      "bbox_normalized": [
        0.4097,
        0.0898,
        0.5683,
        0.1104
      ],
      "label": "Section-header",
      "confidence": 0.742,
      "area": 2415,
      "center": [
        355,
        103
      ],
      "width": 115,
      "height": 21,
      "extractedText": "Experiment — 7",
      "reading_order": 1,
      "pageNumber": 24,
      "sourceImagePath": "temp_images\\page-24.png",
      "annotatedImagePath": "output\\annotated_frames\\page_24_annotated.png",
      "pageWidth": 725,
      "pageHeight": 1024
    },
    {
      "id": "page24_detection8",
      "bbox": [
        83,
        146,
        467,
        163
      ],
      "bbox_normalized": [
        0.1145,
        0.1426,
        0.6441,
        0.1592
      ],
      "label": "Text",
      "confidence": 0.84,
      "area": 6528,
      "center": [
        275,
        155
      ],
      "width": 384,
      "height": 17,
      "extractedText": "Aim: Write a C program to simulate page replacement algorithm a) FIE",
      "reading_order": 2,
      "pageNumber": 24,
      "sourceImagePath": "temp_images\\page-24.png",
      "annotatedImagePath": "output\\annotated_frames\\page_24_annotated.png",
      "pageWidth": 725,
      "pageHeight": 1024
    },
    {
      "id": "page24_detection7",
      "bbox": [
        81,
        177,
        162,
        197
      ],
      "bbox_normalized": [
        0.1117,
        0.1729,
        0.2234,
        0.1924
      ],
      "label": "Section-header",
      "confidence": 0.874,
      "area": 1620,
      "center": [
        122,
        187
      ],
      "width": 81,
      "height": 20,
      "extractedText": "Description",
      "reading_order": 3,
      "pageNumber": 24,
      "sourceImagePath": "temp_images\\page-24.png",
      "annotatedImagePath": "output\\annotated_frames\\page_24_annotated.png",
      "pageWidth": 725,
      "pageHeight": 1024
    },
    {
      "id": "page24_detection1",
      "bbox": [
        81,
        209,
        645,
        257
      ],
      "bbox_normalized": [
        0.1117,
        0.2041,
        0.8897,
        0.251
      ],
      "label": "Text",
      "confidence": 0.979,
      "area": 27072,
      "center": [
        363,
        233
      ],
      "width": 564,
      "height": 48,
      "extractedText": "Page replacement algorithms are used when a program accesses more pages than can fit in memory. The algorithm needs to decide which page to replace when the memory is full. FIFO and LRU are two popular page replacement strategies:",
      "reading_order": 4,
      "pageNumber": 24,
      "sourceImagePath": "temp_images\\page-24.png",
      "annotatedImagePath": "output\\annotated_frames\\page_24_annotated.png",
      "pageWidth": 725,
      "pageHeight": 1024
    },
    {
      "id": "page24_detection2",
      "bbox": [
        103,
        273,
        651,
        305
      ],
      "bbox_normalized": [
        0.1421,
        0.2666,
        0.8979,
        0.2979
      ],
      "label": "List-item",
      "confidence": 0.97,
      "area": 17536,
      "center": [
        377,
        289
      ],
      "width": 548,
      "height": 32,
      "extractedText": "+ FIFO (First-In-First-Out): In FIFO, the oldest page in memory (the one that was loaded first) is replaced when a new page needs to be loaded,",
      "reading_order": 5,
      "pageNumber": 24,
      "sourceImagePath": "temp_images\\page-24.png",
      "annotatedImagePath": "output\\annotated_frames\\page_24_annotated.png",
      "pageWidth": 725,
      "pageHeight": 1024
    },
    {
      "id": "page24_detection3",
      "bbox": [
        103,
        304,
        628,
        336
      ],
      "bbox_normalized": [
        0.1421,
        0.2969,
        0.8662,
        0.3281
      ],
      "label": "List-item",
      "confidence": 0.97,
      "area": 16800,
      "center": [
        366,
        320
      ],
      "width": 525,
      "height": 32,
      "extractedText": "* LRU (Least Recently Used): In LRU, the page that has not been used for the longest time is replaced when a new page needs to be loaded,",
      "reading_order": 6,
      "pageNumber": 24,
      "sourceImagePath": "temp_images\\page-24.png",
      "annotatedImagePath": "output\\annotated_frames\\page_24_annotated.png",
      "pageWidth": 725,
      "pageHeight": 1024
    },
    {
      "id": "page24_detection9",
      "bbox": [
        80,
        352,
        127,
        372
      ],
      "bbox_normalized": [
        0.1103,
        0.3438,
        0.1752,
        0.3633
      ],
      "label": "Section-header",
      "confidence": 0.775,
      "area": 940,
      "center": [
        104,
        362
      ],
      "width": 47,
      "height": 20,
      "extractedText": "Theor",
      "reading_order": 7,
      "pageNumber": 24,
      "sourceImagePath": "temp_images\\page-24.png",
      "annotatedImagePath": "output\\annotated_frames\\page_24_annotated.png",
      "pageWidth": 725,
      "pageHeight": 1024
    },
    {
      "id": "page24_detection6",
      "bbox": [
        81,
        401,
        650,
        449
      ],
      "bbox_normalized": [
        0.1117,
        0.3916,
        0.8966,
        0.4385
      ],
      "label": "Text",
      "confidence": 0.919,
      "area": 27312,
      "center": [
        366,
        425
      ],
      "width": 569,
      "height": 48,
      "extractedText": "M1 FIFO (First-In-First-Out): FIFO is a simple page replacement algorithm. It keeps track of the pages in memory in the order they were loaded. When a new page needs to be loaded into memory and memory is full, it replaces the page that has been in memory the longest",
      "reading_order": 8,
      "pageNumber": 24,
      "sourceImagePath": "temp_images\\page-24.png",
      "annotatedImagePath": "output\\annotated_frames\\page_24_annotated.png",
      "pageWidth": 725,
      "pageHeight": 1024
    },
    {
      "id": "page24_detection4",
      "bbox": [
        81,
        465,
        647,
        513
      ],
      "bbox_normalized": [
        0.1117,
        0.4541,
        0.8924,
        0.501
      ],
      "label": "Text",
      "confidence": 0.968,
      "area": 27168,
      "center": [
        364,
        489
      ],
      "width": 566,
      "height": 48,
      "extractedText": "\" LRU (Least Recently Used): LRU replaces the page that has not been used for the longest time. It keeps track of the access history of the pages and selects the least recently accessed page for replacement when needed.",
      "reading_order": 9,
      "pageNumber": 24,
      "sourceImagePath": "temp_images\\page-24.png",
      "annotatedImagePath": "output\\annotated_frames\\page_24_annotated.png",
      "pageWidth": 725,
      "pageHeight": 1024
    },
    {
      "id": "page24_detection11",
      "bbox": [
        81,
        552,
        112,
        574
      ],
      "bbox_normalized": [
        0.1117,
        0.5391,
        0.1545,
        0.5605
      ],
      "label": "Section-header",
      "confidence": 0.689,
      "area": 682,
      "center": [
        97,
        563
      ],
      "width": 31,
      "height": 22,
      "extractedText": "Cod",
      "reading_order": 10,
      "pageNumber": 24,
      "sourceImagePath": "temp_images\\page-24.png",
      "annotatedImagePath": "output\\annotated_frames\\page_24_annotated.png",
      "pageWidth": 725,
      "pageHeight": 1024
    },
    {
      "id": "page24_detection12",
      "bbox": [
        81,
        575,
        93,
        592
      ],
      "bbox_normalized": [
        0.1117,
        0.5615,
        0.1283,
        0.5781
      ],
      "label": "Section-header",
      "confidence": 0.556,
      "area": 204,
      "center": [
        87,
        584
      ],
      "width": 12,
      "height": 17,
      "extractedText": "e:",
      "reading_order": 11,
      "pageNumber": 24,
      "sourceImagePath": "temp_images\\page-24.png",
      "annotatedImagePath": "output\\annotated_frames\\page_24_annotated.png",
      "pageWidth": 725,
      "pageHeight": 1024
    },
    {
      "id": "page24_detection5",
      "bbox": [
        80,
        607,
        386,
        1001
      ],
      "bbox_normalized": [
        0.1103,
        0.5928,
        0.5324,
        0.9775
      ],
      "label": "Text",
      "confidence": 0.963,
      "area": 120564,
      "center": [
        233,
        804
      ],
      "width": 306,
      "height": 394,
      "extractedText": "incline <sidio.&> void fifoPageReplacementint pages). intr nt capaci) | int pageFauts = 0: int framelcapacin int count = 0; for inti =0: = capaci: i++) rameli] 15 for (inti = 0; <n; iH) | int flag = 0: for inj =0:) < capaci: j++) { if (@ramelj) = pages() { flag: break; i i if(flag=0) { framefcount] = pages(: count = (count + 1) Yocapacin; pageFalis +; i i printf(’FIFO Page Faults: din’. pageFauls): }",
      "reading_order": 12,
      "pageNumber": 24,
      "sourceImagePath": "temp_images\\page-24.png",
      "annotatedImagePath": "output\\annotated_frames\\page_24_annotated.png",
      "pageWidth": 725,
      "pageHeight": 1024
    },
    {
      "id": "page25_detection1",
      "bbox": [
        80,
        116,
        386,
        800
      ],
      "bbox_normalized": [
        0.1103,
        0.1133,
        0.5324,
        0.7813
      ],
      "label": "Text",
      "confidence": 0.945,
      "area": 209304,
      "center": [
        233,
        458
      ],
      "width": 306,
      "height": 684,
      "extractedText": "void frufageleplacement{int pages|], mtn, mt capaciiy) | int pageFaults = 0: int framelcapacin int timelcapuacin: int count = 0; for (inti =0: = capaci: i++) { framefi]=-1: time[i] =I: ) for inti =0ci< i++) { int flag = 0: for in = 0: < capaci: j++) { if @ramelj) = pages() { flag 1: timef] = count bres: ) ) if (flag=0) { inti =0; for (in = 1: < capaci j++) { if imefj] = timefinu) ru =: ) framefira] = pages(ls timeliru] = count pageFauls +; ) count; ) printf(\"LRU Page Faults: %d'n\", pageFaults); } int main) { int pages] = 17.0.1, 2.0,3.0,4.2,3,0,3.25; int n= sizeof{ pages) / sizeof{pages[0]): int capacity = 3: fifoPageReplacementpages, n, capacity): IuPageReplacament (pages, n. capacity): retum 0; ,",
      "reading_order": 1,
      "pageNumber": 25,
      "sourceImagePath": "temp_images\\page-25.png",
      "annotatedImagePath": "output\\annotated_frames\\page_25_annotated.png",
      "pageWidth": 725,
      "pageHeight": 1024
    },
    {
      "id": "page25_detection2",
      "bbox": [
        89,
        863,
        502,
        925
      ],
      "bbox_normalized": [
        0.1228,
        0.8428,
        0.6924,
        0.9033
      ],
      "label": "Text",
      "confidence": 0.893,
      "area": 25606,
      "center": [
        296,
        894
      ],
      "width": 413,
      "height": 62,
      "extractedText": "\\B-7 } FIFO Page Faults: 10 LRU Page Faults: 9 PS D:\\Hemang\\hj AIMS\\voice-segregation\\smart Farm\\smart-farm",
      "reading_order": 2,
      "pageNumber": 25,
      "sourceImagePath": "temp_images\\page-25.png",
      "annotatedImagePath": "output\\annotated_frames\\page_25_annotated.png",
      "pageWidth": 725,
      "pageHeight": 1024
    },
    {
      "id": "page26_detection10",
      "bbox": [
        297,
        92,
        412,
        113
      ],
      "bbox_normalized": [
        0.4097,
        0.0898,
        0.5683,
        0.1104
      ],
      "label": "Section-header",
      "confidence": 0.736,
      "area": 2415,
      "center": [
        355,
        103
      ],
      "width": 115,
      "height": 21,
      "extractedText": "Experiment — 8",
      "reading_order": 1,
      "pageNumber": 26,
      "sourceImagePath": "temp_images\\page-26.png",
      "annotatedImagePath": "output\\annotated_frames\\page_26_annotated.png",
      "pageWidth": 725,
      "pageHeight": 1024
    },
    {
      "id": "page26_detection9",
      "bbox": [
        96,
        147,
        480,
        163
      ],
      "bbox_normalized": [
        0.1324,
        0.1436,
        0.6621,
        0.1592
      ],
      "label": "Text",
      "confidence": 0.748,
      "area": 6144,
      "center": [
        288,
        155
      ],
      "width": 384,
      "height": 16,
      "extractedText": "m: Write a C program to simulate page replacement algorithm a) LFU,",
      "reading_order": 2,
      "pageNumber": 26,
      "sourceImagePath": "temp_images\\page-26.png",
      "annotatedImagePath": "output\\annotated_frames\\page_26_annotated.png",
      "pageWidth": 725,
      "pageHeight": 1024
    },
    {
      "id": "page26_detection7",
      "bbox": [
        81,
        177,
        167,
        197
      ],
      "bbox_normalized": [
        0.1117,
        0.1729,
        0.2303,
        0.1924
      ],
      "label": "Section-header",
      "confidence": 0.809,
      "area": 1720,
      "center": [
        124,
        187
      ],
      "width": 86,
      "height": 20,
      "extractedText": "Description:",
      "reading_order": 3,
      "pageNumber": 26,
      "sourceImagePath": "temp_images\\page-26.png",
      "annotatedImagePath": "output\\annotated_frames\\page_26_annotated.png",
      "pageWidth": 725,
      "pageHeight": 1024
    },
    {
      "id": "page26_detection5",
      "bbox": [
        80,
        208,
        643,
        244
      ],
      "bbox_normalized": [
        0.1103,
        0.2031,
        0.8869,
        0.2383
      ],
      "label": "Text",
      "confidence": 0.955,
      "area": 20268,
      "center": [
        362,
        226
      ],
      "width": 563,
      "height": 36,
      "extractedText": "Page replacement algorithms are used when a program requires more memory than is available. In such cases, pages are replaced based on certain strategies:",
      "reading_order": 4,
      "pageNumber": 26,
      "sourceImagePath": "temp_images\\page-26.png",
      "annotatedImagePath": "output\\annotated_frames\\page_26_annotated.png",
      "pageWidth": 725,
      "pageHeight": 1024
    },
    {
      "id": "page26_detection2",
      "bbox": [
        103,
        258,
        650,
        310
      ],
      "bbox_normalized": [
        0.1421,
        0.252,
        0.8966,
        0.3027
      ],
      "label": "List-item",
      "confidence": 0.978,
      "area": 28444,
      "center": [
        377,
        284
      ],
      "width": 547,
      "height": 52,
      "extractedText": "+ LFU (Least Frequently Used): The LFU algorithm replaces the page that has been used the least number of times. This means that pages that have not been frequently accessed are replaced first.",
      "reading_order": 5,
      "pageNumber": 26,
      "sourceImagePath": "temp_images\\page-26.png",
      "annotatedImagePath": "output\\annotated_frames\\page_26_annotated.png",
      "pageWidth": 725,
      "pageHeight": 1024
    },
    {
      "id": "page26_detection3",
      "bbox": [
        103,
        309,
        646,
        361
      ],
      "bbox_normalized": [
        0.1421,
        0.3018,
        0.891,
        0.3525
      ],
      "label": "List-item",
      "confidence": 0.974,
      "area": 28236,
      "center": [
        375,
        335
      ],
      "width": 543,
      "height": 52,
      "extractedText": "+ Optimal: The Optimal page replacement algorithm replaces the page that will not be used for the longest period of time in the future. It is theoretically the best algorithm, but it requires knowledge of future page references, which is not possible in real scenarios.",
      "reading_order": 6,
      "pageNumber": 26,
      "sourceImagePath": "temp_images\\page-26.png",
      "annotatedImagePath": "output\\annotated_frames\\page_26_annotated.png",
      "pageWidth": 725,
      "pageHeight": 1024
    },
    {
      "id": "page26_detection12",
      "bbox": [
        81,
        376,
        139,
        396
      ],
      "bbox_normalized": [
        0.1117,
        0.3672,
        0.1917,
        0.3867
      ],
      "label": "Section-header",
      "confidence": 0.676,
      "area": 1160,
      "center": [
        110,
        386
      ],
      "width": 58,
      "height": 20,
      "extractedText": "Theory:",
      "reading_order": 7,
      "pageNumber": 26,
      "sourceImagePath": "temp_images\\page-26.png",
      "annotatedImagePath": "output\\annotated_frames\\page_26_annotated.png",
      "pageWidth": 725,
      "pageHeight": 1024
    },
    {
      "id": "page26_detection1",
      "bbox": [
        103,
        406,
        645,
        476
      ],
      "bbox_normalized": [
        0.1421,
        0.3965,
        0.8897,
        0.4648
      ],
      "label": "List-item",
      "confidence": 0.98,
      "area": 37940,
      "center": [
        374,
        441
      ],
      "width": 542,
      "height": 70,
      "extractedText": "+ LFU (Least Frequently Used): LFU replaces the page with the least frequency of access. The algorithm keeps track of the number of times each page is accessed. When a page fault occurs and a new page must be loaded, the page with the least access count is chosen for replacement.",
      "reading_order": 8,
      "pageNumber": 26,
      "sourceImagePath": "temp_images\\page-26.png",
      "annotatedImagePath": "output\\annotated_frames\\page_26_annotated.png",
      "pageWidth": 725,
      "pageHeight": 1024
    },
    {
      "id": "page26_detection4",
      "bbox": [
        102,
        474,
        639,
        526
      ],
      "bbox_normalized": [
        0.1407,
        0.4629,
        0.8814,
        0.5137
      ],
      "label": "List-item",
      "confidence": 0.968,
      "area": 27924,
      "center": [
        371,
        500
      ],
      "width": 537,
      "height": 52,
      "extractedText": "+ Optimal: The Optimal algorithm is based on future page reference information. It predicts which page will be needed furthest in the future and replaces it. This algorithm is ideal but impractical, as it requires future knowledge.",
      "reading_order": 9,
      "pageNumber": 26,
      "sourceImagePath": "temp_images\\page-26.png",
      "annotatedImagePath": "output\\annotated_frames\\page_26_annotated.png",
      "pageWidth": 725,
      "pageHeight": 1024
    },
    {
      "id": "page26_detection11",
      "bbox": [
        81,
        554,
        124,
        574
      ],
      "bbox_normalized": [
        0.1117,
        0.541,
        0.171,
        0.5605
      ],
      "label": "Section-header",
      "confidence": 0.73,
      "area": 860,
      "center": [
        103,
        564
      ],
      "width": 43,
      "height": 20,
      "extractedText": "Code:",
      "reading_order": 10,
      "pageNumber": 26,
      "sourceImagePath": "temp_images\\page-26.png",
      "annotatedImagePath": "output\\annotated_frames\\page_26_annotated.png",
      "pageWidth": 725,
      "pageHeight": 1024
    },
    {
      "id": "page26_detection8",
      "bbox": [
        81,
        588,
        179,
        604
      ],
      "bbox_normalized": [
        0.1117,
        0.5742,
        0.2469,
        0.5898
      ],
      "label": "Text",
      "confidence": 0.76,
      "area": 1568,
      "center": [
        130,
        596
      ],
      "width": 98,
      "height": 16,
      "extractedText": "#include <stdio.h>",
      "reading_order": 11,
      "pageNumber": 26,
      "sourceImagePath": "temp_images\\page-26.png",
      "annotatedImagePath": "output\\annotated_frames\\page_26_annotated.png",
      "pageWidth": 725,
      "pageHeight": 1024
    },
    {
      "id": "page26_detection6",
      "bbox": [
        83,
        621,
        383,
        1003
      ],
      "bbox_normalized": [
        0.1145,
        0.6064,
        0.5283,
        0.9795
      ],
      "label": "Text",
      "confidence": 0.946,
      "area": 114600,
      "center": [
        233,
        812
      ],
      "width": 300,
      "height": 382,
      "extractedText": "void IfuPageReplacement(int pages{], int, int capacity) | int pageFaults = 0: int frame{capaciny]. feclcapacin’: int count = 0; for (inti =0: = capaci: i++) { framefi]=-1: freqli] =O; } for (inti = 0; <n; i++) | int flag = 0: for inj =0:) < capaci: j++) { if @ramelj] = pages() { freq: flag 1: bres: i i if (flag=0) { int minFreq = fre0], minlndex = 0: for (in = 1: = capaci; j++) { if (eqlj] < minfrea) | ‘minFreq = freqj];",
      "reading_order": 12,
      "pageNumber": 26,
      "sourceImagePath": "temp_images\\page-26.png",
      "annotatedImagePath": "output\\annotated_frames\\page_26_annotated.png",
      "pageWidth": 725,
      "pageHeight": 1024
    },
    {
      "id": "page27_detection1",
      "bbox": [
        78,
        85,
        504,
        993
      ],
      "bbox_normalized": [
        0.1076,
        0.083,
        0.6952,
        0.9697
      ],
      "label": "Text",
      "confidence": 0.895,
      "area": 386808,
      "center": [
        291,
        539
      ],
      "width": 426,
      "height": 908,
      "extractedText": "minlodex =: i } ramefminladex] = pages: freqlminindex] = 1: pageFaults +; i i printf(\"LFU Page Fauls: Yd, ageFault); i int findOptimalPage(int pages(]. nt in framel] nt currentndes, int capaci) | int maxDistance = pageToReplace =-1: for (inti =0: = capaci: i++) | ine for = currentindexs <i) | if rameli) = pags(j) { if > maxDistance) { maxDistance =j: pageToReplace ~framelil i bres: i i ifG=m{ rerum framefil i i retum page ToReplace: i void optimalPageReplacament(int pages(. int. int capaci) | int pageFaults = 0: int framelcapacin: for (inti =0: = capaci: i++) rameli] =~ 1: for (inti = 0; <n; i+) | int flag = 0: for inj = 03) < capaci: j++) { if (@ramelj] = pages() { flag: bres: i i if(flag=0) { if (i < capacity) | frameli] = pagestl: else { int pageToReplace = findOptimalPage(pages n frame, i+ 1, capaci): for (int = 05 capacins +4) | if (framelj) — pageToReplace) { frame(j] = pages; break:",
      "reading_order": 1,
      "pageNumber": 27,
      "sourceImagePath": "temp_images\\page-27.png",
      "annotatedImagePath": "output\\annotated_frames\\page_27_annotated.png",
      "pageWidth": 725,
      "pageHeight": 1024
    },
    {
      "id": "page28_detection1",
      "bbox": [
        79,
        99,
        345,
        387
      ],
      "bbox_normalized": [
        0.109,
        0.0967,
        0.4759,
        0.3779
      ],
      "label": "Text",
      "confidence": 0.87,
      "area": 76608,
      "center": [
        212,
        243
      ],
      "width": 266,
      "height": 288,
      "extractedText": "’ ) ) pageFaulisi-+, ) ) printf(\"Optimal Page Faults: %dn\", pageFaults) ) int main() { int pages(] = {7,0,1,2,0,3,0.4,2,3,0.3,2); int n = sizeof pages) sizeof{pages[0] int capacity = 3; IfuPageReplacement (pages, n. capacity). optimalPageR placement (pages, n, capacity): retum 0; i",
      "reading_order": 1,
      "pageNumber": 28,
      "sourceImagePath": "temp_images\\page-28.png",
      "annotatedImagePath": "output\\annotated_frames\\page_28_annotated.png",
      "pageWidth": 725,
      "pageHeight": 1024
    },
    {
      "id": "page28_detection2",
      "bbox": [
        91,
        463,
        484,
        522
      ],
      "bbox_normalized": [
        0.1255,
        0.4521,
        0.6676,
        0.5098
      ],
      "label": "Text",
      "confidence": 0.704,
      "area": 23187,
      "center": [
        288,
        493
      ],
      "width": 393,
      "height": 59,
      "extractedText": "N58} FU page Faults: 9 optimal Page Faults: 7 PS D:\\Hemang\\hj AIMS\\voice-segregation\\smart Farm\\smart-farm>",
      "reading_order": 2,
      "pageNumber": 28,
      "sourceImagePath": "temp_images\\page-28.png",
      "annotatedImagePath": "output\\annotated_frames\\page_28_annotated.png",
      "pageWidth": 725,
      "pageHeight": 1024
    },
    {
      "id": "page29_detection14",
      "bbox": [
        297,
        92,
        413,
        113
      ],
      "bbox_normalized": [
        0.4097,
        0.0898,
        0.5697,
        0.1104
      ],
      "label": "Section-header",
      "confidence": 0.713,
      "area": 2436,
      "center": [
        355,
        103
      ],
      "width": 116,
      "height": 21,
      "extractedText": "Experiment — 9",
      "reading_order": 1,
      "pageNumber": 29,
      "sourceImagePath": "temp_images\\page-29.png",
      "annotatedImagePath": "output\\annotated_frames\\page_29_annotated.png",
      "pageWidth": 725,
      "pageHeight": 1024
    },
    {
      "id": "page29_detection13",
      "bbox": [
        96,
        147,
        480,
        163
      ],
      "bbox_normalized": [
        0.1324,
        0.1436,
        0.6621,
        0.1592
      ],
      "label": "Text",
      "confidence": 0.744,
      "area": 6144,
      "center": [
        288,
        155
      ],
      "width": 384,
      "height": 16,
      "extractedText": "m: Write a C program to simulate producer-consumer problem using s¢",
      "reading_order": 2,
      "pageNumber": 29,
      "sourceImagePath": "temp_images\\page-29.png",
      "annotatedImagePath": "output\\annotated_frames\\page_29_annotated.png",
      "pageWidth": 725,
      "pageHeight": 1024
    },
    {
      "id": "page29_detection18",
      "bbox": [
        81,
        189,
        167,
        209
      ],
      "bbox_normalized": [
        0.1117,
        0.1846,
        0.2303,
        0.2041
      ],
      "label": "Text",
      "confidence": 0.591,
      "area": 1720,
      "center": [
        124,
        199
      ],
      "width": 86,
      "height": 20,
      "extractedText": "Description:",
      "reading_order": 3,
      "pageNumber": 29,
      "sourceImagePath": "temp_images\\page-29.png",
      "annotatedImagePath": "output\\annotated_frames\\page_29_annotated.png",
      "pageWidth": 725,
      "pageHeight": 1024
    },
    {
      "id": "page29_detection7",
      "bbox": [
        81,
        237,
        471,
        255
      ],
      "bbox_normalized": [
        0.1117,
        0.2314,
        0.6497,
        0.249
      ],
      "label": "Text",
      "confidence": 0.929,
      "area": 7020,
      "center": [
        276,
        246
      ],
      "width": 390,
      "height": 18,
      "extractedText": "The Producer-Consumer problem involves two main processes:",
      "reading_order": 4,
      "pageNumber": 29,
      "sourceImagePath": "temp_images\\page-29.png",
      "annotatedImagePath": "output\\annotated_frames\\page_29_annotated.png",
      "pageWidth": 725,
      "pageHeight": 1024
    },
    {
      "id": "page29_detection8",
      "bbox": [
        103,
        288,
        494,
        306
      ],
      "bbox_normalized": [
        0.1421,
        0.2813,
        0.6814,
        0.2988
      ],
      "label": "List-item",
      "confidence": 0.921,
      "area": 7038,
      "center": [
        299,
        297
      ],
      "width": 391,
      "height": 18,
      "extractedText": "« The Consumer: This process consumes items from the buffer.",
      "reading_order": 5,
      "pageNumber": 29,
      "sourceImagePath": "temp_images\\page-29.png",
      "annotatedImagePath": "output\\annotated_frames\\page_29_annotated.png",
      "pageWidth": 725,
      "pageHeight": 1024
    },
    {
      "id": "page29_detection6",
      "bbox": [
        102,
        270,
        594,
        289
      ],
      "bbox_normalized": [
        0.1407,
        0.2637,
        0.8193,
        0.2822
      ],
      "label": "List-item",
      "confidence": 0.931,
      "area": 9348,
      "center": [
        348,
        280
      ],
      "width": 492,
      "height": 19,
      "extractedText": "The Producer: This process generates items and stores them in a shared buffer.",
      "reading_order": 6,
      "pageNumber": 29,
      "sourceImagePath": "temp_images\\page-29.png",
      "annotatedImagePath": "output\\annotated_frames\\page_29_annotated.png",
      "pageWidth": 725,
      "pageHeight": 1024
    },
    {
      "id": "page29_detection15",
      "bbox": [
        80,
        322,
        627,
        340
      ],
      "bbox_normalized": [
        0.1103,
        0.3145,
        0.8648,
        0.332
      ],
      "label": "Text",
      "confidence": 0.702,
      "area": 9846,
      "center": [
        354,
        331
      ],
      "width": 547,
      "height": 18,
      "extractedText": "The semaphore is a synchronization mechanism used to manage access to the shared buffer:",
      "reading_order": 7,
      "pageNumber": 29,
      "sourceImagePath": "temp_images\\page-29.png",
      "annotatedImagePath": "output\\annotated_frames\\page_29_annotated.png",
      "pageWidth": 725,
      "pageHeight": 1024
    },
    {
      "id": "page29_detection2",
      "bbox": [
        102,
        354,
        613,
        390
      ],
      "bbox_normalized": [
        0.1407,
        0.3457,
        0.8455,
        0.3809
      ],
      "label": "List-item",
      "confidence": 0.962,
      "area": 18396,
      "center": [
        358,
        372
      ],
      "width": 511,
      "height": 36,
      "extractedText": "+ A mutex semaphore (binary semaphore) is used to ensure mutual exclusion while accessing the buffer.",
      "reading_order": 8,
      "pageNumber": 29,
      "sourceImagePath": "temp_images\\page-29.png",
      "annotatedImagePath": "output\\annotated_frames\\page_29_annotated.png",
      "pageWidth": 725,
      "pageHeight": 1024
    },
    {
      "id": "page29_detection1",
      "bbox": [
        103,
        389,
        604,
        424
      ],
      "bbox_normalized": [
        0.1421,
        0.3799,
        0.8331,
        0.4141
      ],
      "label": "List-item",
      "confidence": 0.965,
      "area": 17535,
      "center": [
        354,
        407
      ],
      "width": 501,
      "height": 35,
      "extractedText": "+ A full semaphore is used to track how many items are in the buffer, ensuring the consumer waits if the buffer is empty.",
      "reading_order": 9,
      "pageNumber": 29,
      "sourceImagePath": "temp_images\\page-29.png",
      "annotatedImagePath": "output\\annotated_frames\\page_29_annotated.png",
      "pageWidth": 725,
      "pageHeight": 1024
    },
    {
      "id": "page29_detection4",
      "bbox": [
        102,
        422,
        603,
        458
      ],
      "bbox_normalized": [
        0.1407,
        0.4121,
        0.8317,
        0.4473
      ],
      "label": "List-item",
      "confidence": 0.961,
      "area": 18036,
      "center": [
        353,
        440
      ],
      "width": 501,
      "height": 36,
      "extractedText": "+ An empty semaphore tracks how many empty spaces are available in the buffer, ensuring the producer waits if the buffer is full",
      "reading_order": 10,
      "pageNumber": 29,
      "sourceImagePath": "temp_images\\page-29.png",
      "annotatedImagePath": "output\\annotated_frames\\page_29_annotated.png",
      "pageWidth": 725,
      "pageHeight": 1024
    },
    {
      "id": "page29_detection3",
      "bbox": [
        80,
        473,
        622,
        508
      ],
      "bbox_normalized": [
        0.1103,
        0.4619,
        0.8579,
        0.4961
      ],
      "label": "Text",
      "confidence": 0.961,
      "area": 18970,
      "center": [
        351,
        491
      ],
      "width": 542,
      "height": 35,
      "extractedText": "The problem can be solved by using semaphores to avoid race conditions and ensure proper synchronization between the producer and consumer.",
      "reading_order": 11,
      "pageNumber": 29,
      "sourceImagePath": "temp_images\\page-29.png",
      "annotatedImagePath": "output\\annotated_frames\\page_29_annotated.png",
      "pageWidth": 725,
      "pageHeight": 1024
    },
    {
      "id": "page29_detection5",
      "bbox": [
        80,
        587,
        653,
        654
      ],
      "bbox_normalized": [
        0.1103,
        0.5732,
        0.9007,
        0.6387
      ],
      "label": "Text",
      "confidence": 0.944,
      "area": 38391,
      "center": [
        367,
        621
      ],
      "width": 573,
      "height": 67,
      "extractedText": "Producer-Consumer Problem: The producer-consumer problem involves two types of processes: the producer, which generates data (e.g., adding items to a buffer), and the consumer, which consumes data from this buffer. The buffer has limited capacity, so producers must wait if it's full, and consumers must wait if it's empty.",
      "reading_order": 12,
      "pageNumber": 29,
      "sourceImagePath": "temp_images\\page-29.png",
      "annotatedImagePath": "output\\annotated_frames\\page_29_annotated.png",
      "pageWidth": 725,
      "pageHeight": 1024
    },
    {
      "id": "page29_detection17",
      "bbox": [
        83,
        654,
        467,
        671
      ],
      "bbox_normalized": [
        0.1145,
        0.6387,
        0.6441,
        0.6553
      ],
      "label": "Text",
      "confidence": 0.626,
      "area": 6528,
      "center": [
        275,
        663
      ],
      "width": 384,
      "height": 17,
      "extractedText": "Semaphores: Semaphores are used to handle process synchroniza",
      "reading_order": 13,
      "pageNumber": 29,
      "sourceImagePath": "temp_images\\page-29.png",
      "annotatedImagePath": "output\\annotated_frames\\page_29_annotated.png",
      "pageWidth": 725,
      "pageHeight": 1024
    },
    {
      "id": "page29_detection16",
      "bbox": [
        80,
        687,
        302,
        702
      ],
      "bbox_normalized": [
        0.1103,
        0.6709,
        0.4166,
        0.6855
      ],
      "label": "Text",
      "confidence": 0.639,
      "area": 3330,
      "center": [
        191,
        695
      ],
      "width": 222,
      "height": 15,
      "extractedText": "2.A semaphore full tracks the filled slots.",
      "reading_order": 14,
      "pageNumber": 29,
      "sourceImagePath": "temp_images\\page-29.png",
      "annotatedImagePath": "output\\annotated_frames\\page_29_annotated.png",
      "pageWidth": 725,
      "pageHeight": 1024
    },
    {
      "id": "page29_detection9",
      "bbox": [
        80,
        701,
        623,
        733
      ],
      "bbox_normalized": [
        0.1103,
        0.6846,
        0.8593,
        0.7158
      ],
      "label": "Text",
      "confidence": 0.91,
      "area": 17376,
      "center": [
        352,
        717
      ],
      "width": 543,
      "height": 32,
      "extractedText": "3.A mutex semaphore ensures mutual exclusion, allowing only one process to modify the buffer at a time.",
      "reading_order": 15,
      "pageNumber": 29,
      "sourceImagePath": "temp_images\\page-29.png",
      "annotatedImagePath": "output\\annotated_frames\\page_29_annotated.png",
      "pageWidth": 725,
      "pageHeight": 1024
    },
    {
      "id": "page29_detection11",
      "bbox": [
        81,
        751,
        125,
        768
      ],
      "bbox_normalized": [
        0.1117,
        0.7334,
        0.1724,
        0.75
      ],
      "label": "Section-header",
      "confidence": 0.804,
      "area": 748,
      "center": [
        103,
        760
      ],
      "width": 44,
      "height": 17,
      "extractedText": "Code:",
      "reading_order": 16,
      "pageNumber": 29,
      "sourceImagePath": "temp_images\\page-29.png",
      "annotatedImagePath": "output\\annotated_frames\\page_29_annotated.png",
      "pageWidth": 725,
      "pageHeight": 1024
    },
    {
      "id": "page29_detection10",
      "bbox": [
        81,
        787,
        183,
        837
      ],
      "bbox_normalized": [
        0.1117,
        0.7686,
        0.2524,
        0.8174
      ],
      "label": "Text",
      "confidence": 0.812,
      "area": 5100,
      "center": [
        132,
        812
      ],
      "width": 102,
      "height": 50,
      "extractedText": "#include <stdio.h> include <sidlibh> ¥include <unistd.h>",
      "reading_order": 17,
      "pageNumber": 29,
      "sourceImagePath": "temp_images\\page-29.png",
      "annotatedImagePath": "output\\annotated_frames\\page_29_annotated.png",
      "pageWidth": 725,
      "pageHeight": 1024
    },
    {
      "id": "page29_detection12",
      "bbox": [
        81,
        856,
        224,
        923
      ],
      "bbox_normalized": [
        0.1117,
        0.8359,
        0.309,
        0.9014
      ],
      "label": "Text",
      "confidence": 0.762,
      "area": 9581,
      "center": [
        153,
        890
      ],
      "width": 143,
      "height": 67,
      "extractedText": "#define BUFFER SIZE 5 int buffer{BUFFER_SIZE]; int in= 0, out =0; int count = 0;",
      "reading_order": 18,
      "pageNumber": 29,
      "sourceImagePath": "temp_images\\page-29.png",
      "annotatedImagePath": "output\\annotated_frames\\page_29_annotated.png",
      "pageWidth": 725,
      "pageHeight": 1024
    },
    {
      "id": "page30_detection1",
      "bbox": [
        80,
        99,
        416,
        708
      ],
      "bbox_normalized": [
        0.1103,
        0.0967,
        0.5738,
        0.6914
      ],
      "label": "Text",
      "confidence": 0.738,
      "area": 204624,
      "center": [
        248,
        404
      ],
      "width": 336,
      "height": 609,
      "extractedText": "Tetum; } bufferfin] = rem; in= (in 1) % BUFFER_SIZE; count; printf(\"Produced: Yd’, item): ] int consume() { if (count — 0) { printf{\"Buffr is empty. Waiting to consume.'n\"); retum 1; ) int tem = bufferfout]; out = (out + 1) % BUFFER_SIZE; count, printf(\" Consumed: %dn\", item): retum item; ] int main() { int items_to_produce = 10; int produce interval = I // seconds between produce actions int consume_interval =2; // seconds between consume actions for (inti = 0; i < tems_to_produce; i++) { produce + 1); sleep(produce_interval); if count 0) { consume); sleep(consume interval); ) )",
      "reading_order": 1,
      "pageNumber": 30,
      "sourceImagePath": "temp_images\\page-30.png",
      "annotatedImagePath": "output\\annotated_frames\\page_30_annotated.png",
      "pageWidth": 725,
      "pageHeight": 1024
    },
    {
      "id": "page32_detection4",
      "bbox": [
        300,
        92,
        410,
        113
      ],
      "bbox_normalized": [
        0.4138,
        0.0898,
        0.5655,
        0.1104
      ],
      "label": "Section-header",
      "confidence": 0.764,
      "area": 2310,
      "center": [
        355,
        103
      ],
      "width": 110,
      "height": 21,
      "extractedText": "Experiment-10",
      "reading_order": 1,
      "pageNumber": 32,
      "sourceImagePath": "temp_images\\page-32.png",
      "annotatedImagePath": "output\\annotated_frames\\page_32_annotated.png",
      "pageWidth": 725,
      "pageHeight": 1024
    },
    {
      "id": "page32_detection8",
      "bbox": [
        81,
        125,
        574,
        145
      ],
      "bbox_normalized": [
        0.1117,
        0.1221,
        0.7917,
        0.1416
      ],
      "label": "Text",
      "confidence": 0.547,
      "area": 9860,
      "center": [
        328,
        135
      ],
      "width": 493,
      "height": 20,
      "extractedText": "Aim: Write a C program to simulate disk scheduling algorithms a) FCFS, b) SCAN",
      "reading_order": 2,
      "pageNumber": 32,
      "sourceImagePath": "temp_images\\page-32.png",
      "annotatedImagePath": "output\\annotated_frames\\page_32_annotated.png",
      "pageWidth": 725,
      "pageHeight": 1024
    },
    {
      "id": "page32_detection6",
      "bbox": [
        81,
        158,
        160,
        175
      ],
      "bbox_normalized": [
        0.1117,
        0.1543,
        0.2207,
        0.1709
      ],
      "label": "Section-header",
      "confidence": 0.699,
      "area": 1343,
      "center": [
        121,
        167
      ],
      "width": 79,
      "height": 17,
      "extractedText": "Description:",
      "reading_order": 3,
      "pageNumber": 32,
      "sourceImagePath": "temp_images\\page-32.png",
      "annotatedImagePath": "output\\annotated_frames\\page_32_annotated.png",
      "pageWidth": 725,
      "pageHeight": 1024
    },
    {
      "id": "page32_detection1",
      "bbox": [
        80,
        189,
        620,
        241
      ],
      "bbox_normalized": [
        0.1103,
        0.1846,
        0.8552,
        0.2354
      ],
      "label": "Text",
      "confidence": 0.964,
      "area": 28080,
      "center": [
        350,
        215
      ],
      "width": 540,
      "height": 52,
      "extractedText": "This experiment implements two disk scheduling algorithms. FCFS services requests in the order they arrive, while SCAN moves the disk arm back and forth across the request queue, servicing requests as it reaches them in each direct",
      "reading_order": 4,
      "pageNumber": 32,
      "sourceImagePath": "temp_images\\page-32.png",
      "annotatedImagePath": "output\\annotated_frames\\page_32_annotated.png",
      "pageWidth": 725,
      "pageHeight": 1024
    },
    {
      "id": "page32_detection7",
      "bbox": [
        81,
        254,
        134,
        272
      ],
      "bbox_normalized": [
        0.1117,
        0.248,
        0.1848,
        0.2656
      ],
      "label": "Text",
      "confidence": 0.636,
      "area": 954,
      "center": [
        108,
        263
      ],
      "width": 53,
      "height": 18,
      "extractedText": "Theory:",
      "reading_order": 5,
      "pageNumber": 32,
      "sourceImagePath": "temp_images\\page-32.png",
      "annotatedImagePath": "output\\annotated_frames\\page_32_annotated.png",
      "pageWidth": 725,
      "pageHeight": 1024
    },
    {
      "id": "page32_detection2",
      "bbox": [
        80,
        285,
        635,
        337
      ],
      "bbox_normalized": [
        0.1103,
        0.2783,
        0.8759,
        0.3291
      ],
      "label": "Text",
      "confidence": 0.866,
      "area": 28860,
      "center": [
        358,
        311
      ],
      "width": 555,
      "height": 52,
      "extractedText": "FCFS (First-Come, First-Served): The simplest disk scheduling algorithm, where requests are serviced in the order they amive. While easy to implement, it does not optimize seek time, and requests on opposite sides of the disk can increase the time required.",
      "reading_order": 6,
      "pageNumber": 32,
      "sourceImagePath": "temp_images\\page-32.png",
      "annotatedImagePath": "output\\annotated_frames\\page_32_annotated.png",
      "pageWidth": 725,
      "pageHeight": 1024
    },
    {
      "id": "page32_detection3",
      "bbox": [
        80,
        335,
        645,
        404
      ],
      "bbox_normalized": [
        0.1103,
        0.3271,
        0.8897,
        0.3945
      ],
      "label": "Text",
      "confidence": 0.821,
      "area": 38985,
      "center": [
        363,
        370
      ],
      "width": 565,
      "height": 69,
      "extractedText": "SCAN: Also known as the \"elevator algorithm,” SCAN moves the disk arm in one direction, servicing all requests, then reverses direction once the end is reached. This approach reduces the overall seek time by eliminating excessive arm movement and ensures that no requests are left waiting indefinitely.",
      "reading_order": 7,
      "pageNumber": 32,
      "sourceImagePath": "temp_images\\page-32.png",
      "annotatedImagePath": "output\\annotated_frames\\page_32_annotated.png",
      "pageWidth": 725,
      "pageHeight": 1024
    },
    {
      "id": "page32_detection9",
      "bbox": [
        81,
        418,
        122,
        436
      ],
      "bbox_normalized": [
        0.1117,
        0.4082,
        0.1683,
        0.4258
      ],
      "label": "Section-header",
      "confidence": 0.522,
      "area": 738,
      "center": [
        102,
        427
      ],
      "width": 41,
      "height": 18,
      "extractedText": "Code:",
      "reading_order": 8,
      "pageNumber": 32,
      "sourceImagePath": "temp_images\\page-32.png",
      "annotatedImagePath": "output\\annotated_frames\\page_32_annotated.png",
      "pageWidth": 725,
      "pageHeight": 1024
    },
    {
      "id": "page32_detection5",
      "bbox": [
        80,
        459,
        433,
        1011
      ],
      "bbox_normalized": [
        0.1103,
        0.4482,
        0.5972,
        0.9873
      ],
      "label": "Text",
      "confidence": 0.736,
      "area": 194856,
      "center": [
        257,
        735
      ],
      "width": 353,
      "height": 552,
      "extractedText": "#include <stdlib.h> void fefint requests], int, int ead) { int seck time 0; printf(\"nFCFS Disk Scheduling!in'): for (inti = 0; i< ni; 44) { printf{\"Moving from %d to %d\\n\", head, requests]: seek _time += abs(requesisli] - head); head = requess[i); ) printf(\"Total Seek Time (FCFS): %din\", sek_time): ] void scanlint requests() int n, int head. int direction, int disk size) { int seck time 0; printf(\"nSCAN Disk Scheduling\"); for (inti = 0; i< n- 1:4) { for (nj =i +13 < mj) | if (requests[i] > requests) { inttemp = requests requesis(i) = requests); requesis[j] = temp; ) ) ) int, current_position ~ head: if direction —1) { for i= 0; i< n && requess(i] < head: i++);",
      "reading_order": 9,
      "pageNumber": 32,
      "sourceImagePath": "temp_images\\page-32.png",
      "annotatedImagePath": "output\\annotated_frames\\page_32_annotated.png",
      "pageWidth": 725,
      "pageHeight": 1024
    },
    {
      "id": "page33_detection1",
      "bbox": [
        80,
        94,
        458,
        997
      ],
      "bbox_normalized": [
        0.1103,
        0.0918,
        0.6317,
        0.9736
      ],
      "label": "Text",
      "confidence": 0.955,
      "area": 341334,
      "center": [
        269,
        546
      ],
      "width": 378,
      "height": 903,
      "extractedText": "while i <n) { printf\" Moving from %d to %din\", current_position, requests]. seck time += abs(reguesisi] - current position); current_position = requesisfi+ +1; } if (current_position < disk size - 1) { printf\" Moving from %d to %d\\n\", current_position, disk_size - seek time += abs(disk_size - | - curtent_position): current_position =disk_size - 1; ) for i i= 0; i) { printf\" Moving from %d to %d\\n\", current_position, requests]; seek time += abs(reguesisi] - current position); current_position = requests; } else | for(i =n - 1; i>=0 && requesis(i] > head: i=); while (>=0) { printf\" Moving from %d 0 %din\", current_position, requests]. seck time += abs(reguesisi] - current position); current_position = requestsfi-]: } if (curtent_position > 0) printf\" Moving from %d to %d\\n\", current_position, 0); seek time += current_position: current_position = 0: } for (i++ i <miith) { printf\" Moving from %d to %din\", current_position, requests]. seek time += abs(reguesisi] - current position); current_position = requests; ) ) printf(\"Total Seek Time (SCAN): %dn’, seck time); ] int main() { itn, head, direction, disk size; printf(\"Enter the number of requests: ): scanf(\" Yd\", &n): int requestsfnl; printf(\"Enter the requests\"); for (inti = 0: i< n: #4) { seanf(\"%od\", &requestsfl); ) printf(\"Enter initial head position: \"): scanf(\"%d\", &head); printf(\"Enter disk size: \"); scanfl\" id\", &disk_size);",
      "reading_order": 1,
      "pageNumber": 33,
      "sourceImagePath": "temp_images\\page-33.png",
      "annotatedImagePath": "output\\annotated_frames\\page_33_annotated.png",
      "pageWidth": 725,
      "pageHeight": 1024
    },
    {
      "id": "page34_detection2",
      "bbox": [
        94,
        96,
        346,
        128
      ],
      "bbox_normalized": [
        0.1297,
        0.0938,
        0.4772,
        0.125
      ],
      "label": "Text",
      "confidence": 0.524,
      "area": 8064,
      "center": [
        220,
        112
      ],
      "width": 252,
      "height": 32,
      "extractedText": "printf(\"Enter direction (1 for high, 0 for low): *); scanf(\"%d\", &direction);",
      "reading_order": 1,
      "pageNumber": 34,
      "sourceImagePath": "temp_images\\page-34.png",
      "annotatedImagePath": "output\\annotated_frames\\page_34_annotated.png",
      "pageWidth": 725,
      "pageHeight": 1024
    },
    {
      "id": "page34_detection1",
      "bbox": [
        81,
        296,
        133,
        312
      ],
      "bbox_normalized": [
        0.1117,
        0.2891,
        0.1834,
        0.3047
      ],
      "label": "Section-header",
      "confidence": 0.732,
      "area": 832,
      "center": [
        107,
        304
      ],
      "width": 52,
      "height": 16,
      "extractedText": "Output:",
      "reading_order": 2,
      "pageNumber": 34,
      "sourceImagePath": "temp_images\\page-34.png",
      "annotatedImagePath": "output\\annotated_frames\\page_34_annotated.png",
      "pageWidth": 725,
      "pageHeight": 1024
    }
  ],
  "pages": [
    {
      "pageNumber": 1,
      "processingTime": 0.97,
      "sourceImagePath": "temp_images\\page-01.png",
      "annotatedImagePath": "output\\annotated_frames\\page_1_annotated.png",
      "imageWidth": 724,
      "imageHeight": 1024,
      "detectionsCount": 5,
      "detections": [
        {
          "id": "page1_detection5",
          "bbox": [
            186,
            139,
            564,
            168
          ],
          "bbox_normalized": [
            0.2569,
            0.1357,
            0.779,
            0.1641
          ],
          "label": "Text",
          "confidence": 0.568,
          "area": 10962,
          "center": [
            375,
            154
          ],
          "width": 378,
          "height": 29,
          "extractedText": "(Formerly Delhi College of Engineering)",
          "reading_order": 1,
          "pageNumber": 1
        },
        {
          "id": "page1_detection1",
          "bbox": [
            255,
            187,
            469,
            402
          ],
          "bbox_normalized": [
            0.3522,
            0.1826,
            0.6478,
            0.3926
          ],
          "label": "Picture",
          "confidence": 0.906,
          "area": 46010,
          "center": [
            362,
            295
          ],
          "width": 214,
          "height": 215,
          "extractedText": "[Picture - image content]",
          "reading_order": 2,
          "pageNumber": 1
        },
        {
          "id": "page1_detection3",
          "bbox": [
            91,
            448,
            662,
            522
          ],
          "bbox_normalized": [
            0.1257,
            0.4375,
            0.9144,
            0.5098
          ],
          "label": "Title",
          "confidence": 0.697,
          "area": 42254,
          "center": [
            377,
            485
          ],
          "width": 571,
          "height": 74,
          "extractedText": "DEPARTMENT OF COMPUTER SCIENCE AND ENGINEERING",
          "reading_order": 3,
          "pageNumber": 1
        },
        {
          "id": "page1_detection4",
          "bbox": [
            63,
            813,
            293,
            890
          ],
          "bbox_normalized": [
            0.087,
            0.7939,
            0.4047,
            0.8691
          ],
          "label": "Text",
          "confidence": 0.61,
          "area": 17710,
          "center": [
            178,
            852
          ],
          "width": 230,
          "height": 77,
          "extractedText": "Dr. Pawan Singh Mehra Assistant Professor CSE Department",
          "reading_order": 4,
          "pageNumber": 1
        },
        {
          "id": "page1_detection2",
          "bbox": [
            438,
            778,
            652,
            902
          ],
          "bbox_normalized": [
            0.605,
            0.7598,
            0.9006,
            0.8809
          ],
          "label": "Text",
          "confidence": 0.806,
          "area": 26536,
          "center": [
            545,
            840
          ],
          "width": 214,
          "height": 124,
          "extractedText": "SUBMITTED BY- Hemang Jain Roll No.: 23/CS/174 Batch: CO-A3",
          "reading_order": 5,
          "pageNumber": 1
        }
      ]
    },
    {
      "pageNumber": 2,
      "processingTime": 1.56,
      "sourceImagePath": "temp_images\\page-02.png",
      "annotatedImagePath": "output\\annotated_frames\\page_2_annotated.png",
      "imageWidth": 725,
      "imageHeight": 1024,
      "detectionsCount": 9,
      "detections": [
        {
          "id": "page2_detection9",
          "bbox": [
            289,
            100,
            469,
            116
          ],
          "bbox_normalized": [
            0.3986,
            0.0977,
            0.6469,
            0.1133
          ],
          "label": "Section-header",
          "confidence": 0.784,
          "area": 2880,
          "center": [
            379,
            108
          ],
          "width": 180,
          "height": 16,
          "extractedText": "VISION AND MISSION",
          "reading_order": 1,
          "pageNumber": 2
        },
        {
          "id": "page2_detection3",
          "bbox": [
            107,
            164,
            147,
            178
          ],
          "bbox_normalized": [
            0.1476,
            0.1602,
            0.2028,
            0.1738
          ],
          "label": "Section-header",
          "confidence": 0.879,
          "area": 560,
          "center": [
            127,
            171
          ],
          "width": 40,
          "height": 14,
          "extractedText": "Yision",
          "reading_order": 2,
          "pageNumber": 2
        },
        {
          "id": "page2_detection1",
          "bbox": [
            106,
            193,
            627,
            259
          ],
          "bbox_normalized": [
            0.1462,
            0.1885,
            0.8648,
            0.2529
          ],
          "label": "Text",
          "confidence": 0.953,
          "area": 34386,
          "center": [
            367,
            226
          ],
          "width": 521,
          "height": 66,
          "extractedText": "Department of Computer Science & Engineering to be a leading world class technology department playing ts role as a key node in national and global knowledge network, thus empowering the computer science industry with the wings of knowledge and power of innovation.",
          "reading_order": 3,
          "pageNumber": 2
        },
        {
          "id": "page2_detection6",
          "bbox": [
            107,
            311,
            156,
            325
          ],
          "bbox_normalized": [
            0.1476,
            0.3037,
            0.2152,
            0.3174
          ],
          "label": "Section-header",
          "confidence": 0.832,
          "area": 686,
          "center": [
            132,
            318
          ],
          "width": 49,
          "height": 14,
          "extractedText": "zssion",
          "reading_order": 4,
          "pageNumber": 2
        },
        {
          "id": "page2_detection7",
          "bbox": [
            107,
            340,
            367,
            353
          ],
          "bbox_normalized": [
            0.1476,
            0.332,
            0.5062,
            0.3447
          ],
          "label": "Text",
          "confidence": 0.83,
          "area": 3380,
          "center": [
            237,
            347
          ],
          "width": 260,
          "height": 13,
          "extractedText": "1he Mission of the department 1s as follows:",
          "reading_order": 5,
          "pageNumber": 2
        },
        {
          "id": "page2_detection8",
          "bbox": [
            76,
            370,
            603,
            413
          ],
          "bbox_normalized": [
            0.1048,
            0.3613,
            0.8317,
            0.4033
          ],
          "label": "List-item",
          "confidence": 0.794,
          "area": 22661,
          "center": [
            340,
            392
          ],
          "width": 527,
          "height": 43,
          "extractedText": "1. To nurture talent of students for research, mnovation and excellence in the field of computer engineering starting from Under graduate level.",
          "reading_order": 6,
          "pageNumber": 2
        },
        {
          "id": "page2_detection4",
          "bbox": [
            76,
            430,
            617,
            475
          ],
          "bbox_normalized": [
            0.1048,
            0.4199,
            0.851,
            0.4639
          ],
          "label": "List-item",
          "confidence": 0.866,
          "area": 24345,
          "center": [
            347,
            453
          ],
          "width": 541,
          "height": 45,
          "extractedText": "2. To develop highly analytical and qualified computer engineers by imparting training on cutting edge technology.",
          "reading_order": 7,
          "pageNumber": 2
        },
        {
          "id": "page2_detection5",
          "bbox": [
            76,
            493,
            503,
            506
          ],
          "bbox_normalized": [
            0.1048,
            0.4814,
            0.6938,
            0.4941
          ],
          "label": "List-item",
          "confidence": 0.854,
          "area": 5551,
          "center": [
            290,
            500
          ],
          "width": 427,
          "height": 13,
          "extractedText": "3. To produce socially sensitive computer engineers with professional ethics.",
          "reading_order": 8,
          "pageNumber": 2
        },
        {
          "id": "page2_detection2",
          "bbox": [
            76,
            557,
            594,
            601
          ],
          "bbox_normalized": [
            0.1048,
            0.5439,
            0.8193,
            0.5869
          ],
          "label": "List-item",
          "confidence": 0.939,
          "area": 22792,
          "center": [
            335,
            579
          ],
          "width": 518,
          "height": 44,
          "extractedText": "3. To produce well-rounded, up to date, scientifically tempered, design-oriented engineer and scientists capable of lifelong learning.",
          "reading_order": 9,
          "pageNumber": 2
        }
      ]
    },
    {
      "pageNumber": 3,
      "processingTime": 1.46,
      "sourceImagePath": "temp_images\\page-03.png",
      "annotatedImagePath": "output\\annotated_frames\\page_3_annotated.png",
      "imageWidth": 725,
      "imageHeight": 1024,
      "detectionsCount": 2,
      "detections": [
        {
          "id": "page3_detection2",
          "bbox": [
            338,
            95,
            394,
            111
          ],
          "bbox_normalized": [
            0.4662,
            0.0928,
            0.5434,
            0.1084
          ],
          "label": "Section-header",
          "confidence": 0.698,
          "area": 896,
          "center": [
            366,
            103
          ],
          "width": 56,
          "height": 16,
          "extractedText": "INDEX",
          "reading_order": 1,
          "pageNumber": 3
        },
        {
          "id": "page3_detection1",
          "bbox": [
            73,
            159,
            657,
            906
          ],
          "bbox_normalized": [
            0.1007,
            0.1553,
            0.9062,
            0.8848
          ],
          "label": "Table",
          "confidence": 0.963,
          "area": 436248,
          "center": [
            365,
            533
          ],
          "width": 584,
          "height": 747,
          "extractedText": "BE —— RE Write a C program to simulate the following non- 200824 preemptive CPU scheduling algorithms to find tumaround time and waiting time for a given problem. a) FCFS, b) SIF 2, Write a C program to simulate the following 200824 preemptive CPU scheduling algorithms to find tumaround time and waiting time for a given problem. a) Round Robin b) Priority 3 Write a C program to simulate the following 280824 contiguous memory allocation techniques a) Worst fib) Best ft, c) First fit 4, Write a C program to simulate the following file 04/09/24 allocation strategies. a) Sequential, b) Indexed B Write a C program to simulate Baker's algorithm 11109724 for the purpose of Deadlock avoidance. 6 Write a C program to simulate Banker's algorithm 11109724 for the purpose of Deadlock prevention. 7 Write a C program to simulate page replacement 09/1024 algorithm a) FIFO, b) LRU Write a C program to simulate page replacement 09/1024 algorithm a) LFU, b) Optimal Write a C program to simulate producer consumer 161024 problem using semaphores. Write a C program to simulate disk scheduling 231024 algorithms a) FCFS, b) SCAN.",
          "reading_order": 2,
          "pageNumber": 3
        }
      ]
    },
    {
      "pageNumber": 4,
      "processingTime": 2.42,
      "sourceImagePath": "temp_images\\page-04.png",
      "annotatedImagePath": "output\\annotated_frames\\page_4_annotated.png",
      "imageWidth": 725,
      "imageHeight": 1024,
      "detectionsCount": 12,
      "detections": [
        {
          "id": "page4_detection8",
          "bbox": [
            310,
            92,
            420,
            114
          ],
          "bbox_normalized": [
            0.4276,
            0.0898,
            0.5793,
            0.1113
          ],
          "label": "Section-header",
          "confidence": 0.689,
          "area": 2420,
          "center": [
            365,
            103
          ],
          "width": 110,
          "height": 22,
          "extractedText": "Experiment - 1",
          "reading_order": 1,
          "pageNumber": 4
        },
        {
          "id": "page4_detection4",
          "bbox": [
            81,
            155,
            641,
            195
          ],
          "bbox_normalized": [
            0.1117,
            0.1514,
            0.8841,
            0.1904
          ],
          "label": "Text",
          "confidence": 0.919,
          "area": 22400,
          "center": [
            361,
            175
          ],
          "width": 560,
          "height": 40,
          "extractedText": "Aim: Write a C program to simulate the following non-preemptive CPU scheduling algorithms to find turnaround time and waiting time for a given problem. a) FCFS, b) SJF",
          "reading_order": 2,
          "pageNumber": 4
        },
        {
          "id": "page4_detection11",
          "bbox": [
            81,
            222,
            161,
            241
          ],
          "bbox_normalized": [
            0.1117,
            0.2168,
            0.2221,
            0.2354
          ],
          "label": "Section-header",
          "confidence": 0.643,
          "area": 1520,
          "center": [
            121,
            232
          ],
          "width": 80,
          "height": 19,
          "extractedText": "Description",
          "reading_order": 3,
          "pageNumber": 4
        },
        {
          "id": "page4_detection3",
          "bbox": [
            81,
            275,
            633,
            377
          ],
          "bbox_normalized": [
            0.1117,
            0.2686,
            0.8731,
            0.3682
          ],
          "label": "Text",
          "confidence": 0.96,
          "area": 56304,
          "center": [
            357,
            326
          ],
          "width": 552,
          "height": 102,
          "extractedText": "FCFS is one of the simplest CPU scheduling algorithms. In this algorithm, the process that arrives first in the ready queue gets executed first. The scheduling is done based on the arrival time of the processes, meaning that processes are served in the order they arrive without preemption. FCFS is easy to implement and understand; however, it can lead to the \"convoy effect,” where short processes wait for a long process to finish, resulting in increased average waiting time.",
          "reading_order": 4,
          "pageNumber": 4
        },
        {
          "id": "page4_detection9",
          "bbox": [
            81,
            393,
            220,
            409
          ],
          "bbox_normalized": [
            0.1117,
            0.3838,
            0.3034,
            0.3994
          ],
          "label": "Section-header",
          "confidence": 0.687,
          "area": 2224,
          "center": [
            151,
            401
          ],
          "width": 139,
          "height": 16,
          "extractedText": "Shortest Job First (SJF)",
          "reading_order": 5,
          "pageNumber": 4
        },
        {
          "id": "page4_detection2",
          "bbox": [
            80,
            425,
            650,
            527
          ],
          "bbox_normalized": [
            0.1103,
            0.415,
            0.8966,
            0.5146
          ],
          "label": "Text",
          "confidence": 0.966,
          "area": 58140,
          "center": [
            365,
            476
          ],
          "width": 570,
          "height": 102,
          "extractedText": "Shortest Job First (SIF) is a non-preemptive scheduling algorithm that selects the process with the smallest burst time (execution time) for execution first. By executing shorter processes before longer ones, SIF can minimize the average waiting time and turnaround time for a set of processes. However, determining the shortest job can be challenging in a real-time system where the lengths of jobs are not known in advance. This algorithm can lead to the \"starvation\" of longer processes if there is a continuous stream of shorter processes arriving.",
          "reading_order": 6,
          "pageNumber": 4
        },
        {
          "id": "page4_detection5",
          "bbox": [
            81,
            544,
            131,
            562
          ],
          "bbox_normalized": [
            0.1117,
            0.5313,
            0.1807,
            0.5488
          ],
          "label": "Section-header",
          "confidence": 0.859,
          "area": 900,
          "center": [
            106,
            553
          ],
          "width": 50,
          "height": 18,
          "extractedText": "Theory",
          "reading_order": 7,
          "pageNumber": 4
        },
        {
          "id": "page4_detection1",
          "bbox": [
            80,
            579,
            651,
            697
          ],
          "bbox_normalized": [
            0.1103,
            0.5654,
            0.8979,
            0.6807
          ],
          "label": "Text",
          "confidence": 0.968,
          "area": 67378,
          "center": [
            366,
            638
          ],
          "width": 571,
          "height": 118,
          "extractedText": "CPU scheduling is a crucial aspect of operating systems that determines the order in which processes are executed. The primary goals of CPU scheduling are to maximize CPU utilization, ensure fairmess among processes, minimize tumaround time, waiting time, and response time, and avoid starvation. Different algorithms have different approaches to scheduling, and the choice of algorithm can significantly impact system performance. Non-preemptive algorithms, such as FCFS and SIF, do not allow a currently executing process to be interrupted; instead, they run to completion before the CPU is allocated to the next process.",
          "reading_order": 8,
          "pageNumber": 4
        },
        {
          "id": "page4_detection12",
          "bbox": [
            85,
            729,
            129,
            749
          ],
          "bbox_normalized": [
            0.1172,
            0.7119,
            0.1779,
            0.7314
          ],
          "label": "Section-header",
          "confidence": 0.519,
          "area": 880,
          "center": [
            107,
            739
          ],
          "width": 44,
          "height": 20,
          "extractedText": "Code:",
          "reading_order": 9,
          "pageNumber": 4
        },
        {
          "id": "page4_detection7",
          "bbox": [
            81,
            750,
            179,
            767
          ],
          "bbox_normalized": [
            0.1117,
            0.7324,
            0.2469,
            0.749
          ],
          "label": "Text",
          "confidence": 0.714,
          "area": 1666,
          "center": [
            130,
            759
          ],
          "width": 98,
          "height": 17,
          "extractedText": "#include <stdio.h>",
          "reading_order": 10,
          "pageNumber": 4
        },
        {
          "id": "page4_detection6",
          "bbox": [
            79,
            786,
            290,
            854
          ],
          "bbox_normalized": [
            0.109,
            0.7676,
            0.4,
            0.834
          ],
          "label": "Text",
          "confidence": 0.734,
          "area": 14348,
          "center": [
            185,
            820
          ],
          "width": 211,
          "height": 68,
          "extractedText": "int main) { intn; . print \"Enter number of processes: \") scanf(\"%d\", &n);",
          "reading_order": 11,
          "pageNumber": 4
        },
        {
          "id": "page4_detection10",
          "bbox": [
            94,
            871,
            349,
            889
          ],
          "bbox_normalized": [
            0.1297,
            0.8506,
            0.4814,
            0.8682
          ],
          "label": "Text",
          "confidence": 0.68,
          "area": 4590,
          "center": [
            222,
            880
          ],
          "width": 255,
          "height": 18,
          "extractedText": "int arrival[n]. burst[n], waiting[n], turnaround[n];",
          "reading_order": 12,
          "pageNumber": 4
        }
      ]
    },
    {
      "pageNumber": 5,
      "processingTime": 1.33,
      "sourceImagePath": "temp_images\\page-05.png",
      "annotatedImagePath": "output\\annotated_frames\\page_5_annotated.png",
      "imageWidth": 725,
      "imageHeight": 1024,
      "detectionsCount": 1,
      "detections": [
        {
          "id": "page5_detection1",
          "bbox": [
            92,
            99,
            543,
            996
          ],
          "bbox_normalized": [
            0.1269,
            0.0967,
            0.749,
            0.9727
          ],
          "label": "Text",
          "confidence": 0.912,
          "area": 404547,
          "center": [
            318,
            548
          ],
          "width": 451,
          "height": 897,
          "extractedText": "wartinglul = for ini = 1 <n; +4) { waiting(i] = waitngfi - 1] + burs - 11; ) for in = 03 <n; ++) { ‘wmaround(i] = waiingfi + burs il; ) print(\"n—— FCFS Scheduling in\"); print \"Process Arrival\\t Burst Waiting { Tumaroundin”): for int = 0: <n; i++) { print\" Ad 9d 5 da, + 1, aval i, burs], waiting], maround{il): ) int toalWaitingF CFS =0, otaTurnaround CFS =0; for in = 0: <n; i++) { total WaitngFCFS += waiting(i: total TumaroundFCFS += turnaround]; ) print(\"Total Waiting Time (FCFS): 9d”, total WaitingF CFS); printf(\"Total Tumaround Time (FCFS): 9d”, otal TumaroundFCFS); for in = 03 <n; ++) { waitingli] = 0; ) for int i= 0: <n- 1; #09) { for (nj =i + 13j < mij) | if burst] > burst[j]) { int tempBurst = burst: burs] = burs: burs] = tempBurst; int tempAival = anivalfil arivall] = arrival; arivall] = tempArival; ) ) ) for in = <n; i++) { waiting(i] = waitngfi - 1] + burs - 11; ) for in = 03 <n; ++) { ‘wmaround(i] = waiting] + burs il; ) print(\"n—— SIF Scheduling i\"); print \"Process't Arrival\\t Burst iW aiting { Tumaroundin”): for (int = 0: <n: iH) |",
          "reading_order": 1,
          "pageNumber": 5
        }
      ]
    },
    {
      "pageNumber": 6,
      "processingTime": 2.05,
      "sourceImagePath": "temp_images\\page-06.png",
      "annotatedImagePath": "output\\annotated_frames\\page_6_annotated.png",
      "imageWidth": 725,
      "imageHeight": 1024,
      "detectionsCount": 3,
      "detections": [
        {
          "id": "page6_detection2",
          "bbox": [
            83,
            96,
            539,
            299
          ],
          "bbox_normalized": [
            0.1145,
            0.0938,
            0.7434,
            0.292
          ],
          "label": "Text",
          "confidence": 0.916,
          "area": 92568,
          "center": [
            311,
            198
          ],
          "width": 456,
          "height": 203,
          "extractedText": "printf\" %dt%dt%d\\t%d\\t%d\\n\", 1+ 1, arrival[i], bursti), waiting] 1}, tumaround]i]); } int otalWaitingS JF =, total TumaroundSJF = 0; for (nti =0:i <n: #4) | total WaitingSJF += wating[i]; total TumaroundS JF += tumaround(if} printf \"Total Waiting Time (SJF): %dn\", totalWaitingSJF): printf \"Total Turnaround Time (SIF): %din”, ota TumaroundSJF): retum 0;",
          "reading_order": 1,
          "pageNumber": 6
        },
        {
          "id": "page6_detection3",
          "bbox": [
            81,
            318,
            136,
            335
          ],
          "bbox_normalized": [
            0.1117,
            0.3105,
            0.1876,
            0.3271
          ],
          "label": "Section-header",
          "confidence": 0.736,
          "area": 935,
          "center": [
            109,
            327
          ],
          "width": 55,
          "height": 17,
          "extractedText": "Output:",
          "reading_order": 2,
          "pageNumber": 6
        },
        {
          "id": "page6_detection1",
          "bbox": [
            90,
            345,
            563,
            681
          ],
          "bbox_normalized": [
            0.1241,
            0.3369,
            0.7766,
            0.665
          ],
          "label": "Text",
          "confidence": 0.923,
          "area": 158928,
          "center": [
            327,
            513
          ],
          "width": 473,
          "height": 336,
          "extractedText": "PS D: Viesang\\h) AlFSivoice-segregation\\Smart Farm\\smart-fam cd \"ds \\Hemang\\h) ATS os} Enter. rumber of processes: 4 Enter arrival tim and burst time for process 1: 14 Enter arrival time and burst time for process 2: 2 5 Enter arrival time and burst time for process 3: 3 1 Enter arrival time and burst time for process 4: 4 6 Process Arrival rst Waiting Turnaround 11 4 oe a 2 2 sae 303 1 sw CE Total iting Time (iF): 23 Total Turnaround Time (FCFS): 3 ~-- SIF scheduling Process Arrival Burst baiting Turnaround 13 1 oe a 2 1 4 1s 32 ss ow EN Total waiting Time (536): 16 Total Turnaround Time (SIF): 32 n",
          "reading_order": 3,
          "pageNumber": 6
        }
      ]
    },
    {
      "pageNumber": 7,
      "processingTime": 2.32,
      "sourceImagePath": "temp_images\\page-07.png",
      "annotatedImagePath": "output\\annotated_frames\\page_7_annotated.png",
      "imageWidth": 725,
      "imageHeight": 1024,
      "detectionsCount": 9,
      "detections": [
        {
          "id": "page7_detection8",
          "bbox": [
            309,
            93,
            421,
            114
          ],
          "bbox_normalized": [
            0.4262,
            0.0908,
            0.5807,
            0.1113
          ],
          "label": "Section-header",
          "confidence": 0.657,
          "area": 2352,
          "center": [
            365,
            104
          ],
          "width": 112,
          "height": 21,
          "extractedText": "Experiment -2",
          "reading_order": 1,
          "pageNumber": 7
        },
        {
          "id": "page7_detection4",
          "bbox": [
            81,
            155,
            641,
            195
          ],
          "bbox_normalized": [
            0.1117,
            0.1514,
            0.8841,
            0.1904
          ],
          "label": "Text",
          "confidence": 0.926,
          "area": 22400,
          "center": [
            361,
            175
          ],
          "width": 560,
          "height": 40,
          "extractedText": "Aim: Write a C program to simulate the following preemptive CPU scheduling algorithms to find turnaround time and waiting time for a given problem. a) Round Robin b) Priority",
          "reading_order": 2,
          "pageNumber": 7
        },
        {
          "id": "page7_detection7",
          "bbox": [
            81,
            220,
            167,
            239
          ],
          "bbox_normalized": [
            0.1117,
            0.2148,
            0.2303,
            0.2334
          ],
          "label": "Section-header",
          "confidence": 0.683,
          "area": 1634,
          "center": [
            124,
            230
          ],
          "width": 86,
          "height": 19,
          "extractedText": "Description:",
          "reading_order": 3,
          "pageNumber": 7
        },
        {
          "id": "page7_detection1",
          "bbox": [
            80,
            255,
            648,
            323
          ],
          "bbox_normalized": [
            0.1103,
            0.249,
            0.8938,
            0.3154
          ],
          "label": "Text",
          "confidence": 0.952,
          "area": 38624,
          "center": [
            364,
            289
          ],
          "width": 568,
          "height": 68,
          "extractedText": "Round Robin (RR): The Round Robin (RR) scheduling algorithm assigns a fixed time quantum (or time slice) to each process ina cyclic order. Each process is given a small portion of CPU time in a round-robin manner. If a process does not finish execution within its time slice, it is placed back in the queue for another tum. This continues until all processes are completed.",
          "reading_order": 4,
          "pageNumber": 7
        },
        {
          "id": "page7_detection2",
          "bbox": [
            81,
            338,
            646,
            407
          ],
          "bbox_normalized": [
            0.1117,
            0.3301,
            0.891,
            0.3975
          ],
          "label": "Text",
          "confidence": 0.945,
          "area": 38985,
          "center": [
            364,
            373
          ],
          "width": 565,
          "height": 69,
          "extractedText": "Priority Scheduling: Priority Scheduling assigns priorities to processes, where a higher priority value indicates a higher priority for execution. In the preemptive version of this algorithm, a process with a higher priority can preempt a currently inning process, meaning the currently running process may be interrupted if a new process with a higher priority arrives.",
          "reading_order": 5,
          "pageNumber": 7
        },
        {
          "id": "page7_detection6",
          "bbox": [
            81,
            424,
            144,
            443
          ],
          "bbox_normalized": [
            0.1117,
            0.4141,
            0.1986,
            0.4326
          ],
          "label": "Section-header",
          "confidence": 0.7,
          "area": 1197,
          "center": [
            113,
            434
          ],
          "width": 63,
          "height": 19,
          "extractedText": "Theory:",
          "reading_order": 6,
          "pageNumber": 7
        },
        {
          "id": "page7_detection5",
          "bbox": [
            80,
            459,
            640,
            528
          ],
          "bbox_normalized": [
            0.1103,
            0.4482,
            0.8828,
            0.5156
          ],
          "label": "Text",
          "confidence": 0.86,
          "area": 38640,
          "center": [
            360,
            494
          ],
          "width": 560,
          "height": 69,
          "extractedText": "Round Robin Scheduling: The process that gets the CPU for a time quantum and does not finish in that quantum is put back into the ready queue, while the next process gets executed. The round-robin algorithm is fair but can result in high turnaround time if processes have large burst times compared to the time quantum.",
          "reading_order": 7,
          "pageNumber": 7
        },
        {
          "id": "page7_detection3",
          "bbox": [
            80,
            543,
            632,
            596
          ],
          "bbox_normalized": [
            0.1103,
            0.5303,
            0.8717,
            0.582
          ],
          "label": "Text",
          "confidence": 0.939,
          "area": 29256,
          "center": [
            356,
            570
          ],
          "width": 552,
          "height": 53,
          "extractedText": "Priority Scheduling: In preemptive priority scheduling, the process with the highest priority (numerically lower value) gets the CPU. If a new process with higher priority arrives while another process is running, the current process is preempted, and the new process is executed.",
          "reading_order": 8,
          "pageNumber": 7
        },
        {
          "id": "page7_detection9",
          "bbox": [
            82,
            642,
            417,
            995
          ],
          "bbox_normalized": [
            0.1131,
            0.627,
            0.5752,
            0.9717
          ],
          "label": "Text",
          "confidence": 0.613,
          "area": 118255,
          "center": [
            250,
            819
          ],
          "width": 335,
          "height": 353,
          "extractedText": "finclude <sidio > truct Process | int id: int burst; int arival; int remaining Burs; int waiting, int wmarounds int priority; : void roundR obinstruct Process proc], int, int time Quantum) | int otalTime =0: int completed = 0; inti; int oWaiting = 0, total Tumaround = 0; while (completed <1) { for (i=0; i< m i++) {",
          "reading_order": 9,
          "pageNumber": 7
        }
      ]
    },
    {
      "pageNumber": 8,
      "processingTime": 1.62,
      "sourceImagePath": "temp_images\\page-08.png",
      "annotatedImagePath": "output\\annotated_frames\\page_8_annotated.png",
      "imageWidth": 725,
      "imageHeight": 1024,
      "detectionsCount": 1,
      "detections": [
        {
          "id": "page8_detection1",
          "bbox": [
            79,
            94,
            576,
            995
          ],
          "bbox_normalized": [
            0.109,
            0.0918,
            0.7945,
            0.9717
          ],
          "label": "Text",
          "confidence": 0.706,
          "area": 447797,
          "center": [
            328,
            545
          ],
          "width": 497,
          "height": 901,
          "extractedText": "if (proc{i].remainingBurst > 0) { if (rocli] remainingBurst > timeQuantum) { totalTime += time Quantu; proc] remaining Burst — time Quantum; else { totalTime +— proc{i] remainingBurst: procli] waiting = totalTime - procfi] burst, procli]umaround = procfi] waiting + proc|i] burst totalWaiting += proc{i] waiting: totalTumaround + procfi] umaround; procli] remaining Burst = 0; completed-+; ) ) ) ) printf(\"nRound Robin Schedulingin’): printf(\"Process Burs Waiting Tumaroundin\"): for(i=0ri< ms i+) { printf\" t%d 2d 81%dn’. proc. id. proc) burst, proc] waiting. proc(i]tumaround): ) printf(\" Average Waiting Time: %2fn\", (float total Waiting / 1): printf(\" Average Tumaround Time: %. 20\", (float)otal Turnaround /n): ) void priority Scheduling(struct Process proc{], int 1) { int otalTime = 0; int completed = 0; inti; int totalWaiting = 0, total Tamaround = 0; int highestPrioritylds: while (completed < ) { highestPriortyldx = -1; int highestPriority 9999: for(i =0:i< m i++) { if (proc]i].remining Burst > 0 && prac] priority < highestPriority) { highestPriority proc(i. priority; highestPriorityldx =i; ) ) if (highestPriorityldx 1=-1) { total Time + proc{highestPriorityld] remainingBurst: procihighestPriorityldx] waiting ~ total Time - proc[highestPriorityldx] burst prochighestPriorityldx] tumaround proc highestPriorityldx waiting + procihighestPriorityldx] burst; total Waiting += proc highestPriority ld] waiting; total Tumaround += prac[highestPriorityldx] turnaround; procihighestPriorityldx] remaining Burst = 0;",
          "reading_order": 1,
          "pageNumber": 8
        }
      ]
    },
    {
      "pageNumber": 9,
      "processingTime": 1.18,
      "sourceImagePath": "temp_images\\page-09.png",
      "annotatedImagePath": "output\\annotated_frames\\page_9_annotated.png",
      "imageWidth": 725,
      "imageHeight": 1024,
      "detectionsCount": 1,
      "detections": [
        {
          "id": "page9_detection1",
          "bbox": [
            80,
            94,
            585,
            837
          ],
          "bbox_normalized": [
            0.1103,
            0.0918,
            0.8069,
            0.8174
          ],
          "label": "Text",
          "confidence": 0.901,
          "area": 375215,
          "center": [
            333,
            466
          ],
          "width": 505,
          "height": 743,
          "extractedText": "completed++; ) ) printf(\"nPriority Schedulingn\"): printf(\"Processi Priority tBurs( Waiting Turnaround\\n\"): for(i=0ri< mi) { printf\" did 4% %d 02d\", proc id, proc{il priority, proc burst, procli] waiting, proc(i] tumaround); ) printf(\" Average Waiting Time: %2fn\", (float total Waiting / 1): printf(\" Average Tumaround Time: %. 20\", (float)otal Turnaround /n): ] int main() { int n, timeQuantum; printf(\"Enter number of processes: ); scanf(\"%d\", &n): struct Process proc[n; for (inti = 0; i <n; 44) | printf{\"Enter arrival time, burst time and priority for process %d:\". i + 1); scanf{\"%d %d %d\", &proc[i] rival, profi] burst, &procfi] priority); proc(ilid=i+ 1; proc(i] remaining Burst proc[i] burst proc(i] waiting = 0; procfi]tumaround = 0; ) printf(\"Enter time quantum for Round Robin: \"), scanf(\" 4d\", &time Quantum): roundRobin(proc, n, time Quantum): for (inti = 0; i< n: 44) | proc(i] remaining Burst = proc[i] burst ) priorityScheduling(proc, n); retum 0; y",
          "reading_order": 1,
          "pageNumber": 9
        }
      ]
    },
    {
      "pageNumber": 10,
      "processingTime": 1.65,
      "sourceImagePath": "temp_images\\page-10.png",
      "annotatedImagePath": "output\\annotated_frames\\page_10_annotated.png",
      "imageWidth": 725,
      "imageHeight": 1024,
      "detectionsCount": 2,
      "detections": [
        {
          "id": "page10_detection2",
          "bbox": [
            89,
            97,
            142,
            110
          ],
          "bbox_normalized": [
            0.1228,
            0.0947,
            0.1959,
            0.1074
          ],
          "label": "Section-header",
          "confidence": 0.573,
          "area": 689,
          "center": [
            116,
            104
          ],
          "width": 53,
          "height": 13,
          "extractedText": "vuiput:",
          "reading_order": 1,
          "pageNumber": 10
        },
        {
          "id": "page10_detection1",
          "bbox": [
            91,
            121,
            516,
            520
          ],
          "bbox_normalized": [
            0.1255,
            0.1182,
            0.7117,
            0.5078
          ],
          "label": "Text",
          "confidence": 0.631,
          "area": 169575,
          "center": [
            304,
            321
          ],
          "width": 425,
          "height": 399,
          "extractedText": "-\\os-2 } Enter musber of processes: 4 Enter arrival time, burst time and priority for process 1: 13 1 Enter arrival tise, burst time and priority for process 2: 24 5 Enter arrival tise, burst time and priority for process 3: 3 6 2 Enter arrival tie, burst time and priority for process 4: 4 2 3 Enter time quantum for Round Robin: 2 Round Robin Scheduling Process Burst Waiting Turnaround 1 3 6 9 2 a 7 1u 3 6 9 15 a 2 6 8 Average Waiting Time: 7.00 Average Turnaround Tie: 10.75 priority scheduling Process Priority Burst Waiting Turnaround 1 1 3 0) 3 2 5 a un 15 3 2 6 3 B a H 2 ° nu Average Waiting Time: 5.75 Average Turnaround Time: 9.50 ~",
          "reading_order": 2,
          "pageNumber": 10
        }
      ]
    },
    {
      "pageNumber": 11,
      "processingTime": 2.45,
      "sourceImagePath": "temp_images\\page-11.png",
      "annotatedImagePath": "output\\annotated_frames\\page_11_annotated.png",
      "imageWidth": 725,
      "imageHeight": 1024,
      "detectionsCount": 14,
      "detections": [
        {
          "id": "page11_detection14",
          "bbox": [
            309,
            94,
            421,
            115
          ],
          "bbox_normalized": [
            0.4262,
            0.0918,
            0.5807,
            0.1123
          ],
          "label": "Section-header",
          "confidence": 0.63,
          "area": 2352,
          "center": [
            365,
            105
          ],
          "width": 112,
          "height": 21,
          "extractedText": "Experiment -3",
          "reading_order": 1,
          "pageNumber": 11
        },
        {
          "id": "page11_detection12",
          "bbox": [
            81,
            177,
            269,
            196
          ],
          "bbox_normalized": [
            0.1117,
            0.1729,
            0.371,
            0.1914
          ],
          "label": "Text",
          "confidence": 0.664,
          "area": 3572,
          "center": [
            175,
            187
          ],
          "width": 188,
          "height": 19,
          "extractedText": "Worst fit, b) Best fit, ¢) First fit",
          "reading_order": 2,
          "pageNumber": 11
        },
        {
          "id": "page11_detection10",
          "bbox": [
            81,
            221,
            167,
            241
          ],
          "bbox_normalized": [
            0.1117,
            0.2158,
            0.2303,
            0.2354
          ],
          "label": "Section-header",
          "confidence": 0.806,
          "area": 1720,
          "center": [
            124,
            231
          ],
          "width": 86,
          "height": 20,
          "extractedText": "Description:",
          "reading_order": 3,
          "pageNumber": 11
        },
        {
          "id": "page11_detection3",
          "bbox": [
            81,
            256,
            651,
            324
          ],
          "bbox_normalized": [
            0.1117,
            0.25,
            0.8979,
            0.3164
          ],
          "label": "Text",
          "confidence": 0.975,
          "area": 38760,
          "center": [
            366,
            290
          ],
          "width": 570,
          "height": 68,
          "extractedText": "In contiguous memory allocation, the operating system assigns a single contiguous block of memory to each process. The three different allocation strategies (Worst fit, Best fit, First fit) detemine how memory is assigned. Each algorithm has its own method of selecting the memory block, with trade-offs in efficiency and the way memory is utilized.",
          "reading_order": 4,
          "pageNumber": 11
        },
        {
          "id": "page11_detection5",
          "bbox": [
            103,
            339,
            628,
            392
          ],
          "bbox_normalized": [
            0.1421,
            0.3311,
            0.8662,
            0.3828
          ],
          "label": "List-item",
          "confidence": 0.968,
          "area": 27825,
          "center": [
            366,
            366
          ],
          "width": 525,
          "height": 53,
          "extractedText": "1. Worst Fit: This algorithm chooses the block of memory that is the largest among all available blocks. This is done under the assumption that leaving large gaps will leave space for future processes.",
          "reading_order": 5,
          "pageNumber": 11
        },
        {
          "id": "page11_detection1",
          "bbox": [
            103,
            389,
            645,
            426
          ],
          "bbox_normalized": [
            0.1421,
            0.3799,
            0.8897,
            0.416
          ],
          "label": "List-item",
          "confidence": 0.976,
          "area": 20054,
          "center": [
            374,
            408
          ],
          "width": 542,
          "height": 37,
          "extractedText": "2. Best Fit: This algorithm selects the smallest block that is large enough to fit the process, ‘minimizing the leftover unused space in memory.",
          "reading_order": 6,
          "pageNumber": 11
        },
        {
          "id": "page11_detection6",
          "bbox": [
            102,
            424,
            636,
            460
          ],
          "bbox_normalized": [
            0.1407,
            0.4141,
            0.8772,
            0.4492
          ],
          "label": "List-item",
          "confidence": 0.961,
          "area": 19224,
          "center": [
            369,
            442
          ],
          "width": 534,
          "height": 36,
          "extractedText": "3. First Fit: This algorithm assigns the first block of memory that is large enough for the process, which is simple and fast but may leave smaller gaps in memory.",
          "reading_order": 7,
          "pageNumber": 11
        },
        {
          "id": "page11_detection9",
          "bbox": [
            81,
            491,
            144,
            512
          ],
          "bbox_normalized": [
            0.1117,
            0.4795,
            0.1986,
            0.5
          ],
          "label": "Section-header",
          "confidence": 0.861,
          "area": 1323,
          "center": [
            113,
            502
          ],
          "width": 63,
          "height": 21,
          "extractedText": "Theory:",
          "reading_order": 8,
          "pageNumber": 11
        },
        {
          "id": "page11_detection4",
          "bbox": [
            81,
            528,
            641,
            579
          ],
          "bbox_normalized": [
            0.1117,
            0.5156,
            0.8841,
            0.5654
          ],
          "label": "Text",
          "confidence": 0.969,
          "area": 28560,
          "center": [
            361,
            554
          ],
          "width": 560,
          "height": 51,
          "extractedText": "0 Memory Fragmentation: Over time, as processes are loaded and removed, free memory is split into smaller and smaller blocks. This can lead to internal fragmentation (unused space within allocated blocks) and external fragmentation (unused memory between blocks).",
          "reading_order": 9,
          "pageNumber": 11
        },
        {
          "id": "page11_detection7",
          "bbox": [
            81,
            595,
            593,
            631
          ],
          "bbox_normalized": [
            0.1117,
            0.5811,
            0.8179,
            0.6162
          ],
          "label": "Text",
          "confidence": 0.952,
          "area": 18432,
          "center": [
            337,
            613
          ],
          "width": 512,
          "height": 36,
          "extractedText": "11 Contiguous Memory Allocation: In this scheme, cach process is allocated a single continuous block of memory.",
          "reading_order": 10,
          "pageNumber": 11
        },
        {
          "id": "page11_detection2",
          "bbox": [
            81,
            645,
            630,
            698
          ],
          "bbox_normalized": [
            0.1117,
            0.6299,
            0.869,
            0.6816
          ],
          "label": "Text",
          "confidence": 0.975,
          "area": 29097,
          "center": [
            356,
            672
          ],
          "width": 549,
          "height": 53,
          "extractedText": "0 Memory Allocation Algorithms: The three algorithms help in minimizing fragmentation and efficiently allocating memory, but they have different ways of selecting which block to assign toa Process.",
          "reading_order": 11,
          "pageNumber": 11
        },
        {
          "id": "page11_detection11",
          "bbox": [
            81,
            713,
            124,
            733
          ],
          "bbox_normalized": [
            0.1117,
            0.6963,
            0.171,
            0.7158
          ],
          "label": "Section-header",
          "confidence": 0.742,
          "area": 860,
          "center": [
            103,
            723
          ],
          "width": 43,
          "height": 20,
          "extractedText": "Code:",
          "reading_order": 12,
          "pageNumber": 11
        },
        {
          "id": "page11_detection13",
          "bbox": [
            81,
            733,
            179,
            751
          ],
          "bbox_normalized": [
            0.1117,
            0.7158,
            0.2469,
            0.7334
          ],
          "label": "Text",
          "confidence": 0.633,
          "area": 1764,
          "center": [
            130,
            742
          ],
          "width": 98,
          "height": 18,
          "extractedText": "#include <stdio.h>",
          "reading_order": 13,
          "pageNumber": 11
        },
        {
          "id": "page11_detection8",
          "bbox": [
            81,
            769,
            439,
            993
          ],
          "bbox_normalized": [
            0.1117,
            0.751,
            0.6055,
            0.9697
          ],
          "label": "Text",
          "confidence": 0.903,
          "area": 80192,
          "center": [
            260,
            881
          ],
          "width": 358,
          "height": 224,
          "extractedText": "void worstFit(int blockSize[], int m, int processSize{], int n) { int allocation(n]: for (inti = 0: 1 #4) | allocation[i] =-1 } for (inti = 0: i< #4) | int maxlndex =-1: for (nt = 05] <mzj+) if (blockSizej] > processSizefi]) | if (maxlndex = -1 | BlockSizelj] > bockSizelmaxindex) | ‘maxindex =f; )",
          "reading_order": 14,
          "pageNumber": 11
        }
      ]
    },
    {
      "pageNumber": 12,
      "processingTime": 1.33,
      "sourceImagePath": "temp_images\\page-12.png",
      "annotatedImagePath": "output\\annotated_frames\\page_12_annotated.png",
      "imageWidth": 725,
      "imageHeight": 1024,
      "detectionsCount": 1,
      "detections": [
        {
          "id": "page12_detection1",
          "bbox": [
            80,
            97,
            615,
            997
          ],
          "bbox_normalized": [
            0.1103,
            0.0947,
            0.8483,
            0.9736
          ],
          "label": "Text",
          "confidence": 0.945,
          "area": 481500,
          "center": [
            348,
            547
          ],
          "width": 535,
          "height": 900,
          "extractedText": "i } if (maxindex 1=-1) { allocaioni] = maxindex; blockSize[maxndex] = processSizeliJ: } } printf(\"nWarst Fit Allocation'n\"): printf(\"Process No. Process Size Black No.tBlack Sizeln'); for (inti = 0: i< #4) | if allocatonfi] =-1) PAR CAA %d An\", + 1. processSize[i. allocationf] + 1, blockSize allocation]: else PrABA\" 9d 4% Not Allocated i+ 1, processSizell): } ] void bestFiint lockSize], int m, int processSizel], nt) { int allocation(n]: for (inti = 0: 1< #4) | allocation[i] =-1 } for (inti = 0: i< #4) | int bestindex =-15 for (nt = 05] <mzj+) if (blockSizej] >= processSizefil) { if (bestindex —-1 | blockSiz(j] < blockSize{bestindex]) | bastindex =; } } } if (estindex 1= 1) { allocationfi] = bestindex: blockSizelbestindex] = processSizeli; } } printf(\"nBest Fit Allocation’); printf(\"Process No. Process Size Black No.tBlack Sizeln'); for (inti = 0: 1< #4) | if allocationfi] =-1) PAR CAA %d An\", + 1. processSize[i. allocationf] + 1, blockSize allocation]: else PrABA\" 9d 4% Not Allocated i+ 1, processSizell): } ] void firstFit(int blockSize[], int m, int pracessSize[], it n) {",
          "reading_order": 1,
          "pageNumber": 12
        }
      ]
    },
    {
      "pageNumber": 13,
      "processingTime": 1.14,
      "sourceImagePath": "temp_images\\page-13.png",
      "annotatedImagePath": "output\\annotated_frames\\page_13_annotated.png",
      "imageWidth": 725,
      "imageHeight": 1024,
      "detectionsCount": 1,
      "detections": [
        {
          "id": "page13_detection1",
          "bbox": [
            80,
            90,
            614,
            992
          ],
          "bbox_normalized": [
            0.1103,
            0.0879,
            0.8469,
            0.9688
          ],
          "label": "Text",
          "confidence": 0.941,
          "area": 481668,
          "center": [
            347,
            541
          ],
          "width": 534,
          "height": 902,
          "extractedText": "int allocation]; for (inti = 0: 1 #4) | allocationfi] =-1: ) for (inti = 0:1 < #4) | for (nt = 05] < mz) if (blockSizej] >= processSizefil) { allocationfi] = J; blockSizelj] = processSizel; break; ) ) ) printf(\"nFirst Fit Allocationn\"): printf(\"Process No. Process Size! Block No Block Sizeln\"): for (inti = 0: i< #4) | if allocation(i] 1=-1) PHB\" %d CAAA An\", + 1. processSize[i. allocationfi] + 1. blockSizelallocatonfi): ele printf\" 4d 4% Not Allocatedn’, i + 1, processSizeli); ) ] int main() { int m,n; printf(\"Enter the number of memory blocks: ); scanf(\" id\", &m); int blockSize[m]: printf(\"Enter the sizes of memory blacks: \"): for (inti = 0: i< m: i++) { scanf{\"%d\", &blockSizeli); ) printf(\"Enter the number of processes: \"), scanf(\"%d\", &n): int processSizefnl; printf(\"Enter the sizes of processes: \"); for (inti = 0: i< #4) | scanf{\"%d\", &processSizefi]): ) worstFit(blockSize, m, processSize, nf. bestFit(block Size, m, processSize, n); firsFit(blockSize, m, processSize, n): retum 0; N",
          "reading_order": 1,
          "pageNumber": 13
        }
      ]
    },
    {
      "pageNumber": 14,
      "processingTime": 0.48,
      "sourceImagePath": "temp_images\\page-14.png",
      "annotatedImagePath": "output\\annotated_frames\\page_14_annotated.png",
      "imageWidth": 725,
      "imageHeight": 1024,
      "detectionsCount": 1,
      "detections": [
        {
          "id": "page14_detection1",
          "bbox": [
            88,
            141,
            142,
            155
          ],
          "bbox_normalized": [
            0.1214,
            0.1377,
            0.1959,
            0.1514
          ],
          "label": "Section-header",
          "confidence": 0.755,
          "area": 756,
          "center": [
            115,
            148
          ],
          "width": 54,
          "height": 14,
          "extractedText": "Output:",
          "reading_order": 1,
          "pageNumber": 14
        }
      ]
    },
    {
      "pageNumber": 15,
      "processingTime": 2.22,
      "sourceImagePath": "temp_images\\page-15.png",
      "annotatedImagePath": "output\\annotated_frames\\page_15_annotated.png",
      "imageWidth": 792,
      "imageHeight": 1024,
      "detectionsCount": 12,
      "detections": [
        {
          "id": "page15_detection12",
          "bbox": [
            334,
            94,
            451,
            116
          ],
          "bbox_normalized": [
            0.4217,
            0.0918,
            0.5694,
            0.1133
          ],
          "label": "Section-header",
          "confidence": 0.611,
          "area": 2574,
          "center": [
            393,
            105
          ],
          "width": 117,
          "height": 22,
          "extractedText": "Experiment -4",
          "reading_order": 1,
          "pageNumber": 15
        },
        {
          "id": "page15_detection6",
          "bbox": [
            105,
            159,
            673,
            203
          ],
          "bbox_normalized": [
            0.1326,
            0.1553,
            0.8497,
            0.1982
          ],
          "label": "Text",
          "confidence": 0.881,
          "area": 24992,
          "center": [
            389,
            181
          ],
          "width": 568,
          "height": 44,
          "extractedText": "Aim: Write a C program to simulate the following file allocation strategies. a) Sequential, b) Indexed",
          "reading_order": 2,
          "pageNumber": 15
        },
        {
          "id": "page15_detection7",
          "bbox": [
            105,
            229,
            192,
            249
          ],
          "bbox_normalized": [
            0.1326,
            0.2236,
            0.2424,
            0.2432
          ],
          "label": "Section-header",
          "confidence": 0.817,
          "area": 1740,
          "center": [
            149,
            239
          ],
          "width": 87,
          "height": 20,
          "extractedText": "Description:",
          "reading_order": 3,
          "pageNumber": 15
        },
        {
          "id": "page15_detection2",
          "bbox": [
            105,
            265,
            676,
            339
          ],
          "bbox_normalized": [
            0.1326,
            0.2588,
            0.8535,
            0.3311
          ],
          "label": "Text",
          "confidence": 0.958,
          "area": 42254,
          "center": [
            391,
            302
          ],
          "width": 571,
          "height": 74,
          "extractedText": "In Sequential Allocation, files are stored in contiguous blocks on the disk. This means that when a file is created, it occupies a series of consecutive disk blocks, allowing for easy and fast sequential access. However, this method can lead to issues like fragmentation when files are deleted, making it harder to find contiguous free space for new files.",
          "reading_order": 4,
          "pageNumber": 15
        },
        {
          "id": "page15_detection3",
          "bbox": [
            105,
            355,
            670,
            446
          ],
          "bbox_normalized": [
            0.1326,
            0.3467,
            0.846,
            0.4355
          ],
          "label": "Text",
          "confidence": 0.955,
          "area": 51415,
          "center": [
            388,
            401
          ],
          "width": 565,
          "height": 91,
          "extractedText": "In Indexed Allocation, each file has an index block that contains pointers to all the disk blocks allocated to that file. This allows non-contiguous allocation of files, which can lead 0 better utilization of disk space. While accessing a file may require an additional read to get the index block, it significantly reduces fragmentation and allows for efficient file management.",
          "reading_order": 5,
          "pageNumber": 15
        },
        {
          "id": "page15_detection5",
          "bbox": [
            105,
            498,
            670,
            554
          ],
          "bbox_normalized": [
            0.1326,
            0.4863,
            0.846,
            0.541
          ],
          "label": "Text",
          "confidence": 0.941,
          "area": 31640,
          "center": [
            388,
            526
          ],
          "width": 565,
          "height": 56,
          "extractedText": "71 File Allocation: The method by which files are stored in memory and how they are accessed by the operating system. Effective file allocation is essential for maximizing disk utilization and minimizing access time.",
          "reading_order": 6,
          "pageNumber": 15
        },
        {
          "id": "page15_detection4",
          "bbox": [
            105,
            570,
            661,
            607
          ],
          "bbox_normalized": [
            0.1326,
            0.5566,
            0.8346,
            0.5928
          ],
          "label": "Text",
          "confidence": 0.947,
          "area": 20572,
          "center": [
            383,
            589
          ],
          "width": 556,
          "height": 37,
          "extractedText": "| Sequential Allocation: Stores files in a contiguous manner, leading to fast access but potential fragmentation issues.",
          "reading_order": 7,
          "pageNumber": 15
        },
        {
          "id": "page15_detection1",
          "bbox": [
            105,
            624,
            655,
            679
          ],
          "bbox_normalized": [
            0.1326,
            0.6094,
            0.827,
            0.6631
          ],
          "label": "Text",
          "confidence": 0.959,
          "area": 30250,
          "center": [
            380,
            652
          ],
          "width": 550,
          "height": 55,
          "extractedText": "J Indexed Allocation: Uses an index to track file blocks, allowing for non-contiguous storage and better space utilization, though it may introduce overhead due to additional reads.",
          "reading_order": 8,
          "pageNumber": 15
        },
        {
          "id": "page15_detection8",
          "bbox": [
            109,
            695,
            156,
            718
          ],
          "bbox_normalized": [
            0.1376,
            0.6787,
            0.197,
            0.7012
          ],
          "label": "Section-header",
          "confidence": 0.8,
          "area": 1081,
          "center": [
            133,
            707
          ],
          "width": 47,
          "height": 23,
          "extractedText": "Code:",
          "reading_order": 9,
          "pageNumber": 15
        },
        {
          "id": "page15_detection9",
          "bbox": [
            106,
            719,
            207,
            735
          ],
          "bbox_normalized": [
            0.1338,
            0.7021,
            0.2614,
            0.7178
          ],
          "label": "Text",
          "confidence": 0.79,
          "area": 1616,
          "center": [
            157,
            727
          ],
          "width": 101,
          "height": 16,
          "extractedText": "#include <stdio.h>",
          "reading_order": 10,
          "pageNumber": 15
        },
        {
          "id": "page15_detection10",
          "bbox": [
            106,
            755,
            443,
            936
          ],
          "bbox_normalized": [
            0.1338,
            0.7373,
            0.5593,
            0.9141
          ],
          "label": "Text",
          "confidence": 0.782,
          "area": 60997,
          "center": [
            275,
            846
          ],
          "width": 337,
          "height": 181,
          "extractedText": "void sequential Allocation(int fileSizes[], int n, int blockSize) { int allocated[r); for (inti = 0; <n; i+) { if (blockSize >= fileSizesfi]) { allocated[i] = 1; lockSize -= fileSizesli); else { allocated[i] 0; ’ ¥",
          "reading_order": 11,
          "pageNumber": 15
        },
        {
          "id": "page15_detection11",
          "bbox": [
            118,
            958,
            345,
            993
          ],
          "bbox_normalized": [
            0.149,
            0.9355,
            0.4356,
            0.9697
          ],
          "label": "Text",
          "confidence": 0.613,
          "area": 7945,
          "center": [
            232,
            976
          ],
          "width": 227,
          "height": 35,
          "extractedText": "printf\" nSequential Allocation'n\"); orintf(\"File No.\\tFile Size'tAllocated\\n\"):",
          "reading_order": 12,
          "pageNumber": 15
        }
      ]
    },
    {
      "pageNumber": 16,
      "processingTime": 1.08,
      "sourceImagePath": "temp_images\\page-16.png",
      "annotatedImagePath": "output\\annotated_frames\\page_16_annotated.png",
      "imageWidth": 792,
      "imageHeight": 1024,
      "detectionsCount": 1,
      "detections": [
        {
          "id": "page16_detection1",
          "bbox": [
            104,
            94,
            532,
            756
          ],
          "bbox_normalized": [
            0.1313,
            0.0918,
            0.6717,
            0.7383
          ],
          "label": "Text",
          "confidence": 0.929,
          "area": 283336,
          "center": [
            318,
            425
          ],
          "width": 428,
          "height": 662,
          "extractedText": "for (inti =0;i <n; i+) { printf \"odd sin\", i + 1, fleSizesfi], allocated[i] ? \"Yes\" : \"Nof); ’ } void indexedAllocation(int fileSizes[), int n) { int index(n]; printf(\"nindexed Allocation'n’); printf(\"File No tFile Size'tIndex Block\\n\"); for (inti = 0; <n; 1+) { index[i) =i * 5; // Example index block position printf \"od dod”, i + 1, fileSizes(i). index(i]); ’ } int main() { int; printf(\"Enter the number of files: \"); scanfi\"%d\", &n); int fileSizes[n); printf(\"Enter the sizes of the files: \"); for (inti = 0; <m; i+) { seanf(\"%%d\", &fleSizes(il); ’ int blockSize; printf(\"Enter the total size of the disk block: ); scanfi\"Vd\", &eblockSize); sequentialAllocation(fileSizes, n, blockSize); indexedAllocation(fileSizes, n); retum 0; }",
          "reading_order": 1,
          "pageNumber": 16
        }
      ]
    },
    {
      "pageNumber": 17,
      "processingTime": 1.3,
      "sourceImagePath": "temp_images\\page-17.png",
      "annotatedImagePath": "output\\annotated_frames\\page_17_annotated.png",
      "imageWidth": 792,
      "imageHeight": 1024,
      "detectionsCount": 2,
      "detections": [
        {
          "id": "page17_detection1",
          "bbox": [
            111,
            95,
            169,
            112
          ],
          "bbox_normalized": [
            0.1402,
            0.0928,
            0.2134,
            0.1094
          ],
          "label": "Section-header",
          "confidence": 0.738,
          "area": 986,
          "center": [
            140,
            104
          ],
          "width": 58,
          "height": 17,
          "extractedText": "Output:",
          "reading_order": 1,
          "pageNumber": 17
        },
        {
          "id": "page17_detection2",
          "bbox": [
            111,
            144,
            674,
            444
          ],
          "bbox_normalized": [
            0.1402,
            0.1406,
            0.851,
            0.4336
          ],
          "label": "Text",
          "confidence": 0.595,
          "area": 168900,
          "center": [
            393,
            294
          ],
          "width": 563,
          "height": 300,
          "extractedText": "Cl a: Vemang\\n) AlN Nos } Enter the number of files: 3 enter the sizes of the files: 50 100 150 enter the total size of the disk block: 300 Sequential Allocation File No. File Size Allocated 1 so Yes 2 100 Yes 3 150 Yes Indexed Allocation File No. File size Index Block 1 0 0 2 100 5 3 150 10 PS D:\\Hemang\\hj AIMS\\voice-segregation\\smart Farm\\smart-farm> |",
          "reading_order": 2,
          "pageNumber": 17
        }
      ]
    },
    {
      "pageNumber": 18,
      "processingTime": 2.38,
      "sourceImagePath": "temp_images\\page-18.png",
      "annotatedImagePath": "output\\annotated_frames\\page_18_annotated.png",
      "imageWidth": 792,
      "imageHeight": 1024,
      "detectionsCount": 10,
      "detections": [
        {
          "id": "page18_detection10",
          "bbox": [
            333,
            94,
            452,
            116
          ],
          "bbox_normalized": [
            0.4205,
            0.0918,
            0.5707,
            0.1133
          ],
          "label": "Section-header",
          "confidence": 0.656,
          "area": 2618,
          "center": [
            393,
            105
          ],
          "width": 119,
          "height": 22,
          "extractedText": "Experiment - 5",
          "reading_order": 1,
          "pageNumber": 18
        },
        {
          "id": "page18_detection2",
          "bbox": [
            104,
            140,
            674,
            183
          ],
          "bbox_normalized": [
            0.1313,
            0.1367,
            0.851,
            0.1787
          ],
          "label": "Text",
          "confidence": 0.958,
          "area": 24510,
          "center": [
            389,
            162
          ],
          "width": 570,
          "height": 43,
          "extractedText": "Aim: Write a C program to simulate Banker's algorithm for the purpose of Deadlock avoidance.",
          "reading_order": 2,
          "pageNumber": 18
        },
        {
          "id": "page18_detection6",
          "bbox": [
            105,
            211,
            188,
            230
          ],
          "bbox_normalized": [
            0.1326,
            0.2061,
            0.2374,
            0.2246
          ],
          "label": "Section-header",
          "confidence": 0.837,
          "area": 1577,
          "center": [
            147,
            221
          ],
          "width": 83,
          "height": 19,
          "extractedText": "Description:",
          "reading_order": 3,
          "pageNumber": 18
        },
        {
          "id": "page18_detection1",
          "bbox": [
            104,
            238,
            683,
            364
          ],
          "bbox_normalized": [
            0.1313,
            0.2324,
            0.8624,
            0.3555
          ],
          "label": "Text",
          "confidence": 0.967,
          "area": 72954,
          "center": [
            394,
            301
          ],
          "width": 579,
          "height": 126,
          "extractedText": "The Banker's algorithm works by simulating the allocation of resources to processes based on their maximum needs and current availability. Each process must declare its maximum resource needs in advance. When a process requests resources, the system checks if granting that request would leave the system in a safe state. Ifthe request can be granted while keeping the system ina safe state, the resources are allocated; otherwise, the process must wait. The algorithm effectively prevents deadlock by ensuring that resource allocation always leads to a safe sequence of execution for the processes.",
          "reading_order": 4,
          "pageNumber": 18
        },
        {
          "id": "page18_detection8",
          "bbox": [
            105,
            391,
            162,
            409
          ],
          "bbox_normalized": [
            0.1326,
            0.3818,
            0.2045,
            0.3994
          ],
          "label": "Section-header",
          "confidence": 0.749,
          "area": 1026,
          "center": [
            134,
            400
          ],
          "width": 57,
          "height": 18,
          "extractedText": "Theory:",
          "reading_order": 5,
          "pageNumber": 18
        },
        {
          "id": "page18_detection5",
          "bbox": [
            105,
            423,
            660,
            461
          ],
          "bbox_normalized": [
            0.1326,
            0.4131,
            0.8333,
            0.4502
          ],
          "label": "Text",
          "confidence": 0.859,
          "area": 21090,
          "center": [
            383,
            442
          ],
          "width": 555,
          "height": 38,
          "extractedText": "| Deadlock: A situation in which two or more processes are unable to proceed because each is waiting for the other to release resources.",
          "reading_order": 6,
          "pageNumber": 18
        },
        {
          "id": "page18_detection7",
          "bbox": [
            105,
            460,
            637,
            497
          ],
          "bbox_normalized": [
            0.1326,
            0.4492,
            0.8043,
            0.4854
          ],
          "label": "Text",
          "confidence": 0.798,
          "area": 19684,
          "center": [
            371,
            479
          ],
          "width": 532,
          "height": 37,
          "extractedText": "71 Safe State: A condition where the system can allocate resources to processes in a manner that guarantees all processes can complete without causing deadlock.",
          "reading_order": 7,
          "pageNumber": 18
        },
        {
          "id": "page18_detection3",
          "bbox": [
            105,
            500,
            675,
            555
          ],
          "bbox_normalized": [
            0.1326,
            0.4883,
            0.8523,
            0.542
          ],
          "label": "Text",
          "confidence": 0.938,
          "area": 31350,
          "center": [
            390,
            528
          ],
          "width": 570,
          "height": 55,
          "extractedText": "I Resource Allocation: The process of assigning available resources to various processes in a system. The Banker's algorithm simulates this allocation while ensuring the system remains in a safe state.",
          "reading_order": 8,
          "pageNumber": 18
        },
        {
          "id": "page18_detection9",
          "bbox": [
            105,
            600,
            207,
            616
          ],
          "bbox_normalized": [
            0.1326,
            0.5859,
            0.2614,
            0.6016
          ],
          "label": "Text",
          "confidence": 0.661,
          "area": 1632,
          "center": [
            156,
            608
          ],
          "width": 102,
          "height": 16,
          "extractedText": "#include <stdio.h>",
          "reading_order": 9,
          "pageNumber": 18
        },
        {
          "id": "page18_detection4",
          "bbox": [
            107,
            636,
            421,
            1005
          ],
          "bbox_normalized": [
            0.1351,
            0.6211,
            0.5316,
            0.9814
          ],
          "label": "Text",
          "confidence": 0.864,
          "area": 115866,
          "center": [
            264,
            821
          ],
          "width": 314,
          "height": 369,
          "extractedText": "nt main() { into, mij; printf(\" Enter number of processes: \"); scanf{\"%d\", &n); printf(\" Enter number of resources: ); seanf{\"%d\", &em); int max{n]fm), allotfn)[m), need[o])[m], avail[m]; printf(\"Enter maximum resources for each process in\") for (i=0:i <n; #4) { printf \"Process %d: \"i + 1); for (j= 0: < mij) | scanfi \"Vd\", &max[i][j]): ’ ’ printf(\"Enter allocated resources for each process-n\"); for (1-0: <n; #4) { printf \"Process %d: *, i + 1);",
          "reading_order": 10,
          "pageNumber": 18
        }
      ]
    },
    {
      "pageNumber": 19,
      "processingTime": 1.09,
      "sourceImagePath": "temp_images\\page-19.png",
      "annotatedImagePath": "output\\annotated_frames\\page_19_annotated.png",
      "imageWidth": 792,
      "imageHeight": 1024,
      "detectionsCount": 1,
      "detections": [
        {
          "id": "page19_detection1",
          "bbox": [
            117,
            93,
            417,
            996
          ],
          "bbox_normalized": [
            0.1477,
            0.0908,
            0.5265,
            0.9727
          ],
          "label": "Text",
          "confidence": 0.935,
          "area": 270900,
          "center": [
            267,
            545
          ],
          "width": 300,
          "height": 903,
          "extractedText": "for (j= 0: <m; j++) { scanfl\"%%d\", &allot[il[il ’ } printf(\" Enter available resources: a\"); for = 0: < mj) { scanf{(\"%d\", &avail[j]); } for (i= 0: < m i++) { for (j= 0: =m; j++) { need(ilfj) = max(il(] - allo); ’ } int finish{n], safeSeq[n], index = 0; for (i=0:i< m i++) { finish[i] = 0; } while (index <n) { int found = 0; for (i= 0: <m; +4) { if (finish[i] == 0) { intj; for (= 0: <m: j++) { if (meed(iJfj] > avail[]) { break: ’ ’ iff =m){ for (= 0;j<m; j++) { avail] += alloti[j: b safeSeqfindex++] =i; fnish[i] = 1; found = 1; ’ ’ ’ if (found == 0) { printf(\"System is not in 2 safe state in”); rem 0; ’ } printf{\"System is in a safe state \\nSafe sequence is: \"); for (i=0;i< mn i++) {",
          "reading_order": 1,
          "pageNumber": 19
        }
      ]
    },
    {
      "pageNumber": 20,
      "processingTime": 1.82,
      "sourceImagePath": "temp_images\\page-20.png",
      "annotatedImagePath": "output\\annotated_frames\\page_20_annotated.png",
      "imageWidth": 792,
      "imageHeight": 1024,
      "detectionsCount": 3,
      "detections": [
        {
          "id": "page20_detection2",
          "bbox": [
            104,
            96,
            292,
            203
          ],
          "bbox_normalized": [
            0.1313,
            0.0938,
            0.3687,
            0.1982
          ],
          "label": "Text",
          "confidence": 0.926,
          "area": 20116,
          "center": [
            198,
            150
          ],
          "width": 188,
          "height": 107,
          "extractedText": "prantfi™d \", safeSeq[i] + 1); ’ printf(\"n\"); retum 0; }",
          "reading_order": 1,
          "pageNumber": 20
        },
        {
          "id": "page20_detection3",
          "bbox": [
            105,
            222,
            159,
            238
          ],
          "bbox_normalized": [
            0.1326,
            0.2168,
            0.2008,
            0.2324
          ],
          "label": "Section-header",
          "confidence": 0.577,
          "area": 864,
          "center": [
            132,
            230
          ],
          "width": 54,
          "height": 16,
          "extractedText": "Output:",
          "reading_order": 2,
          "pageNumber": 20
        },
        {
          "id": "page20_detection1",
          "bbox": [
            106,
            241,
            679,
            583
          ],
          "bbox_normalized": [
            0.1338,
            0.2354,
            0.8573,
            0.5693
          ],
          "label": "Text",
          "confidence": 0.929,
          "area": 195966,
          "center": [
            393,
            412
          ],
          "width": 573,
          "height": 342,
          "extractedText": "PS D:\\Hemang\\h) AIMS\\voice-segregation\\Smart Farm\\smart-farm> cd ~d:\\Hemang\\hj AIMSAv SS } Enter number of processes: 5 Enter number of resources: 3 Enter maximm resources for each process: Process 1: 4.3 2 Process 2: 12 2 Process 3: 5 0 2 Process 4: 22 2 Process 5: 2 3 3 enter allocated resources for each process: Process 1: © 10 Process 2: 20 Process 3: 30 2 Process 4: 211 Process 5: 00 2 Enter available resources: 342 system is in a safe state. safe sequence is: 23451 PS D:\\Hemang\\hj AIMS\\voice-segregation\\smart Farm\\smart-farm> [|",
          "reading_order": 3,
          "pageNumber": 20
        }
      ]
    },
    {
      "pageNumber": 21,
      "processingTime": 2.2,
      "sourceImagePath": "temp_images\\page-21.png",
      "annotatedImagePath": "output\\annotated_frames\\page_21_annotated.png",
      "imageWidth": 725,
      "imageHeight": 1024,
      "detectionsCount": 11,
      "detections": [
        {
          "id": "page21_detection7",
          "bbox": [
            309,
            95,
            421,
            114
          ],
          "bbox_normalized": [
            0.4262,
            0.0928,
            0.5807,
            0.1113
          ],
          "label": "Section-header",
          "confidence": 0.761,
          "area": 2128,
          "center": [
            365,
            105
          ],
          "width": 112,
          "height": 19,
          "extractedText": "Experiment - 6",
          "reading_order": 1,
          "pageNumber": 21
        },
        {
          "id": "page21_detection8",
          "bbox": [
            82,
            156,
            642,
            171
          ],
          "bbox_normalized": [
            0.1131,
            0.1523,
            0.8855,
            0.167
          ],
          "label": "Text",
          "confidence": 0.758,
          "area": 8400,
          "center": [
            362,
            164
          ],
          "width": 560,
          "height": 15,
          "extractedText": "Aim: Write a C program to simulate Banker's algorithm for the purpose of Deadlock prevention",
          "reading_order": 2,
          "pageNumber": 21
        },
        {
          "id": "page21_detection6",
          "bbox": [
            81,
            199,
            166,
            217
          ],
          "bbox_normalized": [
            0.1117,
            0.1943,
            0.229,
            0.2119
          ],
          "label": "Section-header",
          "confidence": 0.843,
          "area": 1530,
          "center": [
            124,
            208
          ],
          "width": 85,
          "height": 18,
          "extractedText": "Description:",
          "reading_order": 3,
          "pageNumber": 21
        },
        {
          "id": "page21_detection1",
          "bbox": [
            81,
            219,
            642,
            365
          ],
          "bbox_normalized": [
            0.1117,
            0.2139,
            0.8855,
            0.3564
          ],
          "label": "Text",
          "confidence": 0.979,
          "area": 81906,
          "center": [
            362,
            292
          ],
          "width": 561,
          "height": 146,
          "extractedText": "The Banker's al gorithm operates by managing resource allocation based on the maximum needs of processes and the currently available resources. When a process requests resources, the algorithm checks whether granting the request would keep the system in a safe state. This is done by simulating the allocation and detemining if all processes can finish with the available resources. If the request can be safely granted, the resources are allocated; otherwise, the process must wait. This method prevents deadlock by ensuring that the system always has a valid sequence of resource allocations that allows all processes to complete.",
          "reading_order": 4,
          "pageNumber": 21
        },
        {
          "id": "page21_detection5",
          "bbox": [
            81,
            392,
            139,
            409
          ],
          "bbox_normalized": [
            0.1117,
            0.3828,
            0.1917,
            0.3994
          ],
          "label": "Section-header",
          "confidence": 0.863,
          "area": 986,
          "center": [
            110,
            401
          ],
          "width": 58,
          "height": 17,
          "extractedText": "Theory:",
          "reading_order": 5,
          "pageNumber": 21
        },
        {
          "id": "page21_detection3",
          "bbox": [
            82,
            411,
            642,
            448
          ],
          "bbox_normalized": [
            0.1131,
            0.4014,
            0.8855,
            0.4375
          ],
          "label": "Text",
          "confidence": 0.926,
          "area": 20720,
          "center": [
            362,
            430
          ],
          "width": 560,
          "height": 37,
          "extractedText": "1 Deadlock: A situation where two or more processes cannot proceed because each 1s waiting for the other to release resources.",
          "reading_order": 6,
          "pageNumber": 21
        },
        {
          "id": "page21_detection4",
          "bbox": [
            80,
            454,
            641,
            492
          ],
          "bbox_normalized": [
            0.1103,
            0.4434,
            0.8841,
            0.4805
          ],
          "label": "Text",
          "confidence": 0.897,
          "area": 21318,
          "center": [
            361,
            473
          ],
          "width": 561,
          "height": 38,
          "extractedText": "II\" Safe State: A condition where resource allocation to processes is such that the system can guarantee that all processes will complete without entering a deadlock.",
          "reading_order": 7,
          "pageNumber": 21
        },
        {
          "id": "page21_detection2",
          "bbox": [
            80,
            497,
            642,
            557
          ],
          "bbox_normalized": [
            0.1103,
            0.4854,
            0.8855,
            0.5439
          ],
          "label": "Text",
          "confidence": 0.931,
          "area": 33720,
          "center": [
            361,
            527
          ],
          "width": 562,
          "height": 60,
          "extractedText": "0 Resource Allocation: The act of distributing available resources to processes. The Banker's algorithm prevents deadlock by ensuring that resources are allocated in a way that maintains a safe state.",
          "reading_order": 8,
          "pageNumber": 21
        },
        {
          "id": "page21_detection11",
          "bbox": [
            86,
            582,
            128,
            603
          ],
          "bbox_normalized": [
            0.1186,
            0.5684,
            0.1766,
            0.5889
          ],
          "label": "Section-header",
          "confidence": 0.671,
          "area": 882,
          "center": [
            107,
            593
          ],
          "width": 42,
          "height": 21,
          "extractedText": "Code:",
          "reading_order": 9,
          "pageNumber": 21
        },
        {
          "id": "page21_detection10",
          "bbox": [
            82,
            603,
            176,
            620
          ],
          "bbox_normalized": [
            0.1131,
            0.5889,
            0.2428,
            0.6055
          ],
          "label": "Text",
          "confidence": 0.695,
          "area": 1598,
          "center": [
            129,
            612
          ],
          "width": 94,
          "height": 17,
          "extractedText": "#include <stdio.h>",
          "reading_order": 10,
          "pageNumber": 21
        },
        {
          "id": "page21_detection9",
          "bbox": [
            85,
            630,
            378,
            1002
          ],
          "bbox_normalized": [
            0.1172,
            0.6152,
            0.5214,
            0.9785
          ],
          "label": "Text",
          "confidence": 0.698,
          "area": 108996,
          "center": [
            232,
            816
          ],
          "width": 293,
          "height": 372,
          "extractedText": "ot main) { intn, mij: printf(\"Enter number of processes: ); scanf(\" Yd\", &n): printf(\"Enter number of resources: \"): scanf(\" id\", &m); int max(n]{m], alloin]fm), need[n][m], avail[m}: printf(\"Enter maximum resources for each process-in\"): for(i=0:i<n; i+) { printf \"Process %d: i + 1) for (=0:j< m+) | scanf(\"%d\", &emax(i][]). ) ) printf(\"Enter allocated resources for each process:in'): for(i=0:i< ni) { printf \"Process %d: i + 1) for (= 0; < mej) {",
          "reading_order": 11,
          "pageNumber": 21
        }
      ]
    },
    {
      "pageNumber": 22,
      "processingTime": 0.93,
      "sourceImagePath": "temp_images\\page-22.png",
      "annotatedImagePath": "output\\annotated_frames\\page_22_annotated.png",
      "imageWidth": 725,
      "imageHeight": 1024,
      "detectionsCount": 1,
      "detections": [
        {
          "id": "page22_detection1",
          "bbox": [
            90,
            95,
            371,
            979
          ],
          "bbox_normalized": [
            0.1241,
            0.0928,
            0.5117,
            0.9561
          ],
          "label": "Text",
          "confidence": 0.926,
          "area": 248404,
          "center": [
            231,
            537
          ],
          "width": 281,
          "height": 884,
          "extractedText": "scanfi\"%d\", &allot[i][j]); ) ) printf(\"Enter available resources:in\"); for (= 0: < mi ++) { scanf(\"%dt, &avail]): ) for(i=0ri< min) | for G=05< mij) | need] = max(il[] - alot: ) ) int finish], safeSecfn]. index = 0: for(i= 05m iv) { finish] = 0: ) while (index <n) { int found = 0; for (1=0;i< m i++) { if (finish{i] = 0) { ints for 1-0: <mi ji) | (nec) > avail] break: ) ) if(G==m) { for(1= 0: <mi jo) avail] += allo: ) safeSeqfindex+] =i: finish] = 1: found= 1; ) ) ) if (found = 0) { print\" System is not in a safe state in\"); rem; ) ) printf(\"System is in a safe state InSafe sequence is: \"); for(i=0ri< mir) | printf\". safeSeafi] + 1): ) printf(\"in\");",
          "reading_order": 1,
          "pageNumber": 22
        }
      ]
    },
    {
      "pageNumber": 23,
      "processingTime": 1.23,
      "sourceImagePath": "temp_images\\page-23.png",
      "annotatedImagePath": "output\\annotated_frames\\page_23_annotated.png",
      "imageWidth": 725,
      "imageHeight": 1024,
      "detectionsCount": 1,
      "detections": [
        {
          "id": "page23_detection1",
          "bbox": [
            97,
            185,
            679,
            516
          ],
          "bbox_normalized": [
            0.1338,
            0.1807,
            0.9366,
            0.5039
          ],
          "label": "Text",
          "confidence": 0.875,
          "area": 192642,
          "center": [
            388,
            351
          ],
          "width": 582,
          "height": 331,
          "extractedText": "PS D:\\Hemang\\hj AIMS\\voice-segregation\\Smart Farm\\smart-farm> cd ~d:iHemanging AIFS \\0s-6 } Enter nusber of processes: 5 Enter number of resources: 3 Enter maximum resources for each process: Process 1: 25 3 Process 2: 32 2 Process 3: 4.0 2 Process 4: 22 2 Process 5: 3 3 3 Enter allocated resources for each process: Process 1: 0.10 Process 2: 20 0 Process 3: 30 2 Process 4: 211 Process 5: 0 0 4 Enter available resources: 231 System is in a safe state. safe sequence is: 34512 N",
          "reading_order": 1,
          "pageNumber": 23
        }
      ]
    },
    {
      "pageNumber": 24,
      "processingTime": 1.97,
      "sourceImagePath": "temp_images\\page-24.png",
      "annotatedImagePath": "output\\annotated_frames\\page_24_annotated.png",
      "imageWidth": 725,
      "imageHeight": 1024,
      "detectionsCount": 12,
      "detections": [
        {
          "id": "page24_detection10",
          "bbox": [
            297,
            92,
            412,
            113
          ],
          "bbox_normalized": [
            0.4097,
            0.0898,
            0.5683,
            0.1104
          ],
          "label": "Section-header",
          "confidence": 0.742,
          "area": 2415,
          "center": [
            355,
            103
          ],
          "width": 115,
          "height": 21,
          "extractedText": "Experiment — 7",
          "reading_order": 1,
          "pageNumber": 24
        },
        {
          "id": "page24_detection8",
          "bbox": [
            83,
            146,
            467,
            163
          ],
          "bbox_normalized": [
            0.1145,
            0.1426,
            0.6441,
            0.1592
          ],
          "label": "Text",
          "confidence": 0.84,
          "area": 6528,
          "center": [
            275,
            155
          ],
          "width": 384,
          "height": 17,
          "extractedText": "Aim: Write a C program to simulate page replacement algorithm a) FIE",
          "reading_order": 2,
          "pageNumber": 24
        },
        {
          "id": "page24_detection7",
          "bbox": [
            81,
            177,
            162,
            197
          ],
          "bbox_normalized": [
            0.1117,
            0.1729,
            0.2234,
            0.1924
          ],
          "label": "Section-header",
          "confidence": 0.874,
          "area": 1620,
          "center": [
            122,
            187
          ],
          "width": 81,
          "height": 20,
          "extractedText": "Description",
          "reading_order": 3,
          "pageNumber": 24
        },
        {
          "id": "page24_detection1",
          "bbox": [
            81,
            209,
            645,
            257
          ],
          "bbox_normalized": [
            0.1117,
            0.2041,
            0.8897,
            0.251
          ],
          "label": "Text",
          "confidence": 0.979,
          "area": 27072,
          "center": [
            363,
            233
          ],
          "width": 564,
          "height": 48,
          "extractedText": "Page replacement algorithms are used when a program accesses more pages than can fit in memory. The algorithm needs to decide which page to replace when the memory is full. FIFO and LRU are two popular page replacement strategies:",
          "reading_order": 4,
          "pageNumber": 24
        },
        {
          "id": "page24_detection2",
          "bbox": [
            103,
            273,
            651,
            305
          ],
          "bbox_normalized": [
            0.1421,
            0.2666,
            0.8979,
            0.2979
          ],
          "label": "List-item",
          "confidence": 0.97,
          "area": 17536,
          "center": [
            377,
            289
          ],
          "width": 548,
          "height": 32,
          "extractedText": "+ FIFO (First-In-First-Out): In FIFO, the oldest page in memory (the one that was loaded first) is replaced when a new page needs to be loaded,",
          "reading_order": 5,
          "pageNumber": 24
        },
        {
          "id": "page24_detection3",
          "bbox": [
            103,
            304,
            628,
            336
          ],
          "bbox_normalized": [
            0.1421,
            0.2969,
            0.8662,
            0.3281
          ],
          "label": "List-item",
          "confidence": 0.97,
          "area": 16800,
          "center": [
            366,
            320
          ],
          "width": 525,
          "height": 32,
          "extractedText": "* LRU (Least Recently Used): In LRU, the page that has not been used for the longest time is replaced when a new page needs to be loaded,",
          "reading_order": 6,
          "pageNumber": 24
        },
        {
          "id": "page24_detection9",
          "bbox": [
            80,
            352,
            127,
            372
          ],
          "bbox_normalized": [
            0.1103,
            0.3438,
            0.1752,
            0.3633
          ],
          "label": "Section-header",
          "confidence": 0.775,
          "area": 940,
          "center": [
            104,
            362
          ],
          "width": 47,
          "height": 20,
          "extractedText": "Theor",
          "reading_order": 7,
          "pageNumber": 24
        },
        {
          "id": "page24_detection6",
          "bbox": [
            81,
            401,
            650,
            449
          ],
          "bbox_normalized": [
            0.1117,
            0.3916,
            0.8966,
            0.4385
          ],
          "label": "Text",
          "confidence": 0.919,
          "area": 27312,
          "center": [
            366,
            425
          ],
          "width": 569,
          "height": 48,
          "extractedText": "M1 FIFO (First-In-First-Out): FIFO is a simple page replacement algorithm. It keeps track of the pages in memory in the order they were loaded. When a new page needs to be loaded into memory and memory is full, it replaces the page that has been in memory the longest",
          "reading_order": 8,
          "pageNumber": 24
        },
        {
          "id": "page24_detection4",
          "bbox": [
            81,
            465,
            647,
            513
          ],
          "bbox_normalized": [
            0.1117,
            0.4541,
            0.8924,
            0.501
          ],
          "label": "Text",
          "confidence": 0.968,
          "area": 27168,
          "center": [
            364,
            489
          ],
          "width": 566,
          "height": 48,
          "extractedText": "\" LRU (Least Recently Used): LRU replaces the page that has not been used for the longest time. It keeps track of the access history of the pages and selects the least recently accessed page for replacement when needed.",
          "reading_order": 9,
          "pageNumber": 24
        },
        {
          "id": "page24_detection11",
          "bbox": [
            81,
            552,
            112,
            574
          ],
          "bbox_normalized": [
            0.1117,
            0.5391,
            0.1545,
            0.5605
          ],
          "label": "Section-header",
          "confidence": 0.689,
          "area": 682,
          "center": [
            97,
            563
          ],
          "width": 31,
          "height": 22,
          "extractedText": "Cod",
          "reading_order": 10,
          "pageNumber": 24
        },
        {
          "id": "page24_detection12",
          "bbox": [
            81,
            575,
            93,
            592
          ],
          "bbox_normalized": [
            0.1117,
            0.5615,
            0.1283,
            0.5781
          ],
          "label": "Section-header",
          "confidence": 0.556,
          "area": 204,
          "center": [
            87,
            584
          ],
          "width": 12,
          "height": 17,
          "extractedText": "e:",
          "reading_order": 11,
          "pageNumber": 24
        },
        {
          "id": "page24_detection5",
          "bbox": [
            80,
            607,
            386,
            1001
          ],
          "bbox_normalized": [
            0.1103,
            0.5928,
            0.5324,
            0.9775
          ],
          "label": "Text",
          "confidence": 0.963,
          "area": 120564,
          "center": [
            233,
            804
          ],
          "width": 306,
          "height": 394,
          "extractedText": "incline <sidio.&> void fifoPageReplacementint pages). intr nt capaci) | int pageFauts = 0: int framelcapacin int count = 0; for inti =0: = capaci: i++) rameli] 15 for (inti = 0; <n; iH) | int flag = 0: for inj =0:) < capaci: j++) { if (@ramelj) = pages() { flag: break; i i if(flag=0) { framefcount] = pages(: count = (count + 1) Yocapacin; pageFalis +; i i printf(’FIFO Page Faults: din’. pageFauls): }",
          "reading_order": 12,
          "pageNumber": 24
        }
      ]
    },
    {
      "pageNumber": 25,
      "processingTime": 1.26,
      "sourceImagePath": "temp_images\\page-25.png",
      "annotatedImagePath": "output\\annotated_frames\\page_25_annotated.png",
      "imageWidth": 725,
      "imageHeight": 1024,
      "detectionsCount": 2,
      "detections": [
        {
          "id": "page25_detection1",
          "bbox": [
            80,
            116,
            386,
            800
          ],
          "bbox_normalized": [
            0.1103,
            0.1133,
            0.5324,
            0.7813
          ],
          "label": "Text",
          "confidence": 0.945,
          "area": 209304,
          "center": [
            233,
            458
          ],
          "width": 306,
          "height": 684,
          "extractedText": "void frufageleplacement{int pages|], mtn, mt capaciiy) | int pageFaults = 0: int framelcapacin int timelcapuacin: int count = 0; for (inti =0: = capaci: i++) { framefi]=-1: time[i] =I: ) for inti =0ci< i++) { int flag = 0: for in = 0: < capaci: j++) { if @ramelj) = pages() { flag 1: timef] = count bres: ) ) if (flag=0) { inti =0; for (in = 1: < capaci j++) { if imefj] = timefinu) ru =: ) framefira] = pages(ls timeliru] = count pageFauls +; ) count; ) printf(\"LRU Page Faults: %d'n\", pageFaults); } int main) { int pages] = 17.0.1, 2.0,3.0,4.2,3,0,3.25; int n= sizeof{ pages) / sizeof{pages[0]): int capacity = 3: fifoPageReplacementpages, n, capacity): IuPageReplacament (pages, n. capacity): retum 0; ,",
          "reading_order": 1,
          "pageNumber": 25
        },
        {
          "id": "page25_detection2",
          "bbox": [
            89,
            863,
            502,
            925
          ],
          "bbox_normalized": [
            0.1228,
            0.8428,
            0.6924,
            0.9033
          ],
          "label": "Text",
          "confidence": 0.893,
          "area": 25606,
          "center": [
            296,
            894
          ],
          "width": 413,
          "height": 62,
          "extractedText": "\\B-7 } FIFO Page Faults: 10 LRU Page Faults: 9 PS D:\\Hemang\\hj AIMS\\voice-segregation\\smart Farm\\smart-farm",
          "reading_order": 2,
          "pageNumber": 25
        }
      ]
    },
    {
      "pageNumber": 26,
      "processingTime": 2.3,
      "sourceImagePath": "temp_images\\page-26.png",
      "annotatedImagePath": "output\\annotated_frames\\page_26_annotated.png",
      "imageWidth": 725,
      "imageHeight": 1024,
      "detectionsCount": 12,
      "detections": [
        {
          "id": "page26_detection10",
          "bbox": [
            297,
            92,
            412,
            113
          ],
          "bbox_normalized": [
            0.4097,
            0.0898,
            0.5683,
            0.1104
          ],
          "label": "Section-header",
          "confidence": 0.736,
          "area": 2415,
          "center": [
            355,
            103
          ],
          "width": 115,
          "height": 21,
          "extractedText": "Experiment — 8",
          "reading_order": 1,
          "pageNumber": 26
        },
        {
          "id": "page26_detection9",
          "bbox": [
            96,
            147,
            480,
            163
          ],
          "bbox_normalized": [
            0.1324,
            0.1436,
            0.6621,
            0.1592
          ],
          "label": "Text",
          "confidence": 0.748,
          "area": 6144,
          "center": [
            288,
            155
          ],
          "width": 384,
          "height": 16,
          "extractedText": "m: Write a C program to simulate page replacement algorithm a) LFU,",
          "reading_order": 2,
          "pageNumber": 26
        },
        {
          "id": "page26_detection7",
          "bbox": [
            81,
            177,
            167,
            197
          ],
          "bbox_normalized": [
            0.1117,
            0.1729,
            0.2303,
            0.1924
          ],
          "label": "Section-header",
          "confidence": 0.809,
          "area": 1720,
          "center": [
            124,
            187
          ],
          "width": 86,
          "height": 20,
          "extractedText": "Description:",
          "reading_order": 3,
          "pageNumber": 26
        },
        {
          "id": "page26_detection5",
          "bbox": [
            80,
            208,
            643,
            244
          ],
          "bbox_normalized": [
            0.1103,
            0.2031,
            0.8869,
            0.2383
          ],
          "label": "Text",
          "confidence": 0.955,
          "area": 20268,
          "center": [
            362,
            226
          ],
          "width": 563,
          "height": 36,
          "extractedText": "Page replacement algorithms are used when a program requires more memory than is available. In such cases, pages are replaced based on certain strategies:",
          "reading_order": 4,
          "pageNumber": 26
        },
        {
          "id": "page26_detection2",
          "bbox": [
            103,
            258,
            650,
            310
          ],
          "bbox_normalized": [
            0.1421,
            0.252,
            0.8966,
            0.3027
          ],
          "label": "List-item",
          "confidence": 0.978,
          "area": 28444,
          "center": [
            377,
            284
          ],
          "width": 547,
          "height": 52,
          "extractedText": "+ LFU (Least Frequently Used): The LFU algorithm replaces the page that has been used the least number of times. This means that pages that have not been frequently accessed are replaced first.",
          "reading_order": 5,
          "pageNumber": 26
        },
        {
          "id": "page26_detection3",
          "bbox": [
            103,
            309,
            646,
            361
          ],
          "bbox_normalized": [
            0.1421,
            0.3018,
            0.891,
            0.3525
          ],
          "label": "List-item",
          "confidence": 0.974,
          "area": 28236,
          "center": [
            375,
            335
          ],
          "width": 543,
          "height": 52,
          "extractedText": "+ Optimal: The Optimal page replacement algorithm replaces the page that will not be used for the longest period of time in the future. It is theoretically the best algorithm, but it requires knowledge of future page references, which is not possible in real scenarios.",
          "reading_order": 6,
          "pageNumber": 26
        },
        {
          "id": "page26_detection12",
          "bbox": [
            81,
            376,
            139,
            396
          ],
          "bbox_normalized": [
            0.1117,
            0.3672,
            0.1917,
            0.3867
          ],
          "label": "Section-header",
          "confidence": 0.676,
          "area": 1160,
          "center": [
            110,
            386
          ],
          "width": 58,
          "height": 20,
          "extractedText": "Theory:",
          "reading_order": 7,
          "pageNumber": 26
        },
        {
          "id": "page26_detection1",
          "bbox": [
            103,
            406,
            645,
            476
          ],
          "bbox_normalized": [
            0.1421,
            0.3965,
            0.8897,
            0.4648
          ],
          "label": "List-item",
          "confidence": 0.98,
          "area": 37940,
          "center": [
            374,
            441
          ],
          "width": 542,
          "height": 70,
          "extractedText": "+ LFU (Least Frequently Used): LFU replaces the page with the least frequency of access. The algorithm keeps track of the number of times each page is accessed. When a page fault occurs and a new page must be loaded, the page with the least access count is chosen for replacement.",
          "reading_order": 8,
          "pageNumber": 26
        },
        {
          "id": "page26_detection4",
          "bbox": [
            102,
            474,
            639,
            526
          ],
          "bbox_normalized": [
            0.1407,
            0.4629,
            0.8814,
            0.5137
          ],
          "label": "List-item",
          "confidence": 0.968,
          "area": 27924,
          "center": [
            371,
            500
          ],
          "width": 537,
          "height": 52,
          "extractedText": "+ Optimal: The Optimal algorithm is based on future page reference information. It predicts which page will be needed furthest in the future and replaces it. This algorithm is ideal but impractical, as it requires future knowledge.",
          "reading_order": 9,
          "pageNumber": 26
        },
        {
          "id": "page26_detection11",
          "bbox": [
            81,
            554,
            124,
            574
          ],
          "bbox_normalized": [
            0.1117,
            0.541,
            0.171,
            0.5605
          ],
          "label": "Section-header",
          "confidence": 0.73,
          "area": 860,
          "center": [
            103,
            564
          ],
          "width": 43,
          "height": 20,
          "extractedText": "Code:",
          "reading_order": 10,
          "pageNumber": 26
        },
        {
          "id": "page26_detection8",
          "bbox": [
            81,
            588,
            179,
            604
          ],
          "bbox_normalized": [
            0.1117,
            0.5742,
            0.2469,
            0.5898
          ],
          "label": "Text",
          "confidence": 0.76,
          "area": 1568,
          "center": [
            130,
            596
          ],
          "width": 98,
          "height": 16,
          "extractedText": "#include <stdio.h>",
          "reading_order": 11,
          "pageNumber": 26
        },
        {
          "id": "page26_detection6",
          "bbox": [
            83,
            621,
            383,
            1003
          ],
          "bbox_normalized": [
            0.1145,
            0.6064,
            0.5283,
            0.9795
          ],
          "label": "Text",
          "confidence": 0.946,
          "area": 114600,
          "center": [
            233,
            812
          ],
          "width": 300,
          "height": 382,
          "extractedText": "void IfuPageReplacement(int pages{], int, int capacity) | int pageFaults = 0: int frame{capaciny]. feclcapacin’: int count = 0; for (inti =0: = capaci: i++) { framefi]=-1: freqli] =O; } for (inti = 0; <n; i++) | int flag = 0: for inj =0:) < capaci: j++) { if @ramelj] = pages() { freq: flag 1: bres: i i if (flag=0) { int minFreq = fre0], minlndex = 0: for (in = 1: = capaci; j++) { if (eqlj] < minfrea) | ‘minFreq = freqj];",
          "reading_order": 12,
          "pageNumber": 26
        }
      ]
    },
    {
      "pageNumber": 27,
      "processingTime": 1.25,
      "sourceImagePath": "temp_images\\page-27.png",
      "annotatedImagePath": "output\\annotated_frames\\page_27_annotated.png",
      "imageWidth": 725,
      "imageHeight": 1024,
      "detectionsCount": 1,
      "detections": [
        {
          "id": "page27_detection1",
          "bbox": [
            78,
            85,
            504,
            993
          ],
          "bbox_normalized": [
            0.1076,
            0.083,
            0.6952,
            0.9697
          ],
          "label": "Text",
          "confidence": 0.895,
          "area": 386808,
          "center": [
            291,
            539
          ],
          "width": 426,
          "height": 908,
          "extractedText": "minlodex =: i } ramefminladex] = pages: freqlminindex] = 1: pageFaults +; i i printf(\"LFU Page Fauls: Yd, ageFault); i int findOptimalPage(int pages(]. nt in framel] nt currentndes, int capaci) | int maxDistance = pageToReplace =-1: for (inti =0: = capaci: i++) | ine for = currentindexs <i) | if rameli) = pags(j) { if > maxDistance) { maxDistance =j: pageToReplace ~framelil i bres: i i ifG=m{ rerum framefil i i retum page ToReplace: i void optimalPageReplacament(int pages(. int. int capaci) | int pageFaults = 0: int framelcapacin: for (inti =0: = capaci: i++) rameli] =~ 1: for (inti = 0; <n; i+) | int flag = 0: for inj = 03) < capaci: j++) { if (@ramelj] = pages() { flag: bres: i i if(flag=0) { if (i < capacity) | frameli] = pagestl: else { int pageToReplace = findOptimalPage(pages n frame, i+ 1, capaci): for (int = 05 capacins +4) | if (framelj) — pageToReplace) { frame(j] = pages; break:",
          "reading_order": 1,
          "pageNumber": 27
        }
      ]
    },
    {
      "pageNumber": 28,
      "processingTime": 0.97,
      "sourceImagePath": "temp_images\\page-28.png",
      "annotatedImagePath": "output\\annotated_frames\\page_28_annotated.png",
      "imageWidth": 725,
      "imageHeight": 1024,
      "detectionsCount": 2,
      "detections": [
        {
          "id": "page28_detection1",
          "bbox": [
            79,
            99,
            345,
            387
          ],
          "bbox_normalized": [
            0.109,
            0.0967,
            0.4759,
            0.3779
          ],
          "label": "Text",
          "confidence": 0.87,
          "area": 76608,
          "center": [
            212,
            243
          ],
          "width": 266,
          "height": 288,
          "extractedText": "’ ) ) pageFaulisi-+, ) ) printf(\"Optimal Page Faults: %dn\", pageFaults) ) int main() { int pages(] = {7,0,1,2,0,3,0.4,2,3,0.3,2); int n = sizeof pages) sizeof{pages[0] int capacity = 3; IfuPageReplacement (pages, n. capacity). optimalPageR placement (pages, n, capacity): retum 0; i",
          "reading_order": 1,
          "pageNumber": 28
        },
        {
          "id": "page28_detection2",
          "bbox": [
            91,
            463,
            484,
            522
          ],
          "bbox_normalized": [
            0.1255,
            0.4521,
            0.6676,
            0.5098
          ],
          "label": "Text",
          "confidence": 0.704,
          "area": 23187,
          "center": [
            288,
            493
          ],
          "width": 393,
          "height": 59,
          "extractedText": "N58} FU page Faults: 9 optimal Page Faults: 7 PS D:\\Hemang\\hj AIMS\\voice-segregation\\smart Farm\\smart-farm>",
          "reading_order": 2,
          "pageNumber": 28
        }
      ]
    },
    {
      "pageNumber": 29,
      "processingTime": 2.53,
      "sourceImagePath": "temp_images\\page-29.png",
      "annotatedImagePath": "output\\annotated_frames\\page_29_annotated.png",
      "imageWidth": 725,
      "imageHeight": 1024,
      "detectionsCount": 18,
      "detections": [
        {
          "id": "page29_detection14",
          "bbox": [
            297,
            92,
            413,
            113
          ],
          "bbox_normalized": [
            0.4097,
            0.0898,
            0.5697,
            0.1104
          ],
          "label": "Section-header",
          "confidence": 0.713,
          "area": 2436,
          "center": [
            355,
            103
          ],
          "width": 116,
          "height": 21,
          "extractedText": "Experiment — 9",
          "reading_order": 1,
          "pageNumber": 29
        },
        {
          "id": "page29_detection13",
          "bbox": [
            96,
            147,
            480,
            163
          ],
          "bbox_normalized": [
            0.1324,
            0.1436,
            0.6621,
            0.1592
          ],
          "label": "Text",
          "confidence": 0.744,
          "area": 6144,
          "center": [
            288,
            155
          ],
          "width": 384,
          "height": 16,
          "extractedText": "m: Write a C program to simulate producer-consumer problem using s¢",
          "reading_order": 2,
          "pageNumber": 29
        },
        {
          "id": "page29_detection18",
          "bbox": [
            81,
            189,
            167,
            209
          ],
          "bbox_normalized": [
            0.1117,
            0.1846,
            0.2303,
            0.2041
          ],
          "label": "Text",
          "confidence": 0.591,
          "area": 1720,
          "center": [
            124,
            199
          ],
          "width": 86,
          "height": 20,
          "extractedText": "Description:",
          "reading_order": 3,
          "pageNumber": 29
        },
        {
          "id": "page29_detection7",
          "bbox": [
            81,
            237,
            471,
            255
          ],
          "bbox_normalized": [
            0.1117,
            0.2314,
            0.6497,
            0.249
          ],
          "label": "Text",
          "confidence": 0.929,
          "area": 7020,
          "center": [
            276,
            246
          ],
          "width": 390,
          "height": 18,
          "extractedText": "The Producer-Consumer problem involves two main processes:",
          "reading_order": 4,
          "pageNumber": 29
        },
        {
          "id": "page29_detection8",
          "bbox": [
            103,
            288,
            494,
            306
          ],
          "bbox_normalized": [
            0.1421,
            0.2813,
            0.6814,
            0.2988
          ],
          "label": "List-item",
          "confidence": 0.921,
          "area": 7038,
          "center": [
            299,
            297
          ],
          "width": 391,
          "height": 18,
          "extractedText": "« The Consumer: This process consumes items from the buffer.",
          "reading_order": 5,
          "pageNumber": 29
        },
        {
          "id": "page29_detection6",
          "bbox": [
            102,
            270,
            594,
            289
          ],
          "bbox_normalized": [
            0.1407,
            0.2637,
            0.8193,
            0.2822
          ],
          "label": "List-item",
          "confidence": 0.931,
          "area": 9348,
          "center": [
            348,
            280
          ],
          "width": 492,
          "height": 19,
          "extractedText": "The Producer: This process generates items and stores them in a shared buffer.",
          "reading_order": 6,
          "pageNumber": 29
        },
        {
          "id": "page29_detection15",
          "bbox": [
            80,
            322,
            627,
            340
          ],
          "bbox_normalized": [
            0.1103,
            0.3145,
            0.8648,
            0.332
          ],
          "label": "Text",
          "confidence": 0.702,
          "area": 9846,
          "center": [
            354,
            331
          ],
          "width": 547,
          "height": 18,
          "extractedText": "The semaphore is a synchronization mechanism used to manage access to the shared buffer:",
          "reading_order": 7,
          "pageNumber": 29
        },
        {
          "id": "page29_detection2",
          "bbox": [
            102,
            354,
            613,
            390
          ],
          "bbox_normalized": [
            0.1407,
            0.3457,
            0.8455,
            0.3809
          ],
          "label": "List-item",
          "confidence": 0.962,
          "area": 18396,
          "center": [
            358,
            372
          ],
          "width": 511,
          "height": 36,
          "extractedText": "+ A mutex semaphore (binary semaphore) is used to ensure mutual exclusion while accessing the buffer.",
          "reading_order": 8,
          "pageNumber": 29
        },
        {
          "id": "page29_detection1",
          "bbox": [
            103,
            389,
            604,
            424
          ],
          "bbox_normalized": [
            0.1421,
            0.3799,
            0.8331,
            0.4141
          ],
          "label": "List-item",
          "confidence": 0.965,
          "area": 17535,
          "center": [
            354,
            407
          ],
          "width": 501,
          "height": 35,
          "extractedText": "+ A full semaphore is used to track how many items are in the buffer, ensuring the consumer waits if the buffer is empty.",
          "reading_order": 9,
          "pageNumber": 29
        },
        {
          "id": "page29_detection4",
          "bbox": [
            102,
            422,
            603,
            458
          ],
          "bbox_normalized": [
            0.1407,
            0.4121,
            0.8317,
            0.4473
          ],
          "label": "List-item",
          "confidence": 0.961,
          "area": 18036,
          "center": [
            353,
            440
          ],
          "width": 501,
          "height": 36,
          "extractedText": "+ An empty semaphore tracks how many empty spaces are available in the buffer, ensuring the producer waits if the buffer is full",
          "reading_order": 10,
          "pageNumber": 29
        },
        {
          "id": "page29_detection3",
          "bbox": [
            80,
            473,
            622,
            508
          ],
          "bbox_normalized": [
            0.1103,
            0.4619,
            0.8579,
            0.4961
          ],
          "label": "Text",
          "confidence": 0.961,
          "area": 18970,
          "center": [
            351,
            491
          ],
          "width": 542,
          "height": 35,
          "extractedText": "The problem can be solved by using semaphores to avoid race conditions and ensure proper synchronization between the producer and consumer.",
          "reading_order": 11,
          "pageNumber": 29
        },
        {
          "id": "page29_detection5",
          "bbox": [
            80,
            587,
            653,
            654
          ],
          "bbox_normalized": [
            0.1103,
            0.5732,
            0.9007,
            0.6387
          ],
          "label": "Text",
          "confidence": 0.944,
          "area": 38391,
          "center": [
            367,
            621
          ],
          "width": 573,
          "height": 67,
          "extractedText": "Producer-Consumer Problem: The producer-consumer problem involves two types of processes: the producer, which generates data (e.g., adding items to a buffer), and the consumer, which consumes data from this buffer. The buffer has limited capacity, so producers must wait if it's full, and consumers must wait if it's empty.",
          "reading_order": 12,
          "pageNumber": 29
        },
        {
          "id": "page29_detection17",
          "bbox": [
            83,
            654,
            467,
            671
          ],
          "bbox_normalized": [
            0.1145,
            0.6387,
            0.6441,
            0.6553
          ],
          "label": "Text",
          "confidence": 0.626,
          "area": 6528,
          "center": [
            275,
            663
          ],
          "width": 384,
          "height": 17,
          "extractedText": "Semaphores: Semaphores are used to handle process synchroniza",
          "reading_order": 13,
          "pageNumber": 29
        },
        {
          "id": "page29_detection16",
          "bbox": [
            80,
            687,
            302,
            702
          ],
          "bbox_normalized": [
            0.1103,
            0.6709,
            0.4166,
            0.6855
          ],
          "label": "Text",
          "confidence": 0.639,
          "area": 3330,
          "center": [
            191,
            695
          ],
          "width": 222,
          "height": 15,
          "extractedText": "2.A semaphore full tracks the filled slots.",
          "reading_order": 14,
          "pageNumber": 29
        },
        {
          "id": "page29_detection9",
          "bbox": [
            80,
            701,
            623,
            733
          ],
          "bbox_normalized": [
            0.1103,
            0.6846,
            0.8593,
            0.7158
          ],
          "label": "Text",
          "confidence": 0.91,
          "area": 17376,
          "center": [
            352,
            717
          ],
          "width": 543,
          "height": 32,
          "extractedText": "3.A mutex semaphore ensures mutual exclusion, allowing only one process to modify the buffer at a time.",
          "reading_order": 15,
          "pageNumber": 29
        },
        {
          "id": "page29_detection11",
          "bbox": [
            81,
            751,
            125,
            768
          ],
          "bbox_normalized": [
            0.1117,
            0.7334,
            0.1724,
            0.75
          ],
          "label": "Section-header",
          "confidence": 0.804,
          "area": 748,
          "center": [
            103,
            760
          ],
          "width": 44,
          "height": 17,
          "extractedText": "Code:",
          "reading_order": 16,
          "pageNumber": 29
        },
        {
          "id": "page29_detection10",
          "bbox": [
            81,
            787,
            183,
            837
          ],
          "bbox_normalized": [
            0.1117,
            0.7686,
            0.2524,
            0.8174
          ],
          "label": "Text",
          "confidence": 0.812,
          "area": 5100,
          "center": [
            132,
            812
          ],
          "width": 102,
          "height": 50,
          "extractedText": "#include <stdio.h> include <sidlibh> ¥include <unistd.h>",
          "reading_order": 17,
          "pageNumber": 29
        },
        {
          "id": "page29_detection12",
          "bbox": [
            81,
            856,
            224,
            923
          ],
          "bbox_normalized": [
            0.1117,
            0.8359,
            0.309,
            0.9014
          ],
          "label": "Text",
          "confidence": 0.762,
          "area": 9581,
          "center": [
            153,
            890
          ],
          "width": 143,
          "height": 67,
          "extractedText": "#define BUFFER SIZE 5 int buffer{BUFFER_SIZE]; int in= 0, out =0; int count = 0;",
          "reading_order": 18,
          "pageNumber": 29
        }
      ]
    },
    {
      "pageNumber": 30,
      "processingTime": 0.9,
      "sourceImagePath": "temp_images\\page-30.png",
      "annotatedImagePath": "output\\annotated_frames\\page_30_annotated.png",
      "imageWidth": 725,
      "imageHeight": 1024,
      "detectionsCount": 1,
      "detections": [
        {
          "id": "page30_detection1",
          "bbox": [
            80,
            99,
            416,
            708
          ],
          "bbox_normalized": [
            0.1103,
            0.0967,
            0.5738,
            0.6914
          ],
          "label": "Text",
          "confidence": 0.738,
          "area": 204624,
          "center": [
            248,
            404
          ],
          "width": 336,
          "height": 609,
          "extractedText": "Tetum; } bufferfin] = rem; in= (in 1) % BUFFER_SIZE; count; printf(\"Produced: Yd’, item): ] int consume() { if (count — 0) { printf{\"Buffr is empty. Waiting to consume.'n\"); retum 1; ) int tem = bufferfout]; out = (out + 1) % BUFFER_SIZE; count, printf(\" Consumed: %dn\", item): retum item; ] int main() { int items_to_produce = 10; int produce interval = I // seconds between produce actions int consume_interval =2; // seconds between consume actions for (inti = 0; i < tems_to_produce; i++) { produce + 1); sleep(produce_interval); if count 0) { consume); sleep(consume interval); ) )",
          "reading_order": 1,
          "pageNumber": 30
        }
      ]
    },
    {
      "pageNumber": 31,
      "processingTime": 0.33,
      "sourceImagePath": "temp_images\\page-31.png",
      "annotatedImagePath": "output\\annotated_frames\\page_31_annotated.png",
      "imageWidth": 725,
      "imageHeight": 1024,
      "detectionsCount": 0,
      "detections": []
    },
    {
      "pageNumber": 32,
      "processingTime": 1.95,
      "sourceImagePath": "temp_images\\page-32.png",
      "annotatedImagePath": "output\\annotated_frames\\page_32_annotated.png",
      "imageWidth": 725,
      "imageHeight": 1024,
      "detectionsCount": 9,
      "detections": [
        {
          "id": "page32_detection4",
          "bbox": [
            300,
            92,
            410,
            113
          ],
          "bbox_normalized": [
            0.4138,
            0.0898,
            0.5655,
            0.1104
          ],
          "label": "Section-header",
          "confidence": 0.764,
          "area": 2310,
          "center": [
            355,
            103
          ],
          "width": 110,
          "height": 21,
          "extractedText": "Experiment-10",
          "reading_order": 1,
          "pageNumber": 32
        },
        {
          "id": "page32_detection8",
          "bbox": [
            81,
            125,
            574,
            145
          ],
          "bbox_normalized": [
            0.1117,
            0.1221,
            0.7917,
            0.1416
          ],
          "label": "Text",
          "confidence": 0.547,
          "area": 9860,
          "center": [
            328,
            135
          ],
          "width": 493,
          "height": 20,
          "extractedText": "Aim: Write a C program to simulate disk scheduling algorithms a) FCFS, b) SCAN",
          "reading_order": 2,
          "pageNumber": 32
        },
        {
          "id": "page32_detection6",
          "bbox": [
            81,
            158,
            160,
            175
          ],
          "bbox_normalized": [
            0.1117,
            0.1543,
            0.2207,
            0.1709
          ],
          "label": "Section-header",
          "confidence": 0.699,
          "area": 1343,
          "center": [
            121,
            167
          ],
          "width": 79,
          "height": 17,
          "extractedText": "Description:",
          "reading_order": 3,
          "pageNumber": 32
        },
        {
          "id": "page32_detection1",
          "bbox": [
            80,
            189,
            620,
            241
          ],
          "bbox_normalized": [
            0.1103,
            0.1846,
            0.8552,
            0.2354
          ],
          "label": "Text",
          "confidence": 0.964,
          "area": 28080,
          "center": [
            350,
            215
          ],
          "width": 540,
          "height": 52,
          "extractedText": "This experiment implements two disk scheduling algorithms. FCFS services requests in the order they arrive, while SCAN moves the disk arm back and forth across the request queue, servicing requests as it reaches them in each direct",
          "reading_order": 4,
          "pageNumber": 32
        },
        {
          "id": "page32_detection7",
          "bbox": [
            81,
            254,
            134,
            272
          ],
          "bbox_normalized": [
            0.1117,
            0.248,
            0.1848,
            0.2656
          ],
          "label": "Text",
          "confidence": 0.636,
          "area": 954,
          "center": [
            108,
            263
          ],
          "width": 53,
          "height": 18,
          "extractedText": "Theory:",
          "reading_order": 5,
          "pageNumber": 32
        },
        {
          "id": "page32_detection2",
          "bbox": [
            80,
            285,
            635,
            337
          ],
          "bbox_normalized": [
            0.1103,
            0.2783,
            0.8759,
            0.3291
          ],
          "label": "Text",
          "confidence": 0.866,
          "area": 28860,
          "center": [
            358,
            311
          ],
          "width": 555,
          "height": 52,
          "extractedText": "FCFS (First-Come, First-Served): The simplest disk scheduling algorithm, where requests are serviced in the order they amive. While easy to implement, it does not optimize seek time, and requests on opposite sides of the disk can increase the time required.",
          "reading_order": 6,
          "pageNumber": 32
        },
        {
          "id": "page32_detection3",
          "bbox": [
            80,
            335,
            645,
            404
          ],
          "bbox_normalized": [
            0.1103,
            0.3271,
            0.8897,
            0.3945
          ],
          "label": "Text",
          "confidence": 0.821,
          "area": 38985,
          "center": [
            363,
            370
          ],
          "width": 565,
          "height": 69,
          "extractedText": "SCAN: Also known as the \"elevator algorithm,” SCAN moves the disk arm in one direction, servicing all requests, then reverses direction once the end is reached. This approach reduces the overall seek time by eliminating excessive arm movement and ensures that no requests are left waiting indefinitely.",
          "reading_order": 7,
          "pageNumber": 32
        },
        {
          "id": "page32_detection9",
          "bbox": [
            81,
            418,
            122,
            436
          ],
          "bbox_normalized": [
            0.1117,
            0.4082,
            0.1683,
            0.4258
          ],
          "label": "Section-header",
          "confidence": 0.522,
          "area": 738,
          "center": [
            102,
            427
          ],
          "width": 41,
          "height": 18,
          "extractedText": "Code:",
          "reading_order": 8,
          "pageNumber": 32
        },
        {
          "id": "page32_detection5",
          "bbox": [
            80,
            459,
            433,
            1011
          ],
          "bbox_normalized": [
            0.1103,
            0.4482,
            0.5972,
            0.9873
          ],
          "label": "Text",
          "confidence": 0.736,
          "area": 194856,
          "center": [
            257,
            735
          ],
          "width": 353,
          "height": 552,
          "extractedText": "#include <stdlib.h> void fefint requests], int, int ead) { int seck time 0; printf(\"nFCFS Disk Scheduling!in'): for (inti = 0; i< ni; 44) { printf{\"Moving from %d to %d\\n\", head, requests]: seek _time += abs(requesisli] - head); head = requess[i); ) printf(\"Total Seek Time (FCFS): %din\", sek_time): ] void scanlint requests() int n, int head. int direction, int disk size) { int seck time 0; printf(\"nSCAN Disk Scheduling\"); for (inti = 0; i< n- 1:4) { for (nj =i +13 < mj) | if (requests[i] > requests) { inttemp = requests requesis(i) = requests); requesis[j] = temp; ) ) ) int, current_position ~ head: if direction —1) { for i= 0; i< n && requess(i] < head: i++);",
          "reading_order": 9,
          "pageNumber": 32
        }
      ]
    },
    {
      "pageNumber": 33,
      "processingTime": 1.43,
      "sourceImagePath": "temp_images\\page-33.png",
      "annotatedImagePath": "output\\annotated_frames\\page_33_annotated.png",
      "imageWidth": 725,
      "imageHeight": 1024,
      "detectionsCount": 1,
      "detections": [
        {
          "id": "page33_detection1",
          "bbox": [
            80,
            94,
            458,
            997
          ],
          "bbox_normalized": [
            0.1103,
            0.0918,
            0.6317,
            0.9736
          ],
          "label": "Text",
          "confidence": 0.955,
          "area": 341334,
          "center": [
            269,
            546
          ],
          "width": 378,
          "height": 903,
          "extractedText": "while i <n) { printf\" Moving from %d to %din\", current_position, requests]. seck time += abs(reguesisi] - current position); current_position = requesisfi+ +1; } if (current_position < disk size - 1) { printf\" Moving from %d to %d\\n\", current_position, disk_size - seek time += abs(disk_size - | - curtent_position): current_position =disk_size - 1; ) for i i= 0; i) { printf\" Moving from %d to %d\\n\", current_position, requests]; seek time += abs(reguesisi] - current position); current_position = requests; } else | for(i =n - 1; i>=0 && requesis(i] > head: i=); while (>=0) { printf\" Moving from %d 0 %din\", current_position, requests]. seck time += abs(reguesisi] - current position); current_position = requestsfi-]: } if (curtent_position > 0) printf\" Moving from %d to %d\\n\", current_position, 0); seek time += current_position: current_position = 0: } for (i++ i <miith) { printf\" Moving from %d to %din\", current_position, requests]. seek time += abs(reguesisi] - current position); current_position = requests; ) ) printf(\"Total Seek Time (SCAN): %dn’, seck time); ] int main() { itn, head, direction, disk size; printf(\"Enter the number of requests: ): scanf(\" Yd\", &n): int requestsfnl; printf(\"Enter the requests\"); for (inti = 0: i< n: #4) { seanf(\"%od\", &requestsfl); ) printf(\"Enter initial head position: \"): scanf(\"%d\", &head); printf(\"Enter disk size: \"); scanfl\" id\", &disk_size);",
          "reading_order": 1,
          "pageNumber": 33
        }
      ]
    },
    {
      "pageNumber": 34,
      "processingTime": 0.42,
      "sourceImagePath": "temp_images\\page-34.png",
      "annotatedImagePath": "output\\annotated_frames\\page_34_annotated.png",
      "imageWidth": 725,
      "imageHeight": 1024,
      "detectionsCount": 2,
      "detections": [
        {
          "id": "page34_detection2",
          "bbox": [
            94,
            96,
            346,
            128
          ],
          "bbox_normalized": [
            0.1297,
            0.0938,
            0.4772,
            0.125
          ],
          "label": "Text",
          "confidence": 0.524,
          "area": 8064,
          "center": [
            220,
            112
          ],
          "width": 252,
          "height": 32,
          "extractedText": "printf(\"Enter direction (1 for high, 0 for low): *); scanf(\"%d\", &direction);",
          "reading_order": 1,
          "pageNumber": 34
        },
        {
          "id": "page34_detection1",
          "bbox": [
            81,
            296,
            133,
            312
          ],
          "bbox_normalized": [
            0.1117,
            0.2891,
            0.1834,
            0.3047
          ],
          "label": "Section-header",
          "confidence": 0.732,
          "area": 832,
          "center": [
            107,
            304
          ],
          "width": 52,
          "height": 16,
          "extractedText": "Output:",
          "reading_order": 2,
          "pageNumber": 34
        }
      ]
    }
  ],
  "ocrProcessingSuggestions": {
    "textElements": [
      {
        "id": "page1_detection5",
        "pageNumber": 1,
        "bbox": [
          186,
          139,
          564,
          168
        ],
        "bbox_normalized": [
          0.2569,
          0.1357,
          0.779,
          0.1641
        ],
        "priority": "high"
      },
      {
        "id": "page1_detection4",
        "pageNumber": 1,
        "bbox": [
          63,
          813,
          293,
          890
        ],
        "bbox_normalized": [
          0.087,
          0.7939,
          0.4047,
          0.8691
        ],
        "priority": "high"
      },
      {
        "id": "page1_detection2",
        "pageNumber": 1,
        "bbox": [
          438,
          778,
          652,
          902
        ],
        "bbox_normalized": [
          0.605,
          0.7598,
          0.9006,
          0.8809
        ],
        "priority": "high"
      },
      {
        "id": "page2_detection1",
        "pageNumber": 2,
        "bbox": [
          106,
          193,
          627,
          259
        ],
        "bbox_normalized": [
          0.1462,
          0.1885,
          0.8648,
          0.2529
        ],
        "priority": "high"
      },
      {
        "id": "page2_detection7",
        "pageNumber": 2,
        "bbox": [
          107,
          340,
          367,
          353
        ],
        "bbox_normalized": [
          0.1476,
          0.332,
          0.5062,
          0.3447
        ],
        "priority": "high"
      },
      {
        "id": "page4_detection4",
        "pageNumber": 4,
        "bbox": [
          81,
          155,
          641,
          195
        ],
        "bbox_normalized": [
          0.1117,
          0.1514,
          0.8841,
          0.1904
        ],
        "priority": "high"
      },
      {
        "id": "page4_detection3",
        "pageNumber": 4,
        "bbox": [
          81,
          275,
          633,
          377
        ],
        "bbox_normalized": [
          0.1117,
          0.2686,
          0.8731,
          0.3682
        ],
        "priority": "high"
      },
      {
        "id": "page4_detection2",
        "pageNumber": 4,
        "bbox": [
          80,
          425,
          650,
          527
        ],
        "bbox_normalized": [
          0.1103,
          0.415,
          0.8966,
          0.5146
        ],
        "priority": "high"
      },
      {
        "id": "page4_detection1",
        "pageNumber": 4,
        "bbox": [
          80,
          579,
          651,
          697
        ],
        "bbox_normalized": [
          0.1103,
          0.5654,
          0.8979,
          0.6807
        ],
        "priority": "high"
      },
      {
        "id": "page4_detection7",
        "pageNumber": 4,
        "bbox": [
          81,
          750,
          179,
          767
        ],
        "bbox_normalized": [
          0.1117,
          0.7324,
          0.2469,
          0.749
        ],
        "priority": "high"
      },
      {
        "id": "page4_detection6",
        "pageNumber": 4,
        "bbox": [
          79,
          786,
          290,
          854
        ],
        "bbox_normalized": [
          0.109,
          0.7676,
          0.4,
          0.834
        ],
        "priority": "high"
      },
      {
        "id": "page4_detection10",
        "pageNumber": 4,
        "bbox": [
          94,
          871,
          349,
          889
        ],
        "bbox_normalized": [
          0.1297,
          0.8506,
          0.4814,
          0.8682
        ],
        "priority": "high"
      },
      {
        "id": "page5_detection1",
        "pageNumber": 5,
        "bbox": [
          92,
          99,
          543,
          996
        ],
        "bbox_normalized": [
          0.1269,
          0.0967,
          0.749,
          0.9727
        ],
        "priority": "high"
      },
      {
        "id": "page6_detection2",
        "pageNumber": 6,
        "bbox": [
          83,
          96,
          539,
          299
        ],
        "bbox_normalized": [
          0.1145,
          0.0938,
          0.7434,
          0.292
        ],
        "priority": "high"
      },
      {
        "id": "page6_detection1",
        "pageNumber": 6,
        "bbox": [
          90,
          345,
          563,
          681
        ],
        "bbox_normalized": [
          0.1241,
          0.3369,
          0.7766,
          0.665
        ],
        "priority": "high"
      },
      {
        "id": "page7_detection4",
        "pageNumber": 7,
        "bbox": [
          81,
          155,
          641,
          195
        ],
        "bbox_normalized": [
          0.1117,
          0.1514,
          0.8841,
          0.1904
        ],
        "priority": "high"
      },
      {
        "id": "page7_detection1",
        "pageNumber": 7,
        "bbox": [
          80,
          255,
          648,
          323
        ],
        "bbox_normalized": [
          0.1103,
          0.249,
          0.8938,
          0.3154
        ],
        "priority": "high"
      },
      {
        "id": "page7_detection2",
        "pageNumber": 7,
        "bbox": [
          81,
          338,
          646,
          407
        ],
        "bbox_normalized": [
          0.1117,
          0.3301,
          0.891,
          0.3975
        ],
        "priority": "high"
      },
      {
        "id": "page7_detection5",
        "pageNumber": 7,
        "bbox": [
          80,
          459,
          640,
          528
        ],
        "bbox_normalized": [
          0.1103,
          0.4482,
          0.8828,
          0.5156
        ],
        "priority": "high"
      },
      {
        "id": "page7_detection3",
        "pageNumber": 7,
        "bbox": [
          80,
          543,
          632,
          596
        ],
        "bbox_normalized": [
          0.1103,
          0.5303,
          0.8717,
          0.582
        ],
        "priority": "high"
      },
      {
        "id": "page7_detection9",
        "pageNumber": 7,
        "bbox": [
          82,
          642,
          417,
          995
        ],
        "bbox_normalized": [
          0.1131,
          0.627,
          0.5752,
          0.9717
        ],
        "priority": "high"
      },
      {
        "id": "page8_detection1",
        "pageNumber": 8,
        "bbox": [
          79,
          94,
          576,
          995
        ],
        "bbox_normalized": [
          0.109,
          0.0918,
          0.7945,
          0.9717
        ],
        "priority": "high"
      },
      {
        "id": "page9_detection1",
        "pageNumber": 9,
        "bbox": [
          80,
          94,
          585,
          837
        ],
        "bbox_normalized": [
          0.1103,
          0.0918,
          0.8069,
          0.8174
        ],
        "priority": "high"
      },
      {
        "id": "page10_detection1",
        "pageNumber": 10,
        "bbox": [
          91,
          121,
          516,
          520
        ],
        "bbox_normalized": [
          0.1255,
          0.1182,
          0.7117,
          0.5078
        ],
        "priority": "high"
      },
      {
        "id": "page11_detection12",
        "pageNumber": 11,
        "bbox": [
          81,
          177,
          269,
          196
        ],
        "bbox_normalized": [
          0.1117,
          0.1729,
          0.371,
          0.1914
        ],
        "priority": "high"
      },
      {
        "id": "page11_detection3",
        "pageNumber": 11,
        "bbox": [
          81,
          256,
          651,
          324
        ],
        "bbox_normalized": [
          0.1117,
          0.25,
          0.8979,
          0.3164
        ],
        "priority": "high"
      },
      {
        "id": "page11_detection4",
        "pageNumber": 11,
        "bbox": [
          81,
          528,
          641,
          579
        ],
        "bbox_normalized": [
          0.1117,
          0.5156,
          0.8841,
          0.5654
        ],
        "priority": "high"
      },
      {
        "id": "page11_detection7",
        "pageNumber": 11,
        "bbox": [
          81,
          595,
          593,
          631
        ],
        "bbox_normalized": [
          0.1117,
          0.5811,
          0.8179,
          0.6162
        ],
        "priority": "high"
      },
      {
        "id": "page11_detection2",
        "pageNumber": 11,
        "bbox": [
          81,
          645,
          630,
          698
        ],
        "bbox_normalized": [
          0.1117,
          0.6299,
          0.869,
          0.6816
        ],
        "priority": "high"
      },
      {
        "id": "page11_detection13",
        "pageNumber": 11,
        "bbox": [
          81,
          733,
          179,
          751
        ],
        "bbox_normalized": [
          0.1117,
          0.7158,
          0.2469,
          0.7334
        ],
        "priority": "high"
      },
      {
        "id": "page11_detection8",
        "pageNumber": 11,
        "bbox": [
          81,
          769,
          439,
          993
        ],
        "bbox_normalized": [
          0.1117,
          0.751,
          0.6055,
          0.9697
        ],
        "priority": "high"
      },
      {
        "id": "page12_detection1",
        "pageNumber": 12,
        "bbox": [
          80,
          97,
          615,
          997
        ],
        "bbox_normalized": [
          0.1103,
          0.0947,
          0.8483,
          0.9736
        ],
        "priority": "high"
      },
      {
        "id": "page13_detection1",
        "pageNumber": 13,
        "bbox": [
          80,
          90,
          614,
          992
        ],
        "bbox_normalized": [
          0.1103,
          0.0879,
          0.8469,
          0.9688
        ],
        "priority": "high"
      },
      {
        "id": "page15_detection6",
        "pageNumber": 15,
        "bbox": [
          105,
          159,
          673,
          203
        ],
        "bbox_normalized": [
          0.1326,
          0.1553,
          0.8497,
          0.1982
        ],
        "priority": "high"
      },
      {
        "id": "page15_detection2",
        "pageNumber": 15,
        "bbox": [
          105,
          265,
          676,
          339
        ],
        "bbox_normalized": [
          0.1326,
          0.2588,
          0.8535,
          0.3311
        ],
        "priority": "high"
      },
      {
        "id": "page15_detection3",
        "pageNumber": 15,
        "bbox": [
          105,
          355,
          670,
          446
        ],
        "bbox_normalized": [
          0.1326,
          0.3467,
          0.846,
          0.4355
        ],
        "priority": "high"
      },
      {
        "id": "page15_detection5",
        "pageNumber": 15,
        "bbox": [
          105,
          498,
          670,
          554
        ],
        "bbox_normalized": [
          0.1326,
          0.4863,
          0.846,
          0.541
        ],
        "priority": "high"
      },
      {
        "id": "page15_detection4",
        "pageNumber": 15,
        "bbox": [
          105,
          570,
          661,
          607
        ],
        "bbox_normalized": [
          0.1326,
          0.5566,
          0.8346,
          0.5928
        ],
        "priority": "high"
      },
      {
        "id": "page15_detection1",
        "pageNumber": 15,
        "bbox": [
          105,
          624,
          655,
          679
        ],
        "bbox_normalized": [
          0.1326,
          0.6094,
          0.827,
          0.6631
        ],
        "priority": "high"
      },
      {
        "id": "page15_detection9",
        "pageNumber": 15,
        "bbox": [
          106,
          719,
          207,
          735
        ],
        "bbox_normalized": [
          0.1338,
          0.7021,
          0.2614,
          0.7178
        ],
        "priority": "high"
      },
      {
        "id": "page15_detection10",
        "pageNumber": 15,
        "bbox": [
          106,
          755,
          443,
          936
        ],
        "bbox_normalized": [
          0.1338,
          0.7373,
          0.5593,
          0.9141
        ],
        "priority": "high"
      },
      {
        "id": "page15_detection11",
        "pageNumber": 15,
        "bbox": [
          118,
          958,
          345,
          993
        ],
        "bbox_normalized": [
          0.149,
          0.9355,
          0.4356,
          0.9697
        ],
        "priority": "high"
      },
      {
        "id": "page16_detection1",
        "pageNumber": 16,
        "bbox": [
          104,
          94,
          532,
          756
        ],
        "bbox_normalized": [
          0.1313,
          0.0918,
          0.6717,
          0.7383
        ],
        "priority": "high"
      },
      {
        "id": "page17_detection2",
        "pageNumber": 17,
        "bbox": [
          111,
          144,
          674,
          444
        ],
        "bbox_normalized": [
          0.1402,
          0.1406,
          0.851,
          0.4336
        ],
        "priority": "high"
      },
      {
        "id": "page18_detection2",
        "pageNumber": 18,
        "bbox": [
          104,
          140,
          674,
          183
        ],
        "bbox_normalized": [
          0.1313,
          0.1367,
          0.851,
          0.1787
        ],
        "priority": "high"
      },
      {
        "id": "page18_detection1",
        "pageNumber": 18,
        "bbox": [
          104,
          238,
          683,
          364
        ],
        "bbox_normalized": [
          0.1313,
          0.2324,
          0.8624,
          0.3555
        ],
        "priority": "high"
      },
      {
        "id": "page18_detection5",
        "pageNumber": 18,
        "bbox": [
          105,
          423,
          660,
          461
        ],
        "bbox_normalized": [
          0.1326,
          0.4131,
          0.8333,
          0.4502
        ],
        "priority": "high"
      },
      {
        "id": "page18_detection7",
        "pageNumber": 18,
        "bbox": [
          105,
          460,
          637,
          497
        ],
        "bbox_normalized": [
          0.1326,
          0.4492,
          0.8043,
          0.4854
        ],
        "priority": "high"
      },
      {
        "id": "page18_detection3",
        "pageNumber": 18,
        "bbox": [
          105,
          500,
          675,
          555
        ],
        "bbox_normalized": [
          0.1326,
          0.4883,
          0.8523,
          0.542
        ],
        "priority": "high"
      },
      {
        "id": "page18_detection9",
        "pageNumber": 18,
        "bbox": [
          105,
          600,
          207,
          616
        ],
        "bbox_normalized": [
          0.1326,
          0.5859,
          0.2614,
          0.6016
        ],
        "priority": "high"
      },
      {
        "id": "page18_detection4",
        "pageNumber": 18,
        "bbox": [
          107,
          636,
          421,
          1005
        ],
        "bbox_normalized": [
          0.1351,
          0.6211,
          0.5316,
          0.9814
        ],
        "priority": "high"
      },
      {
        "id": "page19_detection1",
        "pageNumber": 19,
        "bbox": [
          117,
          93,
          417,
          996
        ],
        "bbox_normalized": [
          0.1477,
          0.0908,
          0.5265,
          0.9727
        ],
        "priority": "high"
      },
      {
        "id": "page20_detection2",
        "pageNumber": 20,
        "bbox": [
          104,
          96,
          292,
          203
        ],
        "bbox_normalized": [
          0.1313,
          0.0938,
          0.3687,
          0.1982
        ],
        "priority": "high"
      },
      {
        "id": "page20_detection1",
        "pageNumber": 20,
        "bbox": [
          106,
          241,
          679,
          583
        ],
        "bbox_normalized": [
          0.1338,
          0.2354,
          0.8573,
          0.5693
        ],
        "priority": "high"
      },
      {
        "id": "page21_detection8",
        "pageNumber": 21,
        "bbox": [
          82,
          156,
          642,
          171
        ],
        "bbox_normalized": [
          0.1131,
          0.1523,
          0.8855,
          0.167
        ],
        "priority": "high"
      },
      {
        "id": "page21_detection1",
        "pageNumber": 21,
        "bbox": [
          81,
          219,
          642,
          365
        ],
        "bbox_normalized": [
          0.1117,
          0.2139,
          0.8855,
          0.3564
        ],
        "priority": "high"
      },
      {
        "id": "page21_detection3",
        "pageNumber": 21,
        "bbox": [
          82,
          411,
          642,
          448
        ],
        "bbox_normalized": [
          0.1131,
          0.4014,
          0.8855,
          0.4375
        ],
        "priority": "high"
      },
      {
        "id": "page21_detection4",
        "pageNumber": 21,
        "bbox": [
          80,
          454,
          641,
          492
        ],
        "bbox_normalized": [
          0.1103,
          0.4434,
          0.8841,
          0.4805
        ],
        "priority": "high"
      },
      {
        "id": "page21_detection2",
        "pageNumber": 21,
        "bbox": [
          80,
          497,
          642,
          557
        ],
        "bbox_normalized": [
          0.1103,
          0.4854,
          0.8855,
          0.5439
        ],
        "priority": "high"
      },
      {
        "id": "page21_detection10",
        "pageNumber": 21,
        "bbox": [
          82,
          603,
          176,
          620
        ],
        "bbox_normalized": [
          0.1131,
          0.5889,
          0.2428,
          0.6055
        ],
        "priority": "high"
      },
      {
        "id": "page21_detection9",
        "pageNumber": 21,
        "bbox": [
          85,
          630,
          378,
          1002
        ],
        "bbox_normalized": [
          0.1172,
          0.6152,
          0.5214,
          0.9785
        ],
        "priority": "high"
      },
      {
        "id": "page22_detection1",
        "pageNumber": 22,
        "bbox": [
          90,
          95,
          371,
          979
        ],
        "bbox_normalized": [
          0.1241,
          0.0928,
          0.5117,
          0.9561
        ],
        "priority": "high"
      },
      {
        "id": "page23_detection1",
        "pageNumber": 23,
        "bbox": [
          97,
          185,
          679,
          516
        ],
        "bbox_normalized": [
          0.1338,
          0.1807,
          0.9366,
          0.5039
        ],
        "priority": "high"
      },
      {
        "id": "page24_detection8",
        "pageNumber": 24,
        "bbox": [
          83,
          146,
          467,
          163
        ],
        "bbox_normalized": [
          0.1145,
          0.1426,
          0.6441,
          0.1592
        ],
        "priority": "high"
      },
      {
        "id": "page24_detection1",
        "pageNumber": 24,
        "bbox": [
          81,
          209,
          645,
          257
        ],
        "bbox_normalized": [
          0.1117,
          0.2041,
          0.8897,
          0.251
        ],
        "priority": "high"
      },
      {
        "id": "page24_detection6",
        "pageNumber": 24,
        "bbox": [
          81,
          401,
          650,
          449
        ],
        "bbox_normalized": [
          0.1117,
          0.3916,
          0.8966,
          0.4385
        ],
        "priority": "high"
      },
      {
        "id": "page24_detection4",
        "pageNumber": 24,
        "bbox": [
          81,
          465,
          647,
          513
        ],
        "bbox_normalized": [
          0.1117,
          0.4541,
          0.8924,
          0.501
        ],
        "priority": "high"
      },
      {
        "id": "page24_detection5",
        "pageNumber": 24,
        "bbox": [
          80,
          607,
          386,
          1001
        ],
        "bbox_normalized": [
          0.1103,
          0.5928,
          0.5324,
          0.9775
        ],
        "priority": "high"
      },
      {
        "id": "page25_detection1",
        "pageNumber": 25,
        "bbox": [
          80,
          116,
          386,
          800
        ],
        "bbox_normalized": [
          0.1103,
          0.1133,
          0.5324,
          0.7813
        ],
        "priority": "high"
      },
      {
        "id": "page25_detection2",
        "pageNumber": 25,
        "bbox": [
          89,
          863,
          502,
          925
        ],
        "bbox_normalized": [
          0.1228,
          0.8428,
          0.6924,
          0.9033
        ],
        "priority": "high"
      },
      {
        "id": "page26_detection9",
        "pageNumber": 26,
        "bbox": [
          96,
          147,
          480,
          163
        ],
        "bbox_normalized": [
          0.1324,
          0.1436,
          0.6621,
          0.1592
        ],
        "priority": "high"
      },
      {
        "id": "page26_detection5",
        "pageNumber": 26,
        "bbox": [
          80,
          208,
          643,
          244
        ],
        "bbox_normalized": [
          0.1103,
          0.2031,
          0.8869,
          0.2383
        ],
        "priority": "high"
      },
      {
        "id": "page26_detection8",
        "pageNumber": 26,
        "bbox": [
          81,
          588,
          179,
          604
        ],
        "bbox_normalized": [
          0.1117,
          0.5742,
          0.2469,
          0.5898
        ],
        "priority": "high"
      },
      {
        "id": "page26_detection6",
        "pageNumber": 26,
        "bbox": [
          83,
          621,
          383,
          1003
        ],
        "bbox_normalized": [
          0.1145,
          0.6064,
          0.5283,
          0.9795
        ],
        "priority": "high"
      },
      {
        "id": "page27_detection1",
        "pageNumber": 27,
        "bbox": [
          78,
          85,
          504,
          993
        ],
        "bbox_normalized": [
          0.1076,
          0.083,
          0.6952,
          0.9697
        ],
        "priority": "high"
      },
      {
        "id": "page28_detection1",
        "pageNumber": 28,
        "bbox": [
          79,
          99,
          345,
          387
        ],
        "bbox_normalized": [
          0.109,
          0.0967,
          0.4759,
          0.3779
        ],
        "priority": "high"
      },
      {
        "id": "page28_detection2",
        "pageNumber": 28,
        "bbox": [
          91,
          463,
          484,
          522
        ],
        "bbox_normalized": [
          0.1255,
          0.4521,
          0.6676,
          0.5098
        ],
        "priority": "high"
      },
      {
        "id": "page29_detection13",
        "pageNumber": 29,
        "bbox": [
          96,
          147,
          480,
          163
        ],
        "bbox_normalized": [
          0.1324,
          0.1436,
          0.6621,
          0.1592
        ],
        "priority": "high"
      },
      {
        "id": "page29_detection18",
        "pageNumber": 29,
        "bbox": [
          81,
          189,
          167,
          209
        ],
        "bbox_normalized": [
          0.1117,
          0.1846,
          0.2303,
          0.2041
        ],
        "priority": "high"
      },
      {
        "id": "page29_detection7",
        "pageNumber": 29,
        "bbox": [
          81,
          237,
          471,
          255
        ],
        "bbox_normalized": [
          0.1117,
          0.2314,
          0.6497,
          0.249
        ],
        "priority": "high"
      },
      {
        "id": "page29_detection15",
        "pageNumber": 29,
        "bbox": [
          80,
          322,
          627,
          340
        ],
        "bbox_normalized": [
          0.1103,
          0.3145,
          0.8648,
          0.332
        ],
        "priority": "high"
      },
      {
        "id": "page29_detection3",
        "pageNumber": 29,
        "bbox": [
          80,
          473,
          622,
          508
        ],
        "bbox_normalized": [
          0.1103,
          0.4619,
          0.8579,
          0.4961
        ],
        "priority": "high"
      },
      {
        "id": "page29_detection5",
        "pageNumber": 29,
        "bbox": [
          80,
          587,
          653,
          654
        ],
        "bbox_normalized": [
          0.1103,
          0.5732,
          0.9007,
          0.6387
        ],
        "priority": "high"
      },
      {
        "id": "page29_detection17",
        "pageNumber": 29,
        "bbox": [
          83,
          654,
          467,
          671
        ],
        "bbox_normalized": [
          0.1145,
          0.6387,
          0.6441,
          0.6553
        ],
        "priority": "high"
      },
      {
        "id": "page29_detection16",
        "pageNumber": 29,
        "bbox": [
          80,
          687,
          302,
          702
        ],
        "bbox_normalized": [
          0.1103,
          0.6709,
          0.4166,
          0.6855
        ],
        "priority": "high"
      },
      {
        "id": "page29_detection9",
        "pageNumber": 29,
        "bbox": [
          80,
          701,
          623,
          733
        ],
        "bbox_normalized": [
          0.1103,
          0.6846,
          0.8593,
          0.7158
        ],
        "priority": "high"
      },
      {
        "id": "page29_detection10",
        "pageNumber": 29,
        "bbox": [
          81,
          787,
          183,
          837
        ],
        "bbox_normalized": [
          0.1117,
          0.7686,
          0.2524,
          0.8174
        ],
        "priority": "high"
      },
      {
        "id": "page29_detection12",
        "pageNumber": 29,
        "bbox": [
          81,
          856,
          224,
          923
        ],
        "bbox_normalized": [
          0.1117,
          0.8359,
          0.309,
          0.9014
        ],
        "priority": "high"
      },
      {
        "id": "page30_detection1",
        "pageNumber": 30,
        "bbox": [
          80,
          99,
          416,
          708
        ],
        "bbox_normalized": [
          0.1103,
          0.0967,
          0.5738,
          0.6914
        ],
        "priority": "high"
      },
      {
        "id": "page32_detection8",
        "pageNumber": 32,
        "bbox": [
          81,
          125,
          574,
          145
        ],
        "bbox_normalized": [
          0.1117,
          0.1221,
          0.7917,
          0.1416
        ],
        "priority": "high"
      },
      {
        "id": "page32_detection1",
        "pageNumber": 32,
        "bbox": [
          80,
          189,
          620,
          241
        ],
        "bbox_normalized": [
          0.1103,
          0.1846,
          0.8552,
          0.2354
        ],
        "priority": "high"
      },
      {
        "id": "page32_detection7",
        "pageNumber": 32,
        "bbox": [
          81,
          254,
          134,
          272
        ],
        "bbox_normalized": [
          0.1117,
          0.248,
          0.1848,
          0.2656
        ],
        "priority": "high"
      },
      {
        "id": "page32_detection2",
        "pageNumber": 32,
        "bbox": [
          80,
          285,
          635,
          337
        ],
        "bbox_normalized": [
          0.1103,
          0.2783,
          0.8759,
          0.3291
        ],
        "priority": "high"
      },
      {
        "id": "page32_detection3",
        "pageNumber": 32,
        "bbox": [
          80,
          335,
          645,
          404
        ],
        "bbox_normalized": [
          0.1103,
          0.3271,
          0.8897,
          0.3945
        ],
        "priority": "high"
      },
      {
        "id": "page32_detection5",
        "pageNumber": 32,
        "bbox": [
          80,
          459,
          433,
          1011
        ],
        "bbox_normalized": [
          0.1103,
          0.4482,
          0.5972,
          0.9873
        ],
        "priority": "high"
      },
      {
        "id": "page33_detection1",
        "pageNumber": 33,
        "bbox": [
          80,
          94,
          458,
          997
        ],
        "bbox_normalized": [
          0.1103,
          0.0918,
          0.6317,
          0.9736
        ],
        "priority": "high"
      },
      {
        "id": "page34_detection2",
        "pageNumber": 34,
        "bbox": [
          94,
          96,
          346,
          128
        ],
        "bbox_normalized": [
          0.1297,
          0.0938,
          0.4772,
          0.125
        ],
        "priority": "high"
      }
    ],
    "titleElements": [
      {
        "id": "page1_detection3",
        "pageNumber": 1,
        "bbox": [
          91,
          448,
          662,
          522
        ],
        "bbox_normalized": [
          0.1257,
          0.4375,
          0.9144,
          0.5098
        ],
        "priority": "highest"
      }
    ],
    "tableElements": [
      {
        "id": "page3_detection1",
        "pageNumber": 3,
        "bbox": [
          73,
          159,
          657,
          906
        ],
        "bbox_normalized": [
          0.1007,
          0.1553,
          0.9062,
          0.8848
        ],
        "priority": "high",
        "processingNote": "Use table-specific OCR for better structure recognition"
      }
    ],
    "listElements": [
      {
        "id": "page2_detection8",
        "pageNumber": 2,
        "bbox": [
          76,
          370,
          603,
          413
        ],
        "bbox_normalized": [
          0.1048,
          0.3613,
          0.8317,
          0.4033
        ],
        "priority": "medium"
      },
      {
        "id": "page2_detection4",
        "pageNumber": 2,
        "bbox": [
          76,
          430,
          617,
          475
        ],
        "bbox_normalized": [
          0.1048,
          0.4199,
          0.851,
          0.4639
        ],
        "priority": "medium"
      },
      {
        "id": "page2_detection5",
        "pageNumber": 2,
        "bbox": [
          76,
          493,
          503,
          506
        ],
        "bbox_normalized": [
          0.1048,
          0.4814,
          0.6938,
          0.4941
        ],
        "priority": "medium"
      },
      {
        "id": "page2_detection2",
        "pageNumber": 2,
        "bbox": [
          76,
          557,
          594,
          601
        ],
        "bbox_normalized": [
          0.1048,
          0.5439,
          0.8193,
          0.5869
        ],
        "priority": "medium"
      },
      {
        "id": "page11_detection5",
        "pageNumber": 11,
        "bbox": [
          103,
          339,
          628,
          392
        ],
        "bbox_normalized": [
          0.1421,
          0.3311,
          0.8662,
          0.3828
        ],
        "priority": "medium"
      },
      {
        "id": "page11_detection1",
        "pageNumber": 11,
        "bbox": [
          103,
          389,
          645,
          426
        ],
        "bbox_normalized": [
          0.1421,
          0.3799,
          0.8897,
          0.416
        ],
        "priority": "medium"
      },
      {
        "id": "page11_detection6",
        "pageNumber": 11,
        "bbox": [
          102,
          424,
          636,
          460
        ],
        "bbox_normalized": [
          0.1407,
          0.4141,
          0.8772,
          0.4492
        ],
        "priority": "medium"
      },
      {
        "id": "page24_detection2",
        "pageNumber": 24,
        "bbox": [
          103,
          273,
          651,
          305
        ],
        "bbox_normalized": [
          0.1421,
          0.2666,
          0.8979,
          0.2979
        ],
        "priority": "medium"
      },
      {
        "id": "page24_detection3",
        "pageNumber": 24,
        "bbox": [
          103,
          304,
          628,
          336
        ],
        "bbox_normalized": [
          0.1421,
          0.2969,
          0.8662,
          0.3281
        ],
        "priority": "medium"
      },
      {
        "id": "page26_detection2",
        "pageNumber": 26,
        "bbox": [
          103,
          258,
          650,
          310
        ],
        "bbox_normalized": [
          0.1421,
          0.252,
          0.8966,
          0.3027
        ],
        "priority": "medium"
      },
      {
        "id": "page26_detection3",
        "pageNumber": 26,
        "bbox": [
          103,
          309,
          646,
          361
        ],
        "bbox_normalized": [
          0.1421,
          0.3018,
          0.891,
          0.3525
        ],
        "priority": "medium"
      },
      {
        "id": "page26_detection1",
        "pageNumber": 26,
        "bbox": [
          103,
          406,
          645,
          476
        ],
        "bbox_normalized": [
          0.1421,
          0.3965,
          0.8897,
          0.4648
        ],
        "priority": "medium"
      },
      {
        "id": "page26_detection4",
        "pageNumber": 26,
        "bbox": [
          102,
          474,
          639,
          526
        ],
        "bbox_normalized": [
          0.1407,
          0.4629,
          0.8814,
          0.5137
        ],
        "priority": "medium"
      },
      {
        "id": "page29_detection8",
        "pageNumber": 29,
        "bbox": [
          103,
          288,
          494,
          306
        ],
        "bbox_normalized": [
          0.1421,
          0.2813,
          0.6814,
          0.2988
        ],
        "priority": "medium"
      },
      {
        "id": "page29_detection6",
        "pageNumber": 29,
        "bbox": [
          102,
          270,
          594,
          289
        ],
        "bbox_normalized": [
          0.1407,
          0.2637,
          0.8193,
          0.2822
        ],
        "priority": "medium"
      },
      {
        "id": "page29_detection2",
        "pageNumber": 29,
        "bbox": [
          102,
          354,
          613,
          390
        ],
        "bbox_normalized": [
          0.1407,
          0.3457,
          0.8455,
          0.3809
        ],
        "priority": "medium"
      },
      {
        "id": "page29_detection1",
        "pageNumber": 29,
        "bbox": [
          103,
          389,
          604,
          424
        ],
        "bbox_normalized": [
          0.1421,
          0.3799,
          0.8331,
          0.4141
        ],
        "priority": "medium"
      },
      {
        "id": "page29_detection4",
        "pageNumber": 29,
        "bbox": [
          102,
          422,
          603,
          458
        ],
        "bbox_normalized": [
          0.1407,
          0.4121,
          0.8317,
          0.4473
        ],
        "priority": "medium"
      }
    ]
  }
}